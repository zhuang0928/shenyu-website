[{"author":"xiaoyu","categories":"Apache ShenYu","content":" Apache ICLA 签署流程指南 Apache CLA 全称 Apache Contributor License Agreement，签署ICLA的目的是定义向ASF贡献的文档，保护知识产权，避免后续法律纠纷。ICLA在官方存档后生效，贡献者方可参与Apache项目。\n当我们需要签署ICLA时步骤如下:\n1. 打开链接 官网Licenses 在Contributor License Agreements 下找到CLAs并进入页面。\n2. 在页面上方我们可以看到两个下载链接，选择ICLA(个人CLA)并下载文件。\n3. 打开PDF，ICLA需要填写的是两个部分，均需要全英文填写。\n 注意事项:\n 姓名需要填写拼音，姓与名之间空一格，首字母均为大写，名在前姓氏在后。 Committer相关的签署，则preferred Apache id(s)是必填项。   4.文件最下方的署名。 官网支持手写或者PDF签名软件\n5.签署完之后将icla.pdf命令为 姓名拼音-icla.pdf 发送到导师提供的邮箱\n6.邮箱发送成功之后Apache ShenYu 官方社区告知下\n手动签名和PDF软件签名DEMO  PDF在线签名\n 下载PDF源文件 填写项目与个人信息 打开PDF在线签署网址 进入签名 保存下载已签名pdf 发送到指定邮箱 更新石墨icla 签署状态文档    手写签名\n 下载PDF源文件 填写项目与个人信息n 打印文件 手写签名 拍照转成单个pdf 文件 发送到指定邮箱 更新石墨icla 签署状态文档   邮件发送模板 ","date":1621296000,"description":"签署ICLA指南","dir":"community/icla/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"4a4d1943efa5df25d4266a1fa6004c8227fa78a0","permalink":"/zh/community/icla/","publishdate":"2021-05-18T00:00:00Z","readingtime":2,"relpermalink":"/zh/community/icla/","summary":"Apache ICLA 签署流程指南 Apache CLA 全称 Apache Contributor License Agreement，签署ICLA的目的是定义向ASF贡献的文档，保护知识产权，避免后续法律纠纷。ICLA在官方","tags":["ICLA"],"title":"ICLA 签署指南","type":"community","url":"/zh/community/icla/","wordcount":541},{"author":"xiaoyu","categories":"ShenYu","content":" Apache Sign ICLA Guide Apache CLA short for Apache Contributor License Agreement, the purpose of this agreement is to clearly define the terms under which intellectual property has been contributed to the ASF and thereby allow us to defend the project should there be a legal dispute regarding the software at some future time. A signed ICLA is required to be on file before an individual is given commit rights to any ASF project.\nThe process of submitting ICLA are:\n1. First, click the link Apache Licenses and find CLAs under the Contributor License Agreements section.\n2. At the top of the page, there are two download links choose ICLA(Individual Contributor License Agreement) and download it.\n3. Open the PDF, and fill in the following columns in English.\n To be noticed:\n Leave a space between family name and last name, remember capitalize the first letter, please write family name at first. Preferred Apache id(s) is a required field for committers.   4. The signature at the bottom of the document: Apache only accept hand-written signature or PDF signature software\n5.After signing, send the icla.pdf command as username-icla.pdf to the email address provided by the instructor\n6.After the email is sent successfully, Apache ShenYu official community informs\nManual signature and PDF software signature Demo  PDF online signature\n Download the PDF source file Fill in items and personal information Open PDF and sign URL online Signature Save and download signed pdf fils Send to the specified mailbox icla Sign status document    Handwritten signature\n Download the PDF source file Fill in items and personal information Print documents Handwritten signature Convert photos into single pdf file Send to the specified mailbox icla Sign status document   Email Template ","date":1621296000,"description":"Sign ICLA Guide","dir":"community/icla/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"1fea7065a95ef361f03921da5b8637c17b91c69c","permalink":"/community/icla/","publishdate":"2021-05-18T00:00:00Z","readingtime":1,"relpermalink":"/community/icla/","summary":"Apache Sign ICLA Guide Apache CLA short for Apache Contributor License Agreement, the purpose of this agreement is to clearly define the terms under which intellectual property has been contributed to the ASF and thereby allow us to defend the project should there be a legal dispute regarding the software at some future time. A signed ICLA is required to be on file before an individual is given commit rights","tags":["ICLA"],"title":"Sign ICLA Guide","type":"community","url":"/community/icla/","wordcount":282},{"author":"nuo-promise","categories":"ShenYu","content":" 目标  Apache Dubbo 插件介绍  元数据介绍  Apache Dubbo 插件配置  Bootstrap pom 配置 soul-admin 配置 dubbo服务pom配置  Apache Dubbo 泛化调用介绍  通过API方式使用泛化调用 通过spring使用泛化调用 泛化调用实现流程  ShenYuDubbo 插件调用解析  ApachDubboPlugin泛化调用准备 ApacheDubboProxySerivce DubboResponsePlugin WebFluxResultUtils返回结果  Dubbo泛化调用介绍 总结 参考\nApache Dubbo 插件介绍 Apache Dubbo 是一款高性能、轻量级的开源Java服务框架,主要提供了六大核心能力,面向接口代理的高性能RPC调用,智能容错和负载均衡,服务自动注册与发现,高度可扩展能力,运行期流量调度,可视化的服务治理与运维。 网关中Dubbo插件主要是将 Http协议 转换成 Dubbo协议 ,也是网关实现Dubbo泛化调用的关键。而Dubbo插件需要配合 元数据 才能实现Dubbo调用。\n元数据介绍 元数据作用就是在进行协议转换时候要获取真实的请求 path 、methodName 、 parameterTypes 为泛化调用做好准备\n   在数据库中,我们有一张表单独存储Dubbo元信息，通过数据同步方案,会把这张表的数据同步到网关的JVM内存中 表结构如下\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;应用名称\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径,不能重复\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径描述\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc类型\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;服务名称\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;方法名称\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;参数类型 多个参数类型 逗号隔开\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc的扩展信息，json格式\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;更新时间\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;启用状态\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   path 字段主要是在请求网关的时候,会根据你的 path 字段来匹配到一条数据,然后进行后续的处理流程 rpc_ext 字段如果代理的接口是 Dubbo 类型的服务接口,同时设置了 group version 字段时候,那么信息就会存储到 rpc_ext 中  每一个 Dubbo 接口方法会应对一条元数据,对比SpringCloud、http分别是只存储一条/contextPath/** 和不存储  Apache Dubbo 插件配置 soul-bootstrap pom 配置 \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${curator.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${curator.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; …","date":1616457600,"description":"ShenYu Gateway Learning Apache Dubbo Plugin","dir":"blog/shenyu_source_learning_22_apache_dubbo/","fuzzywordcount":3800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"efdf7284be4272224f1ef7bbacc3c04749651640","permalink":"/blog/shenyu_source_learning_22_apache_dubbo/","publishdate":"2021-03-23T00:00:00Z","readingtime":8,"relpermalink":"/blog/shenyu_source_learning_22_apache_dubbo/","summary":"目标 Apache Dubbo 插件介绍 元数据介绍 Apache Dubbo 插件配置 Bootstrap pom 配置 soul-admin 配置 dubbo服务pom配置 Apache Dubbo 泛化调用介绍 通过API方式使用泛化调用 通过spring使用泛","tags":["ShenYu"],"title":"ShenYu Gateway Learning Apache Dubbo Plugin","type":"blog","url":"/blog/shenyu_source_learning_22_apache_dubbo/","wordcount":3742},{"author":"nuo-promise","categories":"ShenYu","content":" 目标  Apache Dubbo 插件介绍  元数据介绍  Apache Dubbo 插件配置  Bootstrap pom 配置 soul-admin 配置 dubbo服务pom配置  Apache Dubbo 泛化调用介绍  通过API方式使用泛化调用 通过spring使用泛化调用 泛化调用实现流程  ShenYu Dubbo 插件调用解析  ApachDubboPlugin泛化调用准备 ApacheDubboProxySerivce DubboResponsePlugin WebFluxResultUtils返回结果  Dubbo泛化调用介绍 总结 参考\nApache Dubbo 插件介绍 Apache Dubbo 是一款高性能、轻量级的开源Java服务框架,主要提供了六大核心能力,面向接口代理的高性能RPC调用,智能容错和负载均衡,服务自动注册与发现,高度可扩展能力,运行期流量调度,可视化的服务治理与运维。 网关中Dubbo插件主要是将 Http协议 转换成 Dubbo协议 ,也是网关实现Dubbo泛化调用的关键。而Dubbo插件需要配合 元数据 才能实现Dubbo调用。\n元数据介绍 元数据作用就是在进行协议转换时候要获取真实的请求 path 、methodName 、 parameterTypes 为泛化调用做好准备\n   在数据库中,我们有一张表单独存储Dubbo元信息，通过数据同步方案,会把这张表的数据同步到网关的JVM内存中 表结构如下\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;应用名称\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径,不能重复\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径描述\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc类型\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;服务名称\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;方法名称\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;参数类型 多个参数类型 逗号隔开\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc的扩展信息，json格式\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;更新时间\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;启用状态\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   path 字段主要是在请求网关的时候,会根据你的 path 字段来匹配到一条数据,然后进行后续的处理流程 rpc_ext 字段如果代理的接口是 Dubbo 类型的服务接口,同时设置了 group version 字段时候,那么信息就会存储到 rpc_ext 中  每一个 Dubbo 接口方法会应对一条元数据,对比SpringCloud、http分别是只存储一条/contextPath/** 和不存储  Apache Dubbo 插件配置 soul-bootstrap pom 配置 \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${curator.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${curator.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; …","date":1616457600,"description":"ShenYu网关学习Apache Dubbo插件原理解析","dir":"blog/shenyu_source_learning_22_apache_dubbo/","fuzzywordcount":3800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"892282f8fc1cfc561fdb5813daafe0679ff20686","permalink":"/zh/blog/shenyu_source_learning_22_apache_dubbo/","publishdate":"2021-03-23T00:00:00Z","readingtime":8,"relpermalink":"/zh/blog/shenyu_source_learning_22_apache_dubbo/","summary":"目标 Apache Dubbo 插件介绍 元数据介绍 Apache Dubbo 插件配置 Bootstrap pom 配置 soul-admin 配置 dubbo服务pom配置 Apache Dubbo 泛化调用介绍 通过API方式使用泛化调用 通过spring使用泛","tags":["ShenYu"],"title":"ShenYu网关学习Apache Dubbo插件原理解析","type":"blog","url":"/zh/blog/shenyu_source_learning_22_apache_dubbo/","wordcount":3745},{"author":"yanbing","categories":"ShenYu","content":" 目标  什么是Resilience4J soul的Resilience4j体验  限流 熔断  Resilience4J插件源码解读  什么是Resilience4j  Resilience4J是Spring Cloud Gateway推荐的容错方案，它是一个轻量级的容错库 借鉴了Hystrix而设计，并且采用JDK8 这个函数式编程，即lambda表达式 相比之下， Netflix Hystrix 对Archaius 具有编译依赖性，Resilience4j你无需引用全部依赖，可以根据自己需要的功能引用相关的模块即可 Hystrix不更新了，Spring提供Netflix Hystrix的替换方案，即Resilence4J Resilience4J 提供了一系列增强微服务的可用性功能：\n 断路器 CircuitBreaker 限流 RateLimiter 基于信号量的隔离 缓存 限时 Timelimiter 请求重启 Retry  官方提供的依赖包\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.github.resilience4j\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;resilience4j-circuitbreaker\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${resilience.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  soul的Resilience4j体验  首先在soul-admin控制台插件管理开启Resilience4j  在soul网关添加依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   启动三个服务,分别是一个soul-admin，一个soul-bootstrap，一个soul-examples-http\n 在soul-admin控制台找到插件列表的Resilience4j，自定义配置，如下图，  soul官网的配置介绍\n* Resilience4j处理详解： * timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。 * limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。 * limitForPeriod：每次刷新令牌的数量，默认值：50。 * circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。 * timeoutDuration：熔断超时时间，单位ms，默认值：30000。 * fallbackUri：降级处理的uri。 * slidingWindowSize：滑动窗口大小，默认值：100。 * slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。 * minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。 * waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。 * permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。 * failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。 * automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。   限流  参数配置 如下是参数配置校验，参数值小于默认值，会直接赋值默认值，因此方便测试效果直接修改源码的配置 ： 每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s，超时时间为1s  /** * check filed default value. * * @param resilience4JHandle {@linkplain Resilience4JHandle} * @return {@linkplain Resilience4JHandle} */ public Resilience4JHandle checkData(final Resilience4JHandle resilience4JHandle) { resilience4JHandle.setTimeoutDurationRate(Math.max(resilience4JHandle.getTimeoutDurationRate(), Constants.TIMEOUT_DURATION_RATE)); //resilience4JHandle.setLimitRefreshPeriod(Math.max(resilience4JHandle.getLimitRefreshPeriod(), Constants.LIMIT_REFRESH_PERIOD)); //resilience4JHandle.setLimitForPeriod(Math.max(resilience4JHandle.getLimitForPeriod(), Constants.LIMIT_FOR_PERIOD)); //每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s resilience4JHandle.setLimitRefreshPeriod(1000); resilience4JHandle.setLimitForPeriod(2); resilience4JHandle.setTimeoutDuration(1000); resilience4JHandle.setCircuitEnable(Math.max(resilience4JHandle.getCircuitEnable(), Constants.CIRCUIT_ENABLE)); //resilience4JHandle.setTimeoutDuration(Math.max(resilience4JHandle.getTimeoutDuration(), Constants.TIMEOUT_DURATION)); resilience4JHandle.setFallbackUri(!\u0026amp;quot;0\u0026amp;quot;.equals(resilience4JHandle.getFallbackUri()) ? resilience4JHandle.getFallbackUri() : \u0026amp;quot;\u0026amp;quot;); …","date":1616371200,"description":"ShenYu Gateway Learning Resilience4j Plugin","dir":"blog/shenyu_source_learning_21_resilience4j/","fuzzywordcount":2600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"8a1a5afecdc8a56bbed0d3bb160eced61ca89116","permalink":"/blog/shenyu_source_learning_21_resilience4j/","publishdate":"2021-03-22T00:00:00Z","readingtime":6,"relpermalink":"/blog/shenyu_source_learning_21_resilience4j/","summary":"目标 什么是Resilience4J soul的Resilience4j体验 限流 熔断 Resilience4J插件源码解读 什么是Resilienc","tags":["ShenYu"],"title":"ShenYu Gateway Learning Resilience4j Plugin","type":"blog","url":"/blog/shenyu_source_learning_21_resilience4j/","wordcount":2581},{"author":"闫兵","categories":"ShenYu","content":" 目标  什么是Resilience4J soul的Resilience4j体验  限流 熔断  Resilience4J插件源码解读  什么是Resilience4j  Resilience4J是Spring Cloud Gateway推荐的容错方案，它是一个轻量级的容错库 借鉴了Hystrix而设计，并且采用JDK8 这个函数式编程，即lambda表达式 相比之下， Netflix Hystrix 对Archaius 具有编译依赖性，Resilience4j你无需引用全部依赖，可以根据自己需要的功能引用相关的模块即可 Hystrix不更新了，Spring提供Netflix Hystrix的替换方案，即Resilence4J Resilience4J 提供了一系列增强微服务的可用性功能：\n 断路器 CircuitBreaker 限流 RateLimiter 基于信号量的隔离 缓存 限时 Timelimiter 请求重启 Retry  官方提供的依赖包\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.github.resilience4j\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;resilience4j-circuitbreaker\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${resilience.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  soul的Resilience4j体验  首先在soul-admin控制台插件管理开启Resilience4j  在soul网关添加依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   启动三个服务,分别是一个soul-admin，一个soul-bootstrap，一个soul-examples-http\n 在soul-admin控制台找到插件列表的Resilience4j，自定义配置，如下图，  soul官网的配置介绍\n* Resilience4j处理详解： * timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。 * limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。 * limitForPeriod：每次刷新令牌的数量，默认值：50。 * circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。 * timeoutDuration：熔断超时时间，单位ms，默认值：30000。 * fallbackUri：降级处理的uri。 * slidingWindowSize：滑动窗口大小，默认值：100。 * slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。 * minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。 * waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。 * permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。 * failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。 * automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。   限流  参数配置 如下是参数配置校验，参数值小于默认值，会直接赋值默认值，因此方便测试效果直接修改源码的配置 ： 每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s，超时时间为1s  /** * check filed default value. * * @param resilience4JHandle {@linkplain Resilience4JHandle} * @return {@linkplain Resilience4JHandle} */ public Resilience4JHandle checkData(final Resilience4JHandle resilience4JHandle) { resilience4JHandle.setTimeoutDurationRate(Math.max(resilience4JHandle.getTimeoutDurationRate(), Constants.TIMEOUT_DURATION_RATE)); //resilience4JHandle.setLimitRefreshPeriod(Math.max(resilience4JHandle.getLimitRefreshPeriod(), Constants.LIMIT_REFRESH_PERIOD)); //resilience4JHandle.setLimitForPeriod(Math.max(resilience4JHandle.getLimitForPeriod(), Constants.LIMIT_FOR_PERIOD)); //每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s resilience4JHandle.setLimitRefreshPeriod(1000); resilience4JHandle.setLimitForPeriod(2); resilience4JHandle.setTimeoutDuration(1000); resilience4JHandle.setCircuitEnable(Math.max(resilience4JHandle.getCircuitEnable(), Constants.CIRCUIT_ENABLE)); //resilience4JHandle.setTimeoutDuration(Math.max(resilience4JHandle.getTimeoutDuration(), Constants.TIMEOUT_DURATION)); resilience4JHandle.setFallbackUri(!\u0026amp;quot;0\u0026amp;quot;.equals(resilience4JHandle.getFallbackUri()) ? resilience4JHandle.getFallbackUri() : \u0026amp;quot;\u0026amp;quot;); …","date":1616371200,"description":"ShenYu网关学习Resilience4j插件原理解析","dir":"blog/shenyu_source_learning_21_resilience4j/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"34084e2445a70f72ca532feeeb2c4b432896189d","permalink":"/zh/blog/shenyu_source_learning_21_resilience4j/","publishdate":"2021-03-22T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/shenyu_source_learning_21_resilience4j/","summary":"目标 什么是Resilience4J soul的Resilience4j体验 限流 熔断 Resilience4J插件源码解读 什么是Resilienc","tags":["ShenYu"],"title":"ShenYu网关学习Resilience4j插件原理解析","type":"blog","url":"/zh/blog/shenyu_source_learning_21_resilience4j/","wordcount":2581},{"author":"luoxiaolong","categories":"ShenYu","content":" 概述 在业务网关中熔断和流量控制都是非常必要的功能。soul在实现这部分功能时使用了不同的成熟组件，用户可以根据自己的喜好选择。本文将介绍如何在soul中使用阿里的Sentinel组件实现熔断及流控功能。本文首先会介绍熔断和流控的场景及意义。然后介绍如何在soul上配置使用sentinel插件做流控和熔断。最后从源码的层面简略分析soul是如何使用Sentinel组件的。\n熔断和流量控制 场景描述 业务网关作为流量的入口，有保护后继服务的职责。以下两个对服务有严重危害的场景在生产中经常会遇到，也是业务网关必须要关注处理的问题。一种情况是在比如双11或双12这些大型促销时，接口的请求量是平时是数倍，如果没有评估好容量，这种激增的请求很容易导致整个服务完全不可用。这种宕机往往不是因为业务逻辑的漏洞而是因为请求过多资源不够导致的。另一种情况是在整个服务体系中有一些核心服务，多个业务流程都依赖该服务。然而是服务都有出现处理不稳定或者服务损坏的情况，导致请求处理时间长或者老是频繁抛出异常。排除业务BUG的情况，可能就是突发的非常随机的阻塞，一般减缓请求量就会自动修复，但是如果不加保护就有出现多米诺效应导致整个服务不可用。此场景和第一种场景有略微不同，第一种场景是实际流量确实出现了不可处理的峰值，而第二种场景主要考虑的是服务本身出现了不可避免、不可预测的抖动而引发的连锁反应。\n流量控制 针对第一种场景我们通常的做法是进行流量控制，核心思路是业务网关保证打到后面的请求是业务可以承受的量，多余的请求直接拒绝或者加入等待队列，保证服务不会宕掉，大部分请求还是可以正常处理。在考虑流量控制的策略时，我们应该主要思考以下几个问题：\n 通过什么角度控制流量？ 阈值是多少？ 流量控制的策略是什么？  对于第一个问题，正常思路是通过QPS来监控流量，即每秒钟请求的数量超过某限额时进行流控。但其实还有一种思路是从并发数来监控流量。这种控制场景也是非常有意义的，例如当下游应用由于某种原因导致服务不稳定、响应延迟增加，对于网关来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。从某种意义上讲通过并发进行流控可以一定程度上保护网关服务本身。对于第二个问题阈值来说比较好理解，就是触发流控的边界，如果从QPS来考虑就是每秒达到多少时开始流控，从并发数来考量的话就是请求上下文的线程数目超过多少进行流控。对于第三个问题，我们一般有以下3中处理方案：\n 直接拒绝，这种策略非常好理解就是当QPS高于阈值时直接拒接服务，不把请求传输到后面的服务中。 预热启动，这个策略所针对的场景是系统长期处于低水位的情况下，可能出现流量突然增加时，而直接把系统拉升到高水位可能瞬间把系统压垮。预热启动的方式是让阈值缓慢增加，在一定时间内逐渐增加阈值直至达到设置，给冷系统一个预热的时间，避免冷系统被压垮。对于超出阈值的请求也是触发拒绝。 匀速排队，此策略核心思路是以固定间隔时间让请求通过。当请求到来的时候，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；若预期的通过时间超出最大排队时长，则直接拒接这个请求。  熔断 针对第二种场景通常的处理方式是设置服务熔断。简单的说就是当我们探测的一个服务出现了异常，则不再访问它以免更多的请求对它造成更大的压力。一段时间后如果探测到服务恢复了再将流量发送过去。我们首先需要判断出这个服务是否出现了不稳定\\抖动的情况。然后思考如果发现了抖动的服务我们应该怎么办。如何判断服务是否恢复正常了。对于服务是否不稳定这一点我们一般可以通过一下3个方式进行判断。\n 慢调用比例：当单位统计时长内请求数目大于设置的最小请求数目，并且超过最大忍受时间的请求大于阈值，则判断服务异常，触发熔断； 异常比例：当单位统计时长内异常请求的比例大于阈值则我们判定服务异常，触发熔断； 异常数：当单位时长内出现异常的请求的数量的达到阈值则判定服务异常，触发熔断；  当我们通过以上3个指标判断服务为异常并熔断服务后，对于一定时间内（熔断时长内）的请求我们可以选择直接报错，不阻塞上游服务，让请求方来自行决定如何处理。或者直接触发服务降级。服务降级粗略的可以理解为请求此业务的简版，该简版省掉了很多非核心流程，并且只是最终保证流程处理完（最终一致性）。和现实中的熔断一样服务熔断是会自动恢复的。一般是触发熔断后的一段时间内服务处于熔断状态不提供服务，然后进入半开状态，若接下来的少量请求没有报错且响应时间合理则服务恢复，如果还是异常则继续熔断。\nsoul中的Sentinel插件 Sentinel是阿里开源的面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。Soul作为国内优秀的开源网关，将Sentinel整合为插件融入了自己的体系中，使用户通过简单的配置就可以使用Sentinel提供的流量控制和服务熔断功能。下面将简要介绍在soul中如何配置使用sentinel插件。\n首先登陆soul管理平台在\u0026amp;rdquo;插件列表\u0026amp;rdquo; \u0026amp;ndash;\u0026amp;gt; \u0026amp;ldquo;sentinel\u0026amp;rdquo;中配置插件。其中\u0026amp;rdquo;选择器\u0026amp;rdquo;的配置不是本文的重点不再介绍，点击\u0026amp;rdquo;增加规则\u0026amp;rdquo;来进行具体设置如下图。\n在这个配置页面中\u0026amp;rdquo;名称\u0026amp;rdquo;、\u0026amp;rdquo;匹配方式\u0026amp;rdquo;、\u0026amp;rdquo;条件\u0026amp;rdquo;、\u0026amp;rdquo;日志打印\u0026amp;rdquo;、\u0026amp;rdquo;是否开启\u0026amp;rdquo;、\u0026amp;rdquo;执行顺序\u0026amp;rdquo;属于soul插件的常规配置这里也不再赘述。我们重点需要关注的是\u0026amp;rdquo;处理\u0026amp;rdquo;中的配置项。这些配置项主要可以分为2组，前4个选项是关于熔断的配置，后4个选项是关于流量控制的配置。在soul中我们可以针对某一组请求同时设置它的流量控制和熔断策略。下面来重点分析下各个配置项如何使用。\n熔断 首先来看熔断相关的配置，它有四个配置项\u0026amp;rdquo;熔断阈值\u0026amp;rdquo;、\u0026amp;rdquo;是否开启熔断\u0026amp;rdquo;、\u0026amp;rdquo;熔断窗口大小\u0026amp;rdquo;以及没有注名字的是服务异常判断方式。熔断开关表示是否开启熔断（1开\\0不开）。熔断窗口大小指的是触发熔断后经过多少秒后进入半开状态，在半开状态如果请求正常则会进入正常状态如果请求依然不正常则继续熔断。熔断判定方式和熔断阈值需要结合来看。soul中使用了sentinel的3种服务异常判定方式。分别是：\n 慢调用比例，在此模式下阈值指的是判定为慢调用的毫秒数。慢调用的比例默认是1不能更改即单位统计时长内全部超过阈值则触发熔断。该模式是sentinel的默认模式。 异常比例，在此模式下阈值指的是单位统计时长内异常请求的比例上限，需要填写1个[0.0, 1.0]的数，表示0%-100% 异常数策略，在该模式下阈值指的是单位统计时间内异常请求个数的上限。  需要注意的是soul对于单位统计时 …","date":1616112000,"description":"ShenYu Gateway Learning Sentinel Plugin","dir":"blog/shenyu_source_learning_20_sentinel/","fuzzywordcount":5500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"c8dc8e8ae45160bf65a614acb2f4aa0e59893025","permalink":"/blog/shenyu_source_learning_20_sentinel/","publishdate":"2021-03-19T00:00:00Z","readingtime":11,"relpermalink":"/blog/shenyu_source_learning_20_sentinel/","summary":"概述 在业务网关中熔断和流量控制都是非常必要的功能。soul在实现这部分功能时使用了不同的成熟组件，用户可以根据自己的喜好选择。本文将介绍如何","tags":["ShenYu"],"title":"ShenYu Gateway Learning Sentinel Plugin","type":"blog","url":"/blog/shenyu_source_learning_20_sentinel/","wordcount":5435},{"author":"骆潇龙","categories":"ShenYu","content":" 概述 在业务网关中熔断和流量控制都是非常必要的功能。soul在实现这部分功能时使用了不同的成熟组件，用户可以根据自己的喜好选择。本文将介绍如何在soul中使用阿里的Sentinel组件实现熔断及流控功能。本文首先会介绍熔断和流控的场景及意义。然后介绍如何在soul上配置使用sentinel插件做流控和熔断。最后从源码的层面简略分析soul是如何使用Sentinel组件的。\n熔断和流量控制 场景描述 业务网关作为流量的入口，有保护后继服务的职责。以下两个对服务有严重危害的场景在生产中经常会遇到，也是业务网关必须要关注处理的问题。一种情况是在比如双11或双12这些大型促销时，接口的请求量是平时是数倍，如果没有评估好容量，这种激增的请求很容易导致整个服务完全不可用。这种宕机往往不是因为业务逻辑的漏洞而是因为请求过多资源不够导致的。另一种情况是在整个服务体系中有一些核心服务，多个业务流程都依赖该服务。然而是服务都有出现处理不稳定或者服务损坏的情况，导致请求处理时间长或者老是频繁抛出异常。排除业务BUG的情况，可能就是突发的非常随机的阻塞，一般减缓请求量就会自动修复，但是如果不加保护就有出现多米诺效应导致整个服务不可用。此场景和第一种场景有略微不同，第一种场景是实际流量确实出现了不可处理的峰值，而第二种场景主要考虑的是服务本身出现了不可避免、不可预测的抖动而引发的连锁反应。\n流量控制 针对第一种场景我们通常的做法是进行流量控制，核心思路是业务网关保证打到后面的请求是业务可以承受的量，多余的请求直接拒绝或者加入等待队列，保证服务不会宕掉，大部分请求还是可以正常处理。在考虑流量控制的策略时，我们应该主要思考以下几个问题：\n 通过什么角度控制流量？ 阈值是多少？ 流量控制的策略是什么？  对于第一个问题，正常思路是通过QPS来监控流量，即每秒钟请求的数量超过某限额时进行流控。但其实还有一种思路是从并发数来监控流量。这种控制场景也是非常有意义的，例如当下游应用由于某种原因导致服务不稳定、响应延迟增加，对于网关来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。从某种意义上讲通过并发进行流控可以一定程度上保护网关服务本身。对于第二个问题阈值来说比较好理解，就是触发流控的边界，如果从QPS来考虑就是每秒达到多少时开始流控，从并发数来考量的话就是请求上下文的线程数目超过多少进行流控。对于第三个问题，我们一般有以下3中处理方案：\n 直接拒绝，这种策略非常好理解就是当QPS高于阈值时直接拒接服务，不把请求传输到后面的服务中。 预热启动，这个策略所针对的场景是系统长期处于低水位的情况下，可能出现流量突然增加时，而直接把系统拉升到高水位可能瞬间把系统压垮。预热启动的方式是让阈值缓慢增加，在一定时间内逐渐增加阈值直至达到设置，给冷系统一个预热的时间，避免冷系统被压垮。对于超出阈值的请求也是触发拒绝。 匀速排队，此策略核心思路是以固定间隔时间让请求通过。当请求到来的时候，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；若预期的通过时间超出最大排队时长，则直接拒接这个请求。  熔断 针对第二种场景通常的处理方式是设置服务熔断。简单的说就是当我们探测的一个服务出现了异常，则不再访问它以免更多的请求对它造成更大的压力。一段时间后如果探测到服务恢复了再将流量发送过去。我们首先需要判断出这个服务是否出现了不稳定\\抖动的情况。然后思考如果发现了抖动的服务我们应该怎么办。如何判断服务是否恢复正常了。对于服务是否不稳定这一点我们一般可以通过一下3个方式进行判断。\n 慢调用比例：当单位统计时长内请求数目大于设置的最小请求数目，并且超过最大忍受时间的请求大于阈值，则判断服务异常，触发熔断； 异常比例：当单位统计时长内异常请求的比例大于阈值则我们判定服务异常，触发熔断； 异常数：当单位时长内出现异常的请求的数量的达到阈值则判定服务异常，触发熔断；  当我们通过以上3个指标判断服务为异常并熔断服务后，对于一定时间内（熔断时长内）的请求我们可以选择直接报错，不阻塞上游服务，让请求方来自行决定如何处理。或者直接触发服务降级。服务降级粗略的可以理解为请求此业务的简版，该简版省掉了很多非核心流程，并且只是最终保证流程处理完（最终一致性）。和现实中的熔断一样服务熔断是会自动恢复的。一般是触发熔断后的一段时间内服务处于熔断状态不提供服务，然后进入半开状态，若接下来的少量请求没有报错且响应时间合理则服务恢复，如果还是异常则继续熔断。\nsoul中的Sentinel插件 Sentinel是阿里开源的面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。Soul作为国内优秀的开源网关，将Sentinel整合为插件融入了自己的体系中，使用户通过简单的配置就可以使用Sentinel提供的流量控制和服务熔断功能。下面将简要介绍在soul中如何配置使用sentinel插件。\n首先登陆soul管理平台在\u0026amp;rdquo;插件列表\u0026amp;rdquo; \u0026amp;ndash;\u0026amp;gt; \u0026amp;ldquo;sentinel\u0026amp;rdquo;中配置插件。其中\u0026amp;rdquo;选择器\u0026amp;rdquo;的配置不是本文的重点不再介绍，点击\u0026amp;rdquo;增加规则\u0026amp;rdquo;来进行具体设置如下图。\n在这个配置页面中\u0026amp;rdquo;名称\u0026amp;rdquo;、\u0026amp;rdquo;匹配方式\u0026amp;rdquo;、\u0026amp;rdquo;条件\u0026amp;rdquo;、\u0026amp;rdquo;日志打印\u0026amp;rdquo;、\u0026amp;rdquo;是否开启\u0026amp;rdquo;、\u0026amp;rdquo;执行顺序\u0026amp;rdquo;属于soul插件的常规配置这里也不再赘述。我们重点需要关注的是\u0026amp;rdquo;处理\u0026amp;rdquo;中的配置项。这些配置项主要可以分为2组，前4个选项是关于熔断的配置，后4个选项是关于流量控制的配置。在soul中我们可以针对某一组请求同时设置它的流量控制和熔断策略。下面来重点分析下各个配置项如何使用。\n熔断 首先来看熔断相关的配置，它有四个配置项\u0026amp;rdquo;熔断阈值\u0026amp;rdquo;、\u0026amp;rdquo;是否开启熔断\u0026amp;rdquo;、\u0026amp;rdquo;熔断窗口大小\u0026amp;rdquo;以及没有注名字的是服务异常判断方式。熔断开关表示是否开启熔断（1开\\0不开）。熔断窗口大小指的是触发熔断后经过多少秒后进入半开状态，在半开状态如果请求正常则会进入正常状态如果请求依然不正常则继续熔断。熔断判定方式和熔断阈值需要结合来看。soul中使用了sentinel的3种服务异常判定方式。分别是：\n 慢调用比例，在此模式下阈值指的是判定为慢调用的毫秒数。慢调用的比例默认是1不能更改即单位统计时长内全部超过阈值则触发熔断。该模式是sentinel的默认模式。 异常比例，在此模式下阈值指的是单位统计时长内异常请求的比例上限，需要填写1个[0.0, 1.0]的数，表示0%-100% 异常数策略，在该模式下阈值指的是单位统计时间内异常请求个数的上限。  需要注意的是soul对于单位统计时 …","date":1616112000,"description":"ShenYu网关学习Sentinel插件原理解析","dir":"blog/shenyu_source_learning_20_sentinel/","fuzzywordcount":5500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"6762fb9baa861c3e2298b803b1d69564d63da3b2","permalink":"/zh/blog/shenyu_source_learning_20_sentinel/","publishdate":"2021-03-19T00:00:00Z","readingtime":11,"relpermalink":"/zh/blog/shenyu_source_learning_20_sentinel/","summary":"概述 在业务网关中熔断和流量控制都是非常必要的功能。soul在实现这部分功能时使用了不同的成熟组件，用户可以根据自己的喜好选择。本文将介绍如何","tags":["ShenYu"],"title":"ShenYu网关学习Sentinel插件原理解析","type":"blog","url":"/zh/blog/shenyu_source_learning_20_sentinel/","wordcount":5435},{"author":"axing","categories":"ShenYu","content":" 介绍 Soul 网关在对目标服务进行代理调用的时候，可以使用 redirect 插件来重定向请求。其中包含两种场景：一种把 redirectUrl 配置为第三方URL 地址，直接使用 308 进行转发跳转，另一种是把 redirectUrl 配置以 / 开头的转发到网关自身。\n插件配置  在 soul-admin –\u0026amp;gt; 插件管理 –\u0026amp;gt; redirect，设置为开启。 在 soul-bootstrap 项目的 pom.xml 文件中添加 redirect 的 maven 依赖。 在 soul- admin 后台设置选择器规则，只有匹配的请求，才会进行转发和重定向，请详细看：选择器规则。  Maven 依赖 在 soul-bootstrap 工程的 pom.xml 文件中添加插件依赖。\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  场景  顾名思义，redirect 插件就是对 uri 的重新转发和重定向。\n 重定向  我们在 Rule 配置自定义路径时，应该为一个可达的服务路径。 当匹配到请求后，根据自定义的路径，ShenYu网关会进行 308 服务跳转。  网关自身接口转发  当满足匹配规则时，服务内部会使用 DispatcherHandler 内部接口转发。 要实现网关自身接口转发，我们需要在配置路径使用 / 作为前缀开始，具体配置如下图。  源码解析 在解析 redirect 重定向源码之前，有必要说一些大前提，我们明白 ShenYu网关基于 SpringBoot WebFlux 实现，其中对于 WebFlux 如果默认什么都不配置，请求会默认执行 DispatcherHandler 处理，这个是响应式 MVC 的处理核心，可以看一下初始化：\nprotected void initStrategies(ApplicationContext context) { Map\u0026amp;lt;String, HandlerMapping\u0026amp;gt; mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); ArrayList\u0026amp;lt;HandlerMapping\u0026amp;gt; mappings = new ArrayList(mappingBeans.values()); AnnotationAwareOrderComparator.sort(mappings); // handlerMapping 相关 this.handlerMappings = Collections.unmodifiableList(mappings); Map\u0026amp;lt;String, HandlerAdapter\u0026amp;gt; adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); // handlerAdapter 相关 this.handlerAdapters = new ArrayList(adapterBeans.values()); AnnotationAwareOrderComparator.sort(this.handlerAdapters); Map\u0026amp;lt;String, HandlerResultHandler\u0026amp;gt; beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerResultHandler.class, true, false); // resultHandler 相关 this.resultHandlers = new ArrayList(beans.values()); AnnotationAwareOrderComparator.sort(this.resultHandlers); }  再之后就是我们熟悉的 MVC 核心处理 DispatcherHandler#handle 方法\npublic Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerWebExchange exchange) { return this.handlerMappings == null ? this.createNotFoundError() : Flux.fromIterable(this.handlerMappings).concatMap((mapping) -\u0026amp;gt; { return mapping.getHandler(exchange); }).next().switchIfEmpty(this.createNotFoundError()).flatMap((handler) -\u0026amp;gt; { return this.invokeHandler(exchange, handler); }).flatMap((result) -\u0026amp;gt; { return this.handleResult(exchange, result); }); }  搞清楚默认 DispatcherHandler 如何处理，我们再来说一下 ShenYu网关，SoulWebHandler 实现了 WebHandler 接口，再把 BeanName 声明为 webHandler 替代了之前 DispatcherHandler 注册成默认处理 handler。\n@Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;SoulPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); soulPlugins.forEach(soulPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, soulPlugin.named(), …","date":1615852800,"description":"ShenYu Gateway Learning Redirect Plugin","dir":"blog/shenyu_source_learning_19_redirect/","fuzzywordcount":900,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7b6af103d19664cf1458cad6aa65c5b44442650f","permalink":"/blog/shenyu_source_learning_19_redirect/","publishdate":"2021-03-16T00:00:00Z","readingtime":2,"relpermalink":"/blog/shenyu_source_learning_19_redirect/","summary":"介绍 Soul 网关在对目标服务进行代理调用的时候，可以使用 redirect 插件来重定向请求。其中包含两种场景：一种把 redirectUrl 配置为第三方URL 地址，直接使用 308 进行转发跳","tags":["ShenYu"],"title":"ShenYu Gateway Learning Redirect Plugin","type":"blog","url":"/blog/shenyu_source_learning_19_redirect/","wordcount":888},{"author":"阿行","categories":"ShenYu","content":" 介绍 Soul 网关在对目标服务进行代理调用的时候，可以使用 redirect 插件来重定向请求。其中包含两种场景：一种把 redirectUrl 配置为第三方URL 地址，直接使用 308 进行转发跳转，另一种是把 redirectUrl 配置以 / 开头的转发到网关自身。\n插件配置  在 soul-admin –\u0026amp;gt; 插件管理 –\u0026amp;gt; redirect，设置为开启。 在 soul-bootstrap 项目的 pom.xml 文件中添加 redirect 的 maven 依赖。 在 soul- admin 后台设置选择器规则，只有匹配的请求，才会进行转发和重定向，请详细看：选择器规则。  Maven 依赖 在 soul-bootstrap 工程的 pom.xml 文件中添加插件依赖。\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  场景  顾名思义，redirect 插件就是对 uri 的重新转发和重定向。\n 重定向  我们在 Rule 配置自定义路径时，应该为一个可达的服务路径。 当匹配到请求后，根据自定义的路径，ShenYu 网关会进行 308 服务跳转。  网关自身接口转发  当满足匹配规则时，服务内部会使用 DispatcherHandler 内部接口转发。 要实现网关自身接口转发，我们需要在配置路径使用 / 作为前缀开始，具体配置如下图。  源码解析 在解析 redirect 重定向源码之前，有必要说一些大前提，我们明白 ShenYu 网关基于 SpringBoot WebFlux 实现，其中对于 WebFlux 如果默认什么都不配置，请求会默认执行 DispatcherHandler 处理，这个是响应式 MVC 的处理核心，可以看一下初始化：\nprotected void initStrategies(ApplicationContext context) { Map\u0026amp;lt;String, HandlerMapping\u0026amp;gt; mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); ArrayList\u0026amp;lt;HandlerMapping\u0026amp;gt; mappings = new ArrayList(mappingBeans.values()); AnnotationAwareOrderComparator.sort(mappings); // handlerMapping 相关 this.handlerMappings = Collections.unmodifiableList(mappings); Map\u0026amp;lt;String, HandlerAdapter\u0026amp;gt; adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); // handlerAdapter 相关 this.handlerAdapters = new ArrayList(adapterBeans.values()); AnnotationAwareOrderComparator.sort(this.handlerAdapters); Map\u0026amp;lt;String, HandlerResultHandler\u0026amp;gt; beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerResultHandler.class, true, false); // resultHandler 相关 this.resultHandlers = new ArrayList(beans.values()); AnnotationAwareOrderComparator.sort(this.resultHandlers); }  再之后就是我们熟悉的 MVC 核心处理 DispatcherHandler#handle 方法\npublic Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerWebExchange exchange) { return this.handlerMappings == null ? this.createNotFoundError() : Flux.fromIterable(this.handlerMappings).concatMap((mapping) -\u0026amp;gt; { return mapping.getHandler(exchange); }).next().switchIfEmpty(this.createNotFoundError()).flatMap((handler) -\u0026amp;gt; { return this.invokeHandler(exchange, handler); }).flatMap((result) -\u0026amp;gt; { return this.handleResult(exchange, result); }); }  搞清楚默认 DispatcherHandler 如何处理，我们再来说一下 ShenYu 网关，SoulWebHandler 实现了 WebHandler 接口，再把 BeanName 声明为 webHandler 替代了之前 DispatcherHandler 注册成默认处理 handler。\n@Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;SoulPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); soulPlugins.forEach(soulPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, soulPlugin.named(), …","date":1615852800,"description":"ShenYu网关学习Redirect插件原理解析","dir":"blog/shenyu_source_learning_19_redirect/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3aa9d24436cdcfee1799b34e92900d433daf838b","permalink":"/zh/blog/shenyu_source_learning_19_redirect/","publishdate":"2021-03-16T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/shenyu_source_learning_19_redirect/","summary":"介绍 Soul 网关在对目标服务进行代理调用的时候，可以使用 redirect 插件来重定向请求。其中包含两种场景：一种把 redirectUrl 配置为第三方URL 地址，直接使用 308 进行转发跳","tags":["ShenYu"],"title":"ShenYu网关学习Redirect插件原理解析","type":"blog","url":"/zh/blog/shenyu_source_learning_19_redirect/","wordcount":878},{"author":"xiaoyu","categories":null,"content":" ShenYu source code reading (ShenYu 2021 first activity)  Date: Sunday, February 6, 2021 Time：20:00 – 23:00 Location: Tencent Meeting  Activity Details 20:00 - 20:10 The opening introduces the recent dream code sharing situation by kimming \u0026amp;amp; 崔\n20:10 - 20:25 Introduction to SPI and how SPI is enhanced by zhuming\n20:25 - 20:50 Introduction to Reactive Programming by Ztzzz\n20:50 - 21:10 ShenYu Unit Test by yangze\n21:10 - 21:25 Fault-tolerant design by jiangwenbo\n21:25 - 21:40 ShenYu Web Flux loading process and processing request analysis by rwby\n21:40 - 21:55 ShenYu current limiting and fusing analysis by liupenghui\n21:55 - 22:05 Summary of common Java problems by muou\n22:05 - 22:20 How to open a social interface by weikai\n22:20 - 22:30 Summary and Community Development Prospects by Xiaoyu\n","date":1612623600,"description":"","dir":"blog/apache-cloud-native-meet-02/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"363ee890e18d5c23aaa1b7992066257d2d2020b4","permalink":"/blog/apache-cloud-native-meet-02/","publishdate":"2021-02-06T15:00:00Z","readingtime":1,"relpermalink":"/blog/apache-cloud-native-meet-02/","summary":"ShenYu source code reading (ShenYu 2021 first activity) Date: Sunday, February 6, 2021 Time：20:00 – 23:00 Location: Tencent Meeting Activity Details 20:00 - 20:10 The opening introduces the recent dream code sharing situation by kimming \u0026amp; 崔 20:10 - 20:25 Introduction to SPI and how SPI is enhanced by zhuming 20:25 - 20:50 Introduction to Reactive Programming by Ztzzz 20:50 -","tags":["Apache","Reactor"],"title":"ShenYu Source Code 01 Reading Sharing Session 02","type":"blog","url":"/blog/apache-cloud-native-meet-02/","wordcount":139},{"author":"xiaoyu","categories":null,"content":" ShenYu 源码阅读（ShenYu 2021 首次活动）  日期：2021年2月6日，星期日 时间：20:00 – 23:00 地点：线上腾讯会议室  活动详情 20:00 - 20:10 开场介绍近期梦码分享情况 by kimming \u0026amp;amp; 崔\n20:10 - 20:25 SPI 介绍以及ShenYu SPI 如何增强实现 by 朱明\n20:25 - 20:50 响应式编程介绍 by Ztzzz\n20:50 - 21:10 ShenYu单测小结 by 阿行\n21:10 - 21:25 容错设计 by 蒋文博\n21:25 - 21:40 WebFlux加载流程以及处理请求分析 by rwby\n21:40 - 21:55 ShenYu限流和熔断分析 by 刘鹏辉\n21:55 - 22:05 Java常见问题总结 by 木偶\n22:05 - 22:20 如何打开社交面 by 伟楷\n22:20 - 22:30 ShenYu 作者 猫大人 总结与 展望 by 猫大人\n","date":1612623600,"description":"","dir":"blog/apache-cloud-native-meet-02/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0b88610a0a1bbe216e5476e14d9af53bf223bb18","permalink":"/zh/blog/apache-cloud-native-meet-02/","publishdate":"2021-02-06T15:00:00Z","readingtime":1,"relpermalink":"/zh/blog/apache-cloud-native-meet-02/","summary":"ShenYu 源码阅读（ShenYu 2021 首次活动） 日期：2021年2月6日，星期日 时间：20:00 – 23:00 地点：线上腾讯会议室 活动详情 20:00 - 20:10 开场介绍近期梦码分","tags":["ShenYu","Reactor"],"title":"ShenYu 源码01期阅读分享会02","type":"blog","url":"/zh/blog/apache-cloud-native-meet-02/","wordcount":231},{"author":"shenxiangjun","categories":"ShenYu","content":" 插件概述 插件定位\ndivide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。\n生效时机\n当请求头的 rpcType = http 且插件开启时，它将根据请求参数匹配规则，最终交由下游插件进行响应式代理调用。\n插件处理流程 1）先回顾下请求处理类插件的通用流程（AbstractSoulPlugin # execute）：\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { // 获取插件数据 String pluginName = named(); final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); if (pluginData != null \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { // 获取选择器数据 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); ... // 匹配选择器 final SelectorData selectorData = matchSelector(exchange, selectors); ... // 获取规则数据 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); ... // 匹配规则 RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { //get last rule = rules.get(rules.size() - 1); } else { rule = matchRule(exchange, rules); } ... // 执行自定义处理 return doExecute(exchange, chain, selectorData, rule); } // 继续执行插件链处理 return chain.execute(exchange); }  AbstractSoulPlugin 先匹配到对应的选择器和规则，匹配通过则执行插件的自定义处理。\n2）再来看看 divide 插件的自定义处理流程（DividePlugin # doExecute）：\nprotected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) { ... // 准备规则处理对象（内部持有：负载均衡算法名、重试次数以及超时时间） final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class); // 获取选择器对应的可用服务列表 final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId()); ... // 选择具体分发的服务实例ip（负载均衡） final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress(); DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); ... //设置 http url、超时时间以及重试次数 String domain = buildDomain(divideUpstream); String realURL = buildRealURL(domain, soulContext, exchange); exchange.getAttributes().put(Constants.HTTP_URL, realURL); exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout()); exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry()); // 继续执行插件链处理 return chain.execute(exchange); }  DividePlugin 先获取到选择器对应的可用服务列表，然后进行负载均衡选择即将分发的目标服务器实例ip，最后设置最终的 url、超时时间以及重试次数并交由插件链下游进行处理。\n注意：\ndivide 插件自身只是负责根据选择器、规则和负载均衡策略选出待分发的服务器实例，并不直接向后端服务发起 http 请求。\n主机探活 上面提到，divide 需要获取服务列表，看下获取的实现（UpstreamCacheManager # findUpstreamListBySelectorId）：\npublic List\u0026amp;lt;DivideUpstream\u0026amp;gt; findUpstreamListBySelectorId(final String selectorId) { return UPSTREAM_MAP_TEMP.get(selectorId); }  内部通过 UPSTREAM_MAP_TEMP 获取存活服务列表。\nUpstreamCacheManager 内部维护了两份散列表：\n UPSTREAM_MAP：  全量服务散列表，负责存放全量的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。\n UPSTREAM_MAP_TEMP：  临时服务散列表，负责存放活动的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。\n前面章节我们提到，数据同步时，submit 方法同时更新了 UPSTREAM_MAP 和 UPSTREAM_MAP_TEMP， …","date":1612137600,"description":"ShenYu Gateway Learning Divide Plugin Source Code Interpretation","dir":"blog/shenyu_source_learning_16_divide_sxj/","fuzzywordcount":2500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"8a1b23a810795680ff65db34b027b0590654abc2","permalink":"/blog/shenyu_source_learning_16_divide_sxj/","publishdate":"2021-02-01T00:00:00Z","readingtime":5,"relpermalink":"/blog/shenyu_source_learning_16_divide_sxj/","summary":"插件概述 插件定位 divide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。 生效时机 当请求头的 rpcType =","tags":["ShenYu"],"title":"ShenYu Gateway Learning Divide Plugin Source Code Interpretation","type":"blog","url":"/blog/shenyu_source_learning_16_divide_sxj/","wordcount":2408},{"author":"沈祥俊","categories":"ShenYu","content":" 插件概述 插件定位\ndivide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。\n生效时机\n当请求头的 rpcType = http 且插件开启时，它将根据请求参数匹配规则，最终交由下游插件进行响应式代理调用。\n插件处理流程 1）先回顾下请求处理类插件的通用流程（AbstractSoulPlugin # execute）：\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { // 获取插件数据 String pluginName = named(); final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); if (pluginData != null \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { // 获取选择器数据 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); ... // 匹配选择器 final SelectorData selectorData = matchSelector(exchange, selectors); ... // 获取规则数据 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); ... // 匹配规则 RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { //get last rule = rules.get(rules.size() - 1); } else { rule = matchRule(exchange, rules); } ... // 执行自定义处理 return doExecute(exchange, chain, selectorData, rule); } // 继续执行插件链处理 return chain.execute(exchange); }  AbstractSoulPlugin 先匹配到对应的选择器和规则，匹配通过则执行插件的自定义处理。\n2）再来看看 divide 插件的自定义处理流程（DividePlugin # doExecute）：\nprotected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) { ... // 准备规则处理对象（内部持有：负载均衡算法名、重试次数以及超时时间） final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class); // 获取选择器对应的可用服务列表 final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId()); ... // 选择具体分发的服务实例ip（负载均衡） final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress(); DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); ... //设置 http url、超时时间以及重试次数 String domain = buildDomain(divideUpstream); String realURL = buildRealURL(domain, soulContext, exchange); exchange.getAttributes().put(Constants.HTTP_URL, realURL); exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout()); exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry()); // 继续执行插件链处理 return chain.execute(exchange); }  DividePlugin 先获取到选择器对应的可用服务列表，然后进行负载均衡选择即将分发的目标服务器实例ip，最后设置最终的 url、超时时间以及重试次数并交由插件链下游进行处理。\n注意：\ndivide 插件自身只是负责根据选择器、规则和负载均衡策略选出待分发的服务器实例，并不直接向后端服务发起 http 请求。\n主机探活 上面提到，divide 需要获取服务列表，看下获取的实现（UpstreamCacheManager # findUpstreamListBySelectorId）：\npublic List\u0026amp;lt;DivideUpstream\u0026amp;gt; findUpstreamListBySelectorId(final String selectorId) { return UPSTREAM_MAP_TEMP.get(selectorId); }  内部通过 UPSTREAM_MAP_TEMP 获取存活服务列表。\nUpstreamCacheManager 内部维护了两份散列表：\n UPSTREAM_MAP：  全量服务散列表，负责存放全量的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。\n UPSTREAM_MAP_TEMP：  临时服务散列表，负责存放活动的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。\n前面章节我们提到，数据同步时，submit 方法同时更新了 UPSTREAM_MAP 和 UPSTREAM_MAP_TEMP， …","date":1612137600,"description":"ShenYu网关学习divide插件源码解读","dir":"blog/shenyu_source_learning_16_divide_sxj/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bdb95ce0cdb0d25b150eb5f3cbff78c213c1882c","permalink":"/zh/blog/shenyu_source_learning_16_divide_sxj/","publishdate":"2021-02-01T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/shenyu_source_learning_16_divide_sxj/","summary":"插件概述 插件定位 divide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。 生效时机 当请求头的 rpcType =","tags":["ShenYu"],"title":"ShenYu网关学习divide插件源码解读","type":"blog","url":"/zh/blog/shenyu_source_learning_16_divide_sxj/","wordcount":2408},{"author":"baiyu","categories":"ShenYu","content":" 回顾 在之前的HTTP请求初探的文章中，大体梳理了Soul插件的处理流程，也得知了DividePlugin、GlobalPlugin，WebClientPlugin，WebCilentResponsePlugin插件的具体作用，在梳理流程中，发现Soul的插件是有先后顺序的，在DividePlugin插件之前做了很多前置插件的操作，其中包含了我们本章分析的主题RateLimiterPlugin 限流插件（其中一种）。\n学习使用 阅读官方文档 对其有大概认知 rateLimiter插件\n通过官方文档的阅读我们得知了RateLimiterPlugin的两个核心点速率、容量\n以下讲解来源于官方文档\n 容量：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。 速率：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。  可以看出RateLimiterPlugin限流核心在于令牌桶算法的实现。\nps：关于限流算法常见的有四种实现令牌桶算法，漏斗算法，计数器（固定窗口）算法，滑动窗口算法，详情看对应博客介绍\n初步使用 启用对应插件 在Soul网关系统管理-插件管理处，将状态更改为启用状态，注意此处需要填写redis相关配置，Soul令牌桶基于Redis。\n为什么Soul的令牌桶算法要基于redis？\n在集群部署情况下单机的令牌桶算法无法满足集群状态下的限流功能。\n添加限流选择器、规则 在Soul网关插件列表处，选择rate_limiter处添加规则及选择器配置，不懂如何添加的可以先阅读选择器\\规则的匹配逻辑. 在此处添加的容量及速率都为1 主要为了验证插件是否启用。\n接口对应访问 调用http://127.0.0.1:9195/http/test/findByUserId?userId=10 进行访问，速率高于1的情况下出现如下接口返回结果，代表插件成功使用。\n{ \u0026amp;quot;code\u0026amp;quot;: 429, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;You have been restricted, please try again later!\u0026amp;quot;, \u0026amp;quot;data\u0026amp;quot;: null }  源码阅读 带着问题读源码 如何保证在页面修改redis配置后立即生效的，后台对应的redis连接立马变更的。 答案自然数据同步脱不了干系。\n在修改插件的配置时，也发布了一个插件数据变更的事件通知，在之前梳理Soul网关同步数据整体流程时,已经得知修改的插件数据除了更改了JVM缓存内的数据外，还对对应的插件进行下发操作，如下图 而针对于RateLimiterPlugin而言，其主要实现了handlePlugin的接口，那这个对应的实现到底做了哪些事呢？\n具体的方法为RateLimiterPluginDataHandler的handlerPlugin。\npublic void handlerPlugin(final PluginData pluginData) { if (Objects.nonNull(pluginData) \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { //加载限流插件配置 RateLimiterConfig rateLimiterConfig = GsonUtils.getInstance().fromJson(pluginData.getConfig(), RateLimiterConfig.class); //判断是否需要重新加载redis连接值 if (Objects.isNull(Singleton.INST.get(ReactiveRedisTemplate.class)) || Objects.isNull(Singleton.INST.get(RateLimiterConfig.class)) || !rateLimiterConfig.equals(Singleton.INST.get(RateLimiterConfig.class))) { LettuceConnectionFactory lettuceConnectionFactory = createLettuceConnectionFactory(rateLimiterConfig); lettuceConnectionFactory.afterPropertiesSet(); RedisSerializer\u0026amp;lt;String\u0026amp;gt; serializer = new StringRedisSerializer(); RedisSerializationContext\u0026amp;lt;String, String\u0026amp;gt; serializationContext = RedisSerializationContext.\u0026amp;lt;String, String\u0026amp;gt;newSerializationContext().key(serializer).value(serializer).hashKey(serializer).hashValue(serializer).build(); ReactiveRedisTemplate\u0026amp;lt;String, String\u0026amp;gt; reactiveRedisTemplate = new ReactiveRedisTemplate\u0026amp;lt;\u0026amp;gt;(lettuceConnectionFactory, serializationContext); Singleton.INST.single(ReactiveRedisTemplate.class, reactiveRedisTemplate); Singleton.INST.single(RateLimiterConfig.class, rateLimiterConfig); } } }  上述代码有几个较为关键的点：\n在上述代码中将限流插件的配置和对应的redisTemplate实例放入了Singleton.INST对应map中。\n在插件数据过来时，判断是否存在redis连接实例，是否存在限流配置实例，判断当前的限流配置实例是否和传递的限流实例一致，不一致就认为配置是有更改的，就重新初始化限流实例和连接池实例放入Singleton.INST的map中，由此而言就保证了更改redis配置的热部署。\nif判断中的代码就是基于SpringDataRedis封装成一个对应redis连接池。\nps：Singleton.INST是枚举实现的单例模式。\n限流插件是底层是如何实现的呢？ Debug 调用链 RateLimiterPlugin由于需要对特定规则进行限流，所以依旧实现了AbstractSoulPlugin，之前依旧梳理过AbstractSoulPlugin的excute的方法和作用了，所以这里不重复解释，可观看Http 调用流程梳理，加深对该类的印象。\n本节重点还是看具体的doexcute方法做了哪些事。\nprotected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(final ServerWebExchange exchange, final …","date":1611964800,"description":"ShenYu Gateway Learning RateLimiter Plugin","dir":"blog/shenyu_source_learning_18_ratelimiter/","fuzzywordcount":2900,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"e88ebcc914fc2bf27e3c2944e809bb598719c94b","permalink":"/blog/shenyu_source_learning_18_ratelimiter/","publishdate":"2021-01-30T00:00:00Z","readingtime":6,"relpermalink":"/blog/shenyu_source_learning_18_ratelimiter/","summary":"回顾 在之前的HTTP请求初探的文章中，大体梳理了Soul插件的处理流程，也得知了DividePlugin、GlobalPlugin，WebC","tags":["ShenYu"],"title":"ShenYu Gateway Learning RateLimiter Plugin","type":"blog","url":"/blog/shenyu_source_learning_18_ratelimiter/","wordcount":2829},{"author":"zhuming","categories":"ShenYu","content":" SOUL 中 SPI 的使用 在之前分析 divide 插件的负载均衡策略时, 有看到过一行代码:\nDivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);  当时很简单的略过了它的实现, 它的作用很容易分析, 调用一个看似工具类的方法, 传入多个节点组成的集群, 返回一个节点. 这是一个负载均衡器.\n但是细节却非常多, 最重要的一点是使用 SPI 来选择具体的实现类. 看看这个方法的代码:\npublic class LoadBalanceUtils { public static DivideUpstream selector(final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList, final String algorithm, final String ip) { // 调用自定义的 SPI 得到一个子类 LoadBalance loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm); return loadBalance.select(upstreamList, ip); } }  后面的是调用具体子类的 select() 方法, 根据子类的不同实现, 最终会表现出各种形式. 目前的子类实现有:\n HashLoadBalance RandomLoadBalance RoundRobinLoadBalance  关键就在于 ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm); 这行.\n在研究它之前, 我们先不妨研究下 Java 提供的 SPI 机制.\nJava SPI \u0026amp;lt;\u0026amp;lt;高可用可伸缩微服务架构\u0026amp;gt;\u0026amp;gt; 第3章 Apache Dubbo 框架的原理与实现 中有这样的一句定义.\n SPI 全称为 Service Provider Interface, 是 JDK 内置的一种服务提供发现功能, 一种动态替换发现的机制. 举个例子, 要想在运行时动态地给一个接口添加实现, 只需要添加一个实现即可.\n 书中也有个非常形象的脑图, 展示了 SPI 的使用:\n也就是说在我们代码中的实现里, 无需去写入一个 Factory 工厂, 用 MAP 去包装一些子类, 最终返回的类型是父接口. 只需要定义好资源文件, 让父接口与它的子类在文件中写明, 即可通过设置好的方式拿到所有定义的子类对象:\nServiceLoader\u0026amp;lt;Interface\u0026amp;gt; loaders = ServiceLoader.load(Interface.class) for(Interface interface : loaders){ System.out.println(interface.toString()); }  这种方式相比与普通的工厂模式, 肯定是更符合开闭原则, 新加入一个子类不用去修改工厂方法, 而是编辑资源文件.\n从一个 Demo 开始 按照 SPI 的规范, 我建了一个 demo, 看看具体的实现效果\nAnimal 中定义一个 run() 方法, 而子类实现它.\npublic interface Animal { void run(); } public class Dog implements Animal { @Override public void run() { System.out.println(\u0026amp;quot;狗在跑\u0026amp;quot;); } } public class Horse implements Animal { @Override public void run() { System.out.println(\u0026amp;quot;马在跑\u0026amp;quot;); } }  使用 SPI 的加载类, 得到子类的执行结果:\nprivate static void test() { final ServiceLoader\u0026amp;lt;Animal\u0026amp;gt; load = ServiceLoader.load(Animal.class); for (Animal animal : load) { System.out.println(animal); animal.run(); } }  在调用后我们得到之前在资源文件中写入的实现类, 并成功调取它们各自的 run() 方法.\n到这里我产生一个疑问, 是否每次调用 ServiceLoader.load(Animal.class) 返回的都是同一个对象? 如果是我猜测它是在启动时加载到缓存了, 如果不是, 可能就是在底层用了反射, 每次调用都有一定消耗. 我们看看下面的实验:\npublic static void main(String[] args) { for (int i = 0; i \u0026amp;lt; 2; i++) { test(); System.out.println(\u0026amp;quot;----------\u0026amp;quot;); } } private static void test() { final ServiceLoader\u0026amp;lt;Animal\u0026amp;gt; load = ServiceLoader.load(Animal.class); for (Animal animal : load) { System.out.println(animal); animal.run(); } }  两次调用出现的对象却不一样, 不由让我替其性能揪心一下, 所以我们先分析下它的代码, 看看到底怎么实现.\nSPI 的实现 找到 java.util,ServiceLoaders 这个类, 入眼最醒目的就是之前我们按照规范放置资源文件的目录\npublic final class ServiceLoader\u0026amp;lt;S\u0026amp;gt; implements Iterable\u0026amp;lt;S\u0026amp;gt; { private static final String PREFIX = \u0026amp;quot;META-INF/services/\u0026amp;quot;; }  在 debug PREFIX 属性的被调用处时, 发现 ServiceLoader.load 实际是使用懒加载的方式, 并没有在调用它的时候, 找寻到实际返回类, 而是在遍历时查找.\n它的懒加载具体实现在如下代码:\npublic final class ServiceLoader\u0026amp;lt;S\u0026amp;gt; implements Iterable\u0026amp;lt;S\u0026amp;gt; { public static \u0026amp;lt;S\u0026amp;gt; ServiceLoader\u0026amp;lt;S\u0026amp;gt; load(Class\u0026amp;lt;S\u0026amp;gt; service) { // 获取当前的类加载器 (我们自己的通常是弟中弟 AppClassLoader ) ClassLoader cl = …","date":1611964800,"description":"ShenYu Gateway Learning SPI","dir":"blog/shenyu_source_learning_11_SPI/","fuzzywordcount":5500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7b079f17c32ed1e73a722b1e2850d1886cc680bb","permalink":"/blog/shenyu_source_learning_11_spi/","publishdate":"2021-01-30T00:00:00Z","readingtime":11,"relpermalink":"/blog/shenyu_source_learning_11_spi/","summary":"SOUL 中 SPI 的使用 在之前分析 divide 插件的负载均衡策略时, 有看到过一行代码: DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); 当时很简单的略过了它的实现, 它的作用很容易分析, 调用一个看似工具","tags":["ShenYu"],"title":"ShenYu Gateway Learning SPI","type":"blog","url":"/blog/shenyu_source_learning_11_spi/","wordcount":5458},{"author":"百钰","categories":"ShenYu","content":" 回顾 在之前的HTTP请求初探的文章中，大体梳理了Soul插件的处理流程，也得知了DividePlugin、GlobalPlugin，WebClientPlugin，WebCilentResponsePlugin插件的具体作用，在梳理流程中，发现Soul的插件是有先后顺序的，在DividePlugin插件之前做了很多前置插件的操作，其中包含了我们本章分析的主题RateLimiterPlugin 限流插件（其中一种）。\n学习使用 阅读官方文档 对其有大概认知 rateLimiter插件\n通过官方文档的阅读我们得知了RateLimiterPlugin的两个核心点速率、容量\n以下讲解来源于官方文档\n 容量：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。 速率：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。  可以看出RateLimiterPlugin限流核心在于令牌桶算法的实现。\nps：关于限流算法常见的有四种实现令牌桶算法，漏斗算法，计数器（固定窗口）算法，滑动窗口算法，详情看对应博客介绍\n初步使用 启用对应插件 在ShenYu网关系统管理-插件管理处，将状态更改为启用状态，注意此处需要填写redis相关配置，Soul令牌桶基于Redis。\n为什么Soul的令牌桶算法要基于redis？\n在集群部署情况下单机的令牌桶算法无法满足集群状态下的限流功能。\n添加限流选择器、规则 在ShenYu网关插件列表处，选择rate_limiter处添加规则及选择器配置，不懂如何添加的可以先阅读选择器\\规则的匹配逻辑. 在此处添加的容量及速率都为1 主要为了验证插件是否启用。\n接口对应访问 调用http://127.0.0.1:9195/http/test/findByUserId?userId=10 进行访问，速率高于1的情况下出现如下接口返回结果，代表插件成功使用。\n{ \u0026amp;quot;code\u0026amp;quot;: 429, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;You have been restricted, please try again later!\u0026amp;quot;, \u0026amp;quot;data\u0026amp;quot;: null }  源码阅读 带着问题读源码 如何保证在页面修改redis配置后立即生效的，后台对应的redis连接立马变更的。 答案自然数据同步脱不了干系。\n在修改插件的配置时，也发布了一个插件数据变更的事件通知，在之前梳理ShenYu网关同步数据整体流程时,已经得知修改的插件数据除了更改了JVM缓存内的数据外，还对对应的插件进行下发操作，如下图 而针对于RateLimiterPlugin而言，其主要实现了handlePlugin的接口，那这个对应的实现到底做了哪些事呢？\n具体的方法为RateLimiterPluginDataHandler的handlerPlugin。\npublic void handlerPlugin(final PluginData pluginData) { if (Objects.nonNull(pluginData) \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { //加载限流插件配置 RateLimiterConfig rateLimiterConfig = GsonUtils.getInstance().fromJson(pluginData.getConfig(), RateLimiterConfig.class); //判断是否需要重新加载redis连接值 if (Objects.isNull(Singleton.INST.get(ReactiveRedisTemplate.class)) || Objects.isNull(Singleton.INST.get(RateLimiterConfig.class)) || !rateLimiterConfig.equals(Singleton.INST.get(RateLimiterConfig.class))) { LettuceConnectionFactory lettuceConnectionFactory = createLettuceConnectionFactory(rateLimiterConfig); lettuceConnectionFactory.afterPropertiesSet(); RedisSerializer\u0026amp;lt;String\u0026amp;gt; serializer = new StringRedisSerializer(); RedisSerializationContext\u0026amp;lt;String, String\u0026amp;gt; serializationContext = RedisSerializationContext.\u0026amp;lt;String, String\u0026amp;gt;newSerializationContext().key(serializer).value(serializer).hashKey(serializer).hashValue(serializer).build(); ReactiveRedisTemplate\u0026amp;lt;String, String\u0026amp;gt; reactiveRedisTemplate = new ReactiveRedisTemplate\u0026amp;lt;\u0026amp;gt;(lettuceConnectionFactory, serializationContext); Singleton.INST.single(ReactiveRedisTemplate.class, reactiveRedisTemplate); Singleton.INST.single(RateLimiterConfig.class, rateLimiterConfig); } } }  上述代码有几个较为关键的点：\n在上述代码中将限流插件的配置和对应的redisTemplate实例放入了Singleton.INST对应map中。\n在插件数据过来时，判断是否存在redis连接实例，是否存在限流配置实例，判断当前的限流配置实例是否和传递的限流实例一致，不一致就认为配置是有更改的，就重新初始化限流实例和连接池实例放入Singleton.INST的map中，由此而言就保证了更改redis配置的热部署。\nif判断中的代码就是基于SpringDataRedis封装成一个对应redis连接池。\nps：Singleton.INST是枚举实现的单例模式。\n限流插件是底层是如何实现的呢？ Debug 调用链 RateLimiterPlugin由于需要对特定规则进行限流，所以依旧实现了AbstractSoulPlugin，之前依旧梳理过AbstractSoulPlugin的excute的方法和作用了，所以这里不重复解释，可观看Http 调用流程梳理，加深对该类的印象。\n本节重点还是看具体的doexcute方法做了哪些事。\nprotected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(final ServerWebExchange exchange, …","date":1611964800,"description":"ShenYu网关学习RateLimiter插件原理解析","dir":"blog/shenyu_source_learning_18_ratelimiter/","fuzzywordcount":2900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e7874d4ab8e30f9e5039521f9cd052df8532fc69","permalink":"/zh/blog/shenyu_source_learning_18_ratelimiter/","publishdate":"2021-01-30T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/shenyu_source_learning_18_ratelimiter/","summary":"回顾 在之前的HTTP请求初探的文章中，大体梳理了Soul插件的处理流程，也得知了DividePlugin、GlobalPlugin，WebC","tags":["ShenYu"],"title":"ShenYu网关学习RateLimiter插件原理解析","type":"blog","url":"/zh/blog/shenyu_source_learning_18_ratelimiter/","wordcount":2835},{"author":"朱明","categories":"ShenYu","content":" SOUL 中 SPI 的使用 在之前分析 divide 插件的负载均衡策略时, 有看到过一行代码:\nDivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);  当时很简单的略过了它的实现, 它的作用很容易分析, 调用一个看似工具类的方法, 传入多个节点组成的集群, 返回一个节点. 这是一个负载均衡器.\n但是细节却非常多, 最重要的一点是使用 SPI 来选择具体的实现类. 看看这个方法的代码:\npublic class LoadBalanceUtils { public static DivideUpstream selector(final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList, final String algorithm, final String ip) { // 调用自定义的 SPI 得到一个子类 LoadBalance loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm); return loadBalance.select(upstreamList, ip); } }  后面的是调用具体子类的 select() 方法, 根据子类的不同实现, 最终会表现出各种形式. 目前的子类实现有:\n HashLoadBalance RandomLoadBalance RoundRobinLoadBalance  关键就在于 ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm); 这行.\n在研究它之前, 我们先不妨研究下 Java 提供的 SPI 机制.\nJava SPI \u0026amp;lt;\u0026amp;lt;高可用可伸缩微服务架构\u0026amp;gt;\u0026amp;gt; 第3章 Apache Dubbo 框架的原理与实现 中有这样的一句定义.\n SPI 全称为 Service Provider Interface, 是 JDK 内置的一种服务提供发现功能, 一种动态替换发现的机制. 举个例子, 要想在运行时动态地给一个接口添加实现, 只需要添加一个实现即可.\n 书中也有个非常形象的脑图, 展示了 SPI 的使用:\n也就是说在我们代码中的实现里, 无需去写入一个 Factory 工厂, 用 MAP 去包装一些子类, 最终返回的类型是父接口. 只需要定义好资源文件, 让父接口与它的子类在文件中写明, 即可通过设置好的方式拿到所有定义的子类对象:\nServiceLoader\u0026amp;lt;Interface\u0026amp;gt; loaders = ServiceLoader.load(Interface.class) for(Interface interface : loaders){ System.out.println(interface.toString()); }  这种方式相比与普通的工厂模式, 肯定是更符合开闭原则, 新加入一个子类不用去修改工厂方法, 而是编辑资源文件.\n从一个 Demo 开始 按照 SPI 的规范, 我建了一个 demo, 看看具体的实现效果\nAnimal 中定义一个 run() 方法, 而子类实现它.\npublic interface Animal { void run(); } public class Dog implements Animal { @Override public void run() { System.out.println(\u0026amp;quot;狗在跑\u0026amp;quot;); } } public class Horse implements Animal { @Override public void run() { System.out.println(\u0026amp;quot;马在跑\u0026amp;quot;); } }  使用 SPI 的加载类, 得到子类的执行结果:\nprivate static void test() { final ServiceLoader\u0026amp;lt;Animal\u0026amp;gt; load = ServiceLoader.load(Animal.class); for (Animal animal : load) { System.out.println(animal); animal.run(); } }  在调用后我们得到之前在资源文件中写入的实现类, 并成功调取它们各自的 run() 方法.\n到这里我产生一个疑问, 是否每次调用 ServiceLoader.load(Animal.class) 返回的都是同一个对象? 如果是我猜测它是在启动时加载到缓存了, 如果不是, 可能就是在底层用了反射, 每次调用都有一定消耗. 我们看看下面的实验:\npublic static void main(String[] args) { for (int i = 0; i \u0026amp;lt; 2; i++) { test(); System.out.println(\u0026amp;quot;----------\u0026amp;quot;); } } private static void test() { final ServiceLoader\u0026amp;lt;Animal\u0026amp;gt; load = ServiceLoader.load(Animal.class); for (Animal animal : load) { System.out.println(animal); animal.run(); } }  两次调用出现的对象却不一样, 不由让我替其性能揪心一下, 所以我们先分析下它的代码, 看看到底怎么实现.\nSPI 的实现 找到 java.util,ServiceLoaders 这个类, 入眼最醒目的就是之前我们按照规范放置资源文件的目录\npublic final class ServiceLoader\u0026amp;lt;S\u0026amp;gt; implements Iterable\u0026amp;lt;S\u0026amp;gt; { private static final String PREFIX = \u0026amp;quot;META-INF/services/\u0026amp;quot;; }  在 debug PREFIX 属性的被调用处时, 发现 ServiceLoader.load 实际是使用懒加载的方式, 并没有在调用它的时候, 找寻到实际返回类, 而是在遍历时查找.\n它的懒加载具体实现在如下代码:\npublic final class ServiceLoader\u0026amp;lt;S\u0026amp;gt; implements Iterable\u0026amp;lt;S\u0026amp;gt; { public static \u0026amp;lt;S\u0026amp;gt; ServiceLoader\u0026amp;lt;S\u0026amp;gt; load(Class\u0026amp;lt;S\u0026amp;gt; service) { // 获取当前的类加载器 (我们自己的通常是弟中弟 AppClassLoader ) ClassLoader cl = …","date":1611964800,"description":"ShenYu网关学习SPI学习使用","dir":"blog/shenyu_source_learning_11_SPI/","fuzzywordcount":5500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"fa49f3565057b48613fe10eb517245fa784933ab","permalink":"/zh/blog/shenyu_source_learning_11_spi/","publishdate":"2021-01-30T00:00:00Z","readingtime":11,"relpermalink":"/zh/blog/shenyu_source_learning_11_spi/","summary":"SOUL 中 SPI 的使用 在之前分析 divide 插件的负载均衡策略时, 有看到过一行代码: DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); 当时很简单的略过了它的实现, 它的作用很容易分析, 调用一个看似工具","tags":["ShenYu"],"title":"ShenYu网关学习SPI学习使用","type":"blog","url":"/zh/blog/shenyu_source_learning_11_spi/","wordcount":5445},{"author":"tangtian","categories":"ShenYu","content":" 介绍 sign插件用来对请求进行签名认证的插件\nAK/SK 介绍 AK/SK（Access Key ID/Secret Access Key）即访问密钥，包含访问密钥ID（AK）和秘密访问密钥（SK）两部分，主要用于对用户的调用行为进行鉴权和认证。\n插件使用-以（/dubbo/findAll）为例 在SoulBootstrap的 pom.xml 文件中添加 sign 的支持 \u0026amp;lt;!-- ShenYu sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- ShenYu sign plugin end--\u0026amp;gt;  新增appKey，secretKey 配置选择器和规则器 添加选择器 添加规则器 增加获取鉴权服务 在自己服务中增加一个对外访问的方法\n@GetMapping(\u0026amp;quot;/authUrl\u0026amp;quot;) public String authUrl() { Map\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) String timetamp = String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) ; System.out.println(timetamp); map.put(\u0026amp;quot;timestamp\u0026amp;quot;,timetamp); //值应该为毫秒数的字符串形式 map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/dubbo/findAll\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;); List\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, map.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;D19CF79F647A465AB9C5C66F430CAD28\u0026amp;quot;);//SECRETkey return DigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase(); }  下面需要注意的 在网关中增加鉴权头信息 请求的结果演示 通过的返回 5min超时的返回 appKey填写错误的返回 签名错误的返回 禁用sign插件的返回 sign插件的实现分析 java中Pair 简单的说就是pair保存的是一对key value，而map可以保存多对key value。 SignPlugin插件调用DefaultSignService中signVerify方法 判断sign 插件是否可用，如果可用获取在global 插件存入的soulContext并调用verify方法\nif (signData != null \u0026amp;amp;\u0026amp;amp; signData.getEnabled()) { final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT); assert soulContext != null; return verify(soulContext, exchange); }  verify方法中 判断请求头信息是否正确 如果不正确就抛出 log.error(\u0026amp;ldquo;sign parameters are incomplete,{}\u0026amp;rdquo;, soulContext)异常\nif (StringUtils.isBlank(soulContext.getAppKey()) || StringUtils.isBlank(soulContext.getSign()) || StringUtils.isBlank(soulContext.getTimestamp())) { log.error(\u0026amp;quot;sign parameters are incomplete,{}\u0026amp;quot;, soulContext); return Pair.of(Boolean.FALSE, Constants.SIGN_PARAMS_ERROR); }  判断请求时间是否超时\nif (between \u0026amp;gt; delay) { return Pair.of(Boolean.FALSE, String.format(SoulResultEnum.SING_TIME_IS_TIMEOUT.getMsg(), delay)); }  没有超时继续调用sign方法 获取认证数据，这个数据在soulAdmin 中配置\nAppAuthData appAuthData = SignAuthDataCache.getInstance().obtainAuthData(soulContext.getAppKey());  后面对appAuthData数据进行判断，数据有错误就不通过 对获取的参数再次签名，判断传入的和再次签名的是否一样\nString sigKey = SignUtils.generateSign(appAuthData.getAppSecret(), buildParamsMap(soulContext));  如果都校验都通过就完成认证 访问请求。\n","date":1611878400,"description":"ShenYu Gateway Learning Sign Plugin","dir":"blog/shenyu_source_learning_12_sign/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"5d581961c65627e7dd4d2b66454e19e80f8f217a","permalink":"/blog/shenyu_source_learning_12_sign/","publishdate":"2021-01-29T00:00:00Z","readingtime":2,"relpermalink":"/blog/shenyu_source_learning_12_sign/","summary":"介绍 sign插件用来对请求进行签名认证的插件 AK/SK 介绍 AK/SK（Access Key ID/Secret Access Key）即访问密钥，包含访问密钥ID（AK）和秘密访问密钥（","tags":["ShenYu"],"title":"ShenYu Gateway Learning Sign Plugin","type":"blog","url":"/blog/shenyu_source_learning_12_sign/","wordcount":759},{"author":"唐甜","categories":"ShenYu","content":" 介绍 sign插件用来对请求进行签名认证的插件\nAK/SK 介绍 AK/SK（Access Key ID/Secret Access Key）即访问密钥，包含访问密钥ID（AK）和秘密访问密钥（SK）两部分，主要用于对用户的调用行为进行鉴权和认证。\n插件使用-以（/dubbo/findAll）为例 在SoulBootstrap的 pom.xml 文件中添加 sign 的支持 \u0026amp;lt;!-- soul sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sign plugin end--\u0026amp;gt;  新增appKey，secretKey 配置选择器和规则器 添加选择器 添加规则器 增加获取鉴权服务 在自己服务中增加一个对外访问的方法\n@GetMapping(\u0026amp;quot;/authUrl\u0026amp;quot;) public String authUrl() { Map\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) String timetamp = String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) ; System.out.println(timetamp); map.put(\u0026amp;quot;timestamp\u0026amp;quot;,timetamp); //值应该为毫秒数的字符串形式 map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/dubbo/findAll\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;); List\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, map.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;D19CF79F647A465AB9C5C66F430CAD28\u0026amp;quot;);//SECRETkey return DigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase(); }  下面需要注意的 在网关中增加鉴权头信息 请求的结果演示 通过的返回 5min超时的返回 appKey填写错误的返回 签名错误的返回 禁用sign插件的返回 sign插件的实现分析 java中Pair 简单的说就是pair保存的是一对key value，而map可以保存多对key value。 SignPlugin插件调用DefaultSignService中signVerify方法 判断sign 插件是否可用，如果可用获取在global 插件存入的soulContext并调用verify方法\nif (signData != null \u0026amp;amp;\u0026amp;amp; signData.getEnabled()) { final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT); assert soulContext != null; return verify(soulContext, exchange); }  verify方法中 判断请求头信息是否正确 如果不正确就抛出 log.error(\u0026amp;ldquo;sign parameters are incomplete,{}\u0026amp;rdquo;, soulContext)异常\nif (StringUtils.isBlank(soulContext.getAppKey()) || StringUtils.isBlank(soulContext.getSign()) || StringUtils.isBlank(soulContext.getTimestamp())) { log.error(\u0026amp;quot;sign parameters are incomplete,{}\u0026amp;quot;, soulContext); return Pair.of(Boolean.FALSE, Constants.SIGN_PARAMS_ERROR); }  判断请求时间是否超时\nif (between \u0026amp;gt; delay) { return Pair.of(Boolean.FALSE, String.format(SoulResultEnum.SING_TIME_IS_TIMEOUT.getMsg(), delay)); }  没有超时继续调用sign方法 获取认证数据，这个数据在soulAdmin 中配置\nAppAuthData appAuthData = SignAuthDataCache.getInstance().obtainAuthData(soulContext.getAppKey());  后面对appAuthData数据进行判断，数据有错误就不通过 对获取的参数再次签名，判断传入的和再次签名的是否一样\nString sigKey = SignUtils.generateSign(appAuthData.getAppSecret(), buildParamsMap(soulContext));  如果都校验都通过就完成认证 访问请求。\n","date":1611878400,"description":"ShenYu网关学习Sign插件","dir":"blog/shenyu_source_learning_12_sign/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"51c7e546af6828d6c8b046eb46b75f6f6ccf2ce0","permalink":"/zh/blog/shenyu_source_learning_12_sign/","publishdate":"2021-01-29T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/shenyu_source_learning_12_sign/","summary":"介绍 sign插件用来对请求进行签名认证的插件 AK/SK 介绍 AK/SK（Access Key ID/Secret Access Key）即访问密钥，包含访问密钥ID（AK）和秘密访问密钥（","tags":["ShenYu"],"title":"ShenYu网关学习Sign插件","type":"blog","url":"/zh/blog/shenyu_source_learning_12_sign/","wordcount":759},{"author":"zhuming","categories":"ShenYu","content":" 后台与网关数据同步 (Http长轮询篇) 长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式.\n网关端长轮询的流程总体也分两个模块: 一是启动时拉取, 二是轮询监听变化\n网关启动时拉取数据 网关启动后, 会调用后台提供的接口拉取数据, 并将数据发送到各个插件的数据处理类中\n下面展示下网关启动拉取数据的处理流程: 这几个处理步骤被分散到下面这些类的方法协作中:\nHttpSyncDataService#start: 网关启动时, HttpSyncDataService 初始化会调用 start() 方法, 该方法会调用后台拉取数据, 并开启多个线程进行轮询监听 (这块在下个模块分析)\npublic class HttpSyncDataService implements SyncDataService, AutoCloseable { private void start() { // 防止二次调用的CAS操作 if (RUNNING.compareAndSet(false, true)) { // 这里是本次流程的重点, 调用拉取数据的方法 this.fetchGroupConfig(ConfigGroupEnum.values()); int threadSize = serverList.size(); // 这里将在下个模块分析, 会根据后台集群开启线程轮询监听 this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;(), SoulThreadFactory.create(\u0026amp;quot;http-long-polling\u0026amp;quot;, true)); this.serverList.forEach(server -\u0026amp;gt; this.executor.execute(new HttpLongPollingTask(server))); } else { log.info(\u0026amp;quot;ShenYu http long polling was started, executor=[{}]\u0026amp;quot;, executor); } } }  HttpSyncDataService#fetchGroupConfig: 作用仅是根据数据类型, 循环多次调用拉取数据方法(针对同一个后台会请求多次, 每次拉取某一种数据类型的信息), 这里的数据类型指的是 plugin、rule、selector 等\nprivate void fetchGroupConfig(final ConfigGroupEnum... groups) throws SoulException { for (int index = 0; index \u0026amp;lt; this.serverList.size(); index++) { String server = serverList.get(index); try { // 根据传入的数据类型枚举, 多次调用拉取数据方法 this.doFetchGroupConfig(server, groups); break; } catch (SoulException e) { if (index \u0026amp;gt;= serverList.size() - 1) { throw e; } log.warn(\u0026amp;quot;fetch config fail, try another one: {}\u0026amp;quot;, serverList.get(index + 1)); } } }  HttpSyncDataService#doFetchGroupConfig: 请求后台的 /configs/fetch 接口, 拿到某个类型的数据, 并更新缓存. 更新缓存前会检测是否变动, 如果变动则结束, 数据未发生变动则睡眠30s (由于是第一次启动, 数据为空的情况下肯定会更新缓存, 所以会直接结束)\nprivate void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) { StringBuilder params = new StringBuilder(); for (ConfigGroupEnum groupKey : groups) { params.append(\u0026amp;quot;groupKeys\u0026amp;quot;).append(\u0026amp;quot;=\u0026amp;quot;).append(groupKey.name()).append(\u0026amp;quot;\u0026amp;amp;\u0026amp;quot;); } // 具体请求路径, 拉取后台数据 String url = server + \u0026amp;quot;/configs/fetch?\u0026amp;quot; + StringUtils.removeEnd(params.toString(), \u0026amp;quot;\u0026amp;amp;\u0026amp;quot;); log.info(\u0026amp;quot;request configs: [{}]\u0026amp;quot;, url); String json = null; try { json = this.httpClient.getForObject(url, String.class); } catch (RestClientException e) { String message = String.format(\u0026amp;quot;fetch config fail from server[%s], %s\u0026amp;quot;, url, e.getMessage()); log.warn(message); throw new SoulException(message, e); } // 修改缓存信息 boolean updated = this.updateCacheWithJson(json); // 判断是否修改, 修改则直接结束 if (updated) { log.info(\u0026amp;quot;get latest configs: [{}]\u0026amp;quot;, json); return; } log.info(\u0026amp;quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.\u0026amp;quot;, server); ThreadUtils.sleep(TimeUnit.SECONDS, 30); }  HttpSyncDataService#updateCacheWithJson: 取出响应信息中的 data , 即变化的数据信息, 传给数据刷新工厂 DataRefreshFactory\nprivate DataRefreshFactory factory; public HttpSyncDataService(...){ this.factory = new …","date":1611705600,"description":"ShenYu Gateway Learns Http Long Polling Analysis","dir":"blog/shenyu_source_learning_09_httplongpolling_02/","fuzzywordcount":1800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"292e07b6ea7df88b13207e5f76a87d102042d52f","permalink":"/blog/shenyu_source_learning_09_httplongpolling_02/","publishdate":"2021-01-27T00:00:00Z","readingtime":4,"relpermalink":"/blog/shenyu_source_learning_09_httplongpolling_02/","summary":"后台与网关数据同步 (Http长轮询篇) 长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式. 网关端长轮询的流程总体也分两个模块:","tags":["ShenYu"],"title":"ShenYu Gateway Learns Http Long Polling Analysis 02","type":"blog","url":"/blog/shenyu_source_learning_09_httplongpolling_02/","wordcount":1750},{"author":"朱明","categories":"ShenYu","content":" 后台与网关数据同步 (Http长轮询篇) 长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式.\n网关端长轮询的流程总体也分两个模块: 一是启动时拉取, 二是轮询监听变化\n网关启动时拉取数据 网关启动后, 会调用后台提供的接口拉取数据, 并将数据发送到各个插件的数据处理类中\n下面展示下网关启动拉取数据的处理流程: 这几个处理步骤被分散到下面这些类的方法协作中:\nHttpSyncDataService#start: 网关启动时, HttpSyncDataService 初始化会调用 start() 方法, 该方法会调用后台拉取数据, 并开启多个线程进行轮询监听 (这块在下个模块分析)\npublic class HttpSyncDataService implements SyncDataService, AutoCloseable { private void start() { // 防止二次调用的CAS操作 if (RUNNING.compareAndSet(false, true)) { // 这里是本次流程的重点, 调用拉取数据的方法 this.fetchGroupConfig(ConfigGroupEnum.values()); int threadSize = serverList.size(); // 这里将在下个模块分析, 会根据后台集群开启线程轮询监听 this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;(), SoulThreadFactory.create(\u0026amp;quot;http-long-polling\u0026amp;quot;, true)); this.serverList.forEach(server -\u0026amp;gt; this.executor.execute(new HttpLongPollingTask(server))); } else { log.info(\u0026amp;quot;soul http long polling was started, executor=[{}]\u0026amp;quot;, executor); } } }  HttpSyncDataService#fetchGroupConfig: 作用仅是根据数据类型, 循环多次调用拉取数据方法(针对同一个后台会请求多次, 每次拉取某一种数据类型的信息), 这里的数据类型指的是 plugin、rule、selector 等\nprivate void fetchGroupConfig(final ConfigGroupEnum... groups) throws SoulException { for (int index = 0; index \u0026amp;lt; this.serverList.size(); index++) { String server = serverList.get(index); try { // 根据传入的数据类型枚举, 多次调用拉取数据方法 this.doFetchGroupConfig(server, groups); break; } catch (SoulException e) { if (index \u0026amp;gt;= serverList.size() - 1) { throw e; } log.warn(\u0026amp;quot;fetch config fail, try another one: {}\u0026amp;quot;, serverList.get(index + 1)); } } }  HttpSyncDataService#doFetchGroupConfig: 请求后台的 /configs/fetch 接口, 拿到某个类型的数据, 并更新缓存. 更新缓存前会检测是否变动, 如果变动则结束, 数据未发生变动则睡眠30s (由于是第一次启动, 数据为空的情况下肯定会更新缓存, 所以会直接结束)\nprivate void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) { StringBuilder params = new StringBuilder(); for (ConfigGroupEnum groupKey : groups) { params.append(\u0026amp;quot;groupKeys\u0026amp;quot;).append(\u0026amp;quot;=\u0026amp;quot;).append(groupKey.name()).append(\u0026amp;quot;\u0026amp;amp;\u0026amp;quot;); } // 具体请求路径, 拉取后台数据 String url = server + \u0026amp;quot;/configs/fetch?\u0026amp;quot; + StringUtils.removeEnd(params.toString(), \u0026amp;quot;\u0026amp;amp;\u0026amp;quot;); log.info(\u0026amp;quot;request configs: [{}]\u0026amp;quot;, url); String json = null; try { json = this.httpClient.getForObject(url, String.class); } catch (RestClientException e) { String message = String.format(\u0026amp;quot;fetch config fail from server[%s], %s\u0026amp;quot;, url, e.getMessage()); log.warn(message); throw new SoulException(message, e); } // 修改缓存信息 boolean updated = this.updateCacheWithJson(json); // 判断是否修改, 修改则直接结束 if (updated) { log.info(\u0026amp;quot;get latest configs: [{}]\u0026amp;quot;, json); return; } log.info(\u0026amp;quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.\u0026amp;quot;, server); ThreadUtils.sleep(TimeUnit.SECONDS, 30); }  HttpSyncDataService#updateCacheWithJson: 取出响应信息中的 data , 即变化的数据信息, 传给数据刷新工厂 DataRefreshFactory\nprivate DataRefreshFactory factory; public HttpSyncDataService(...){ this.factory = new …","date":1611705600,"description":"ShenYu网关学习Http长轮询解析","dir":"blog/shenyu_source_learning_09_httplongpolling_02/","fuzzywordcount":1800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"a46cf7e2de9fb8b7f9383df94bccba5b3a269856","permalink":"/zh/blog/shenyu_source_learning_09_httplongpolling_02/","publishdate":"2021-01-27T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/shenyu_source_learning_09_httplongpolling_02/","summary":"后台与网关数据同步 (Http长轮询篇) 长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式. 网关端长轮询的流程总体也分两个模块:","tags":["ShenYu"],"title":"ShenYu网关学习Http长轮询解析02","type":"blog","url":"/zh/blog/shenyu_source_learning_09_httplongpolling_02/","wordcount":1750},{"author":"baiyu","categories":"ShenYu","content":" 回顾 在ShenYu请求处理概览概览这篇文章中，我们已经知晓了Soul针对于请求的处理入库在DefaultSoulPluginChain的excute，其中执行了一个插件链的模式来完成了请求的处理。\n我们大体梳理了注入到plugins的插件，但是即使这样依然不能纵观全局，对此特地对soul插件所涉及的类进行了相关梳理，整体梳理结果如下图。\n在梳理文章中可以看到核心类是SoulPlugin、PluginEnum、PluginDataHandler、MetaDataSubscriber，在梳理请求的相关文章中我们目前只需要重点关注SoulPlugin与PluginEnum类。\nSoulPlugin类我们已经有了一定的理解，那PluginEnum枚举类的主要作用是什么呢？\nPluginEnum:插件的枚举类\n   属性 作用     code 插件的执行顺序 越小越先执行   role 角色 暂时未发现实际引用地址   name 插件名称    其实我们不难发现在DefaultSoulPluginChain的plugins的插件都是有固定的执行顺序的，那这个插件的执行顺序是在哪定义的呢？\n最终可以追溯到SoulConfiguration类下\npublic SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { //省略 final List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); return new SoulWebHandler(soulPlugins); }  整理整个PluginEnum类相关引用，整理出如下表格，不难看出插件与插件之间的顺序关系    等级 作用     第一等级 只有GlobalPlugin 全局插件   第二等级到第八等级 可以理解为在请求发起前的前置处理插件   第九等级到第十一等级 可以理解为针对调用方的方式所针对的不同调用处理   第十二等级 只有MonitorPlugin 监控插件   第十三等级 是针对于各个调用方返回结果处理的Response相关插件    在刚才的回顾中我们已经明白soul处理请求的大体流程 - 1.GloBalPlugin插件 进行全局的初始化 - 2.部分插件根据鉴权、限流、熔断等规则对请求进行处理 - 3.选择适合自己的调用方式进行拼装参数，发起调用。 - 4.进行监控 - 5.对调用的结果进行处理\n请求流程梳理  以下演示代码截图来自于soul-examples下的http demo，调用的接口地址为http://127.0.0.1:9195/http/test/findByUserId?userId=10\n 在DefaultSoulPluginChain的excute方法进行埋点，查看一次http请求调用经过了哪些类？\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange) { return Mono.defer(() -\u0026amp;gt; { if (this.index \u0026amp;lt; plugins.size()) { SoulPlugin plugin = plugins.get(this.index++); Boolean skip = plugin.skip(exchange); if (skip) { System.out.println(\u0026amp;quot;跳过的插件为\u0026amp;quot;+plugin.getClass().getName().replace(\u0026amp;quot;org.dromara.soul.plugin.\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;)); return this.execute(exchange); } System.out.println(\u0026amp;quot;未跳过的插件为\u0026amp;quot;+plugin.getClass().getName().replace(\u0026amp;quot;org.dromara.soul.plugin.\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;)); return plugin.execute(exchange, this); } return Mono.empty(); }); }  最终输出的未跳过的插件如下：\n未跳过的插件为global.GlobalPlugin\n未跳过的插件为sign.SignPlugin\n未跳过的插件为waf.WafPlugin\n未跳过的插件为ratelimiter.RateLimiterPlugin\n未跳过的插件为hystrix.HystrixPlugin\n未跳过的插件为resilience4j.Resilience4JPlugin\n未跳过的插件为divide.DividePlugin\n未跳过的插件为httpclient.WebClientPlugin\n未跳过的插件为alibaba.dubbo.param.BodyParamPlugin\n未跳过的插件为monitor.MonitorPlugin\n未跳过的插件为httpclient.response.WebClientResponsePlugin\n 这里有个小疑惑，为啥这个alibaba.dubbo.param.BodyParamPlugin插件会被执行，暂时忽略，后期跟踪。\n 我们发现一次针对于http请求的网关调用 所执行的插件的大体流程与我们猜想的处理流程一致。\n目前我们只挑重点来讲，即GlobalPlugin、DividePlugin、WebClientPlugin、WebClientResponsePlugin。\n发起Debug调用依次追踪上述四个插件的作用。\nGlobalPlugin SoulContext对象封装插件 GlobalPlugin的插件的excute方法如下所示\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { final ServerHttpRequest request = exchange.getRequest(); final HttpHeaders headers = request.getHeaders(); final String upgrade = headers.getFirst(\u0026amp;quot;Upgrade\u0026amp;quot;); SoulContext soulContext; if (StringUtils.isBlank(upgrade) || !\u0026amp;quot;websocket\u0026amp;quot;.equals(upgrade)) { soulContext = builder.build(exchange); } else { …","date":1611619200,"description":"ShenYu Gateway Learning Http Request Adventure","dir":"blog/shenyu_source_learning_17_http/","fuzzywordcount":5100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"cec0350ab2b80fd92136921650df512c16f04266","permalink":"/blog/shenyu_source_learning_17_http/","publishdate":"2021-01-26T00:00:00Z","readingtime":11,"relpermalink":"/blog/shenyu_source_learning_17_http/","summary":"回顾 在ShenYu请求处理概览概览这篇文章中，我们已经知晓了Soul针对于请求的处理入库在DefaultSoulPluginChain的ex","tags":["ShenYu"],"title":"ShenYu Gateway Learning Http Request Adventure","type":"blog","url":"/blog/shenyu_source_learning_17_http/","wordcount":5081},{"author":"liquan","categories":"ShenYu","content":" 本篇分析一下Nacos同步数据原理\n1、先配置一下环境 * soul-admin soul-admin/src/main/resources/application.yml\nsoul: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey:  soul-admin/pom.xml，这里默认配置是有的\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${nacos-client.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   soul-bootstrap soul-bootstrap/src/main/resources/application-local.yml\nShenYu : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey:  soul-bootstrap/pom.xml，下面的配置默认是没有的，需要手动添加\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  启动服务\n1、启动 nacos 2、启动 soul-admin 3、启动 soul-bootstrap  2、上面看着挺顺利，这个过程遇到了坑，soul-bootstrap 启动不起来报空指针异常，下面详细记录一下。 首先soul-admin启动后不会主动向nacos同步网关数据，需要手动同步，官网这一点没有提到。这个问题绊了我好久，最后是看到了群里其他同学遇到了同样的问题，参考了他们的文章才解决，下面记录一下解决过程。\n  1）soul-bootstrap 启动的时候遇到了如下的错误，NullPointerException。\nsoul-bootstrap 启动的时候会去，nacos获取网关数据，看到下面的断点，拿到的是空数据。\nError starting ApplicationContext. To display the conditions report re-run your application with \u0026#39;debug\u0026#39; enabled. 2021-01-25 16:49:06.052 ERROR 5273 --- [ main] o.s.boot.SpringApplication : Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026#39;nacosSyncDataService\u0026#39; defined in class path resource [org/dromara/soul/springboot/starter/sync/data/nacos/NacosSyncDataConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.dromara.soul.sync.data.api.SyncDataService]: Factory method \u0026#39;nacosSyncDataService\u0026#39; threw exception; nested exception is java.lang.NullPointerException ...... at org.dromara.soul.bootstrap.SoulBootstrapApplication.main(SoulBootstrapApplication.java:37) [classes/:na] Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.dromara.soul.sync.data.api.SyncDataService]: Factory method \u0026#39;nacosSyncDataService\u0026#39; threw exception; nested exception is java.lang.NullPointerException at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE] at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:651) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE] ... 19 common frames omitted Caused by: java.lang.NullPointerException: null at org.dromara.soul.sync.data.nacos.handler.NacosCacheHandler.updateMetaDataMap(NacosCacheHandler.java:128) ~[classes/:na] at …","date":1611619200,"description":"ShenYu Gateway Learns Nacos Data Synchronization","dir":"blog/shenyu_source_learning_14_nacos/","fuzzywordcount":2800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b4f469beb9961944bd4aea8a23660e4b247ad5e1","permalink":"/blog/shenyu_source_learning_14_nacos/","publishdate":"2021-01-26T00:00:00Z","readingtime":6,"relpermalink":"/blog/shenyu_source_learning_14_nacos/","summary":"本篇分析一下Nacos同步数据原理 1、先配置一下环境 * soul-admin soul-admin/src/main/resources/application.yml soul: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey: soul-admin/pom.xml，这","tags":["ShenYu"],"title":"ShenYu Gateway Learns Nacos Data Synchronization","type":"blog","url":"/blog/shenyu_source_learning_14_nacos/","wordcount":2768},{"author":"百钰","categories":"ShenYu","content":" 回顾 在ShenYu 请求处理概览概览这篇文章中，我们已经知晓了Soul针对于请求的处理入库在DefaultSoulPluginChain的excute，其中执行了一个插件链的模式来完成了请求的处理。\n我们大体梳理了注入到plugins的插件，但是即使这样依然不能纵观全局，对此特地对soul插件所涉及的类进行了相关梳理，整体梳理结果如下图。\n在梳理文章中可以看到核心类是SoulPlugin、PluginEnum、PluginDataHandler、MetaDataSubscriber，在梳理请求的相关文章中我们目前只需要重点关注SoulPlugin与PluginEnum类。\nSoulPlugin类我们已经有了一定的理解，那PluginEnum枚举类的主要作用是什么呢？\nPluginEnum:插件的枚举类\n   属性 作用     code 插件的执行顺序 越小越先执行   role 角色 暂时未发现实际引用地址   name 插件名称    其实我们不难发现在DefaultSoulPluginChain的plugins的插件都是有固定的执行顺序的，那这个插件的执行顺序是在哪定义的呢？\n最终可以追溯到SoulConfiguration类下\npublic SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { //省略 final List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); return new SoulWebHandler(soulPlugins); }  整理整个PluginEnum类相关引用，整理出如下表格，不难看出插件与插件之间的顺序关系    等级 作用     第一等级 只有GlobalPlugin 全局插件   第二等级到第八等级 可以理解为在请求发起前的前置处理插件   第九等级到第十一等级 可以理解为针对调用方的方式所针对的不同调用处理   第十二等级 只有MonitorPlugin 监控插件   第十三等级 是针对于各个调用方返回结果处理的Response相关插件    在刚才的回顾中我们已经明白soul处理请求的大体流程 - 1.GloBalPlugin插件 进行全局的初始化 - 2.部分插件根据鉴权、限流、熔断等规则对请求进行处理 - 3.选择适合自己的调用方式进行拼装参数，发起调用。 - 4.进行监控 - 5.对调用的结果进行处理\n请求流程梳理  以下演示代码截图来自于soul-examples下的http demo，调用的接口地址为http://127.0.0.1:9195/http/test/findByUserId?userId=10\n 在DefaultSoulPluginChain的excute方法进行埋点，查看一次http请求调用经过了哪些类？\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange) { return Mono.defer(() -\u0026amp;gt; { if (this.index \u0026amp;lt; plugins.size()) { SoulPlugin plugin = plugins.get(this.index++); Boolean skip = plugin.skip(exchange); if (skip) { System.out.println(\u0026amp;quot;跳过的插件为\u0026amp;quot;+plugin.getClass().getName().replace(\u0026amp;quot;org.dromara.soul.plugin.\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;)); return this.execute(exchange); } System.out.println(\u0026amp;quot;未跳过的插件为\u0026amp;quot;+plugin.getClass().getName().replace(\u0026amp;quot;org.dromara.soul.plugin.\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;)); return plugin.execute(exchange, this); } return Mono.empty(); }); }  最终输出的未跳过的插件如下：\n未跳过的插件为global.GlobalPlugin\n未跳过的插件为sign.SignPlugin\n未跳过的插件为waf.WafPlugin\n未跳过的插件为ratelimiter.RateLimiterPlugin\n未跳过的插件为hystrix.HystrixPlugin\n未跳过的插件为resilience4j.Resilience4JPlugin\n未跳过的插件为divide.DividePlugin\n未跳过的插件为httpclient.WebClientPlugin\n未跳过的插件为alibaba.dubbo.param.BodyParamPlugin\n未跳过的插件为monitor.MonitorPlugin\n未跳过的插件为httpclient.response.WebClientResponsePlugin\n 这里有个小疑惑，为啥这个alibaba.dubbo.param.BodyParamPlugin插件会被执行，暂时忽略，后期跟踪。\n 我们发现一次针对于http请求的网关调用 所执行的插件的大体流程与我们猜想的处理流程一致。\n目前我们只挑重点来讲，即GlobalPlugin、DividePlugin、WebClientPlugin、WebClientResponsePlugin。\n发起Debug调用依次追踪上述四个插件的作用。\nGlobalPlugin SoulContext对象封装插件 GlobalPlugin的插件的excute方法如下所示\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { final ServerHttpRequest request = exchange.getRequest(); final HttpHeaders headers = request.getHeaders(); final String upgrade = headers.getFirst(\u0026amp;quot;Upgrade\u0026amp;quot;); SoulContext soulContext; if (StringUtils.isBlank(upgrade) || !\u0026amp;quot;websocket\u0026amp;quot;.equals(upgrade)) { soulContext = builder.build(exchange); } else { …","date":1611619200,"description":"ShenYu网关学习Http请求探险","dir":"blog/shenyu_source_learning_17_http/","fuzzywordcount":5100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"b6e69ad80b585c39011392fd91c9f6bf121d0179","permalink":"/zh/blog/shenyu_source_learning_17_http/","publishdate":"2021-01-26T00:00:00Z","readingtime":11,"relpermalink":"/zh/blog/shenyu_source_learning_17_http/","summary":"回顾 在ShenYu 请求处理概览概览这篇文章中，我们已经知晓了Soul针对于请求的处理入库在DefaultSoulPluginChain的ex","tags":["ShenYu"],"title":"ShenYu网关学习Http请求探险","type":"blog","url":"/zh/blog/shenyu_source_learning_17_http/","wordcount":5083},{"author":"李权","categories":"ShenYu","content":" 本篇分析一下Nacos同步数据原理\n1、先配置一下环境 * soul-admin soul-admin/src/main/resources/application.yml\nsoul: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey:  soul-admin/pom.xml，这里默认配置是有的\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${nacos-client.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   soul-bootstrap soul-bootstrap/src/main/resources/application-local.yml\nsoul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey:  soul-bootstrap/pom.xml，下面的配置默认是没有的，需要手动添加\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  启动服务\n1、启动 nacos 2、启动 soul-admin 3、启动 soul-bootstrap  2、上面看着挺顺利，这个过程遇到了坑，soul-bootstrap 启动不起来报空指针异常，下面详细记录一下。 首先soul-admin启动后不会主动向nacos同步网关数据，需要手动同步，官网这一点没有提到。这个问题绊了我好久，最后是看到了群里其他同学遇到了同样的问题，参考了他们的文章才解决，下面记录一下解决过程。\n  1）soul-bootstrap 启动的时候遇到了如下的错误，NullPointerException。\nsoul-bootstrap 启动的时候会去，nacos获取网关数据，看到下面的断点，拿到的是空数据。\nError starting ApplicationContext. To display the conditions report re-run your application with \u0026#39;debug\u0026#39; enabled. 2021-01-25 16:49:06.052 ERROR 5273 --- [ main] o.s.boot.SpringApplication : Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026#39;nacosSyncDataService\u0026#39; defined in class path resource [org/dromara/soul/springboot/starter/sync/data/nacos/NacosSyncDataConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.dromara.soul.sync.data.api.SyncDataService]: Factory method \u0026#39;nacosSyncDataService\u0026#39; threw exception; nested exception is java.lang.NullPointerException ...... at org.dromara.soul.bootstrap.SoulBootstrapApplication.main(SoulBootstrapApplication.java:37) [classes/:na] Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.dromara.soul.sync.data.api.SyncDataService]: Factory method \u0026#39;nacosSyncDataService\u0026#39; threw exception; nested exception is java.lang.NullPointerException at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE] at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:651) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE] ... 19 common frames omitted Caused by: java.lang.NullPointerException: null at org.dromara.soul.sync.data.nacos.handler.NacosCacheHandler.updateMetaDataMap(NacosCacheHandler.java:128) ~[classes/:na] at …","date":1611619200,"description":"ShenYu网关学习Nacos数据同步","dir":"blog/shenyu_source_learning_14_nacos/","fuzzywordcount":2800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"4f2e1b8c6556057210f638ccd893a2ff9c34ad12","permalink":"/zh/blog/shenyu_source_learning_14_nacos/","publishdate":"2021-01-26T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/shenyu_source_learning_14_nacos/","summary":"本篇分析一下Nacos同步数据原理 1、先配置一下环境 * soul-admin soul-admin/src/main/resources/application.yml soul: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c # acm: # enabled: false # endpoint: acm.aliyun.com # namespace: # accessKey: # secretKey: soul-admin/pom.xml，这","tags":["ShenYu"],"title":"ShenYu网关学习Nacos数据同步","type":"blog","url":"/zh/blog/shenyu_source_learning_14_nacos/","wordcount":2768},{"author":"zhuming","categories":"ShenYu","content":" 后台与网关数据同步 (Http长轮询篇) 配置 后台信息模式切换\n在上篇分析 Zookeeper 同步的文章 (Soul网关源码分析-11期) 中, 我们通过 DataSyncConfiguration 这个配置类做的切换, 这次有了经验, 直接贴配置\nsoul: sync: websocket: enabled: false http: enabled: true  网关信息模式切换\n后台模式切换完成, 接下来就是网关, 继续照葫芦画瓢找到关键配置类上的参数设置. 这里也直接贴网关配置\nsoul: sync: #\twebsocket: #\turls: ws://localhost:9095/websocket http: url: http://localhost:9095  DataChangedListener 体系 后台数据初始化 DataSyncConfiguration 配置关键 Bean , 看看这里关于 Http 长轮询的 Bean\n@Configuration public class DataSyncConfiguration { @Configuration @ConditionalOnProperty(name = \u0026amp;quot;soul.sync.http.enabled\u0026amp;quot;, havingValue = \u0026amp;quot;true\u0026amp;quot;) @EnableConfigurationProperties(HttpSyncProperties.class) static class HttpLongPollingListener { @Bean @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class) public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) { return new HttpLongPollingDataChangedListener(httpSyncProperties); } } }  HttpLongPollingDataChangedListener 继承自 AbstractDataChangedListener, 他们都实现自接口 DataChangedListener.\nDataChangedListener 这个接口我们应该非常熟悉了, 它提供了众多不同数据类型变动的方法, 供 DataChangedEventDispatcher 调用, 这个类更是一个 \u0026amp;ldquo;老朋友\u0026amp;rdquo; 了, 作为一个中转站, 辛勤的处理数据同步的事件分类及分发\npublic class DataChangedEventDispatcher implements ApplicationListener\u0026amp;lt;DataChangedEvent\u0026amp;gt;, InitializingBean { // 持有 DataChangedListener 集合 private List\u0026amp;lt;DataChangedListener\u0026amp;gt; listeners; // 事件变动时, 通知 DataChangedListener 的不同事件类型的方法 public void onApplicationEvent(final DataChangedEvent event) { for (DataChangedListener listener : listeners) { switch (event.getGroupKey()) { case APP_AUTH: listener.onAppAuthChanged((List\u0026amp;lt;AppAuthData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case PLUGIN: listener.onPluginChanged((List\u0026amp;lt;PluginData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case RULE: listener.onRuleChanged((List\u0026amp;lt;RuleData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case SELECTOR: listener.onSelectorChanged((List\u0026amp;lt;SelectorData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case META_DATA: listener.onMetaDataChanged((List\u0026amp;lt;MetaData\u0026amp;gt;) event.getSource(), event.getEventType()); break; default: throw new IllegalStateException(\u0026amp;quot;Unexpected value: \u0026amp;quot; + event.getGroupKey()); } } } }  public interface DataChangedListener { default void onAppAuthChanged(List\u0026amp;lt;AppAuthData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onPluginChanged(List\u0026amp;lt;PluginData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onSelectorChanged(List\u0026amp;lt;SelectorData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onMetaDataChanged(List\u0026amp;lt;MetaData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onRuleChanged(List\u0026amp;lt;RuleData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} }  这两个的作用了解了, 那 AbstractDataChangedListener 又做了什么事情? 举个 onPluginChanged() 的例子:\npublic abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean { protected static final ConcurrentMap\u0026amp;lt;String, …","date":1611532800,"description":"ShenYu Gateway Learns Http Long Polling Analysis","dir":"blog/shenyu_source_learning_08_httplongpolling_01/","fuzzywordcount":2800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"ea4529705ac37535e1a8a681f1d3b29bb7b9f2fc","permalink":"/blog/shenyu_source_learning_08_httplongpolling_01/","publishdate":"2021-01-25T00:00:00Z","readingtime":6,"relpermalink":"/blog/shenyu_source_learning_08_httplongpolling_01/","summary":"后台与网关数据同步 (Http长轮询篇) 配置 后台信息模式切换 在上篇分析 Zookeeper 同步的文章 (Soul网关源码分析-11期) 中, 我们通过 DataSyncConfiguration 这个配置类做的","tags":["ShenYu"],"title":"ShenYu Gateway Learns Http Long Polling Analysis 01","type":"blog","url":"/blog/shenyu_source_learning_08_httplongpolling_01/","wordcount":2736},{"author":"朱明","categories":"ShenYu","content":" 后台与网关数据同步 (Http长轮询篇) 配置 后台信息模式切换\n在上篇分析 Zookeeper 同步的文章 (ShenYu网关源码分析-11期) 中, 我们通过 DataSyncConfiguration 这个配置类做的切换, 这次有了经验, 直接贴配置\nsoul: sync: websocket: enabled: false http: enabled: true  网关信息模式切换\n后台模式切换完成, 接下来就是网关, 继续照葫芦画瓢找到关键配置类上的参数设置. 这里也直接贴网关配置\nsoul: sync: #\twebsocket: #\turls: ws://localhost:9095/websocket http: url: http://localhost:9095  DataChangedListener 体系 后台数据初始化 DataSyncConfiguration 配置关键 Bean , 看看这里关于 Http 长轮询的 Bean\n@Configuration public class DataSyncConfiguration { @Configuration @ConditionalOnProperty(name = \u0026amp;quot;soul.sync.http.enabled\u0026amp;quot;, havingValue = \u0026amp;quot;true\u0026amp;quot;) @EnableConfigurationProperties(HttpSyncProperties.class) static class HttpLongPollingListener { @Bean @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class) public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) { return new HttpLongPollingDataChangedListener(httpSyncProperties); } } }  HttpLongPollingDataChangedListener 继承自 AbstractDataChangedListener, 他们都实现自接口 DataChangedListener.\nDataChangedListener 这个接口我们应该非常熟悉了, 它提供了众多不同数据类型变动的方法, 供 DataChangedEventDispatcher 调用, 这个类更是一个 \u0026amp;ldquo;老朋友\u0026amp;rdquo; 了, 作为一个中转站, 辛勤的处理数据同步的事件分类及分发\npublic class DataChangedEventDispatcher implements ApplicationListener\u0026amp;lt;DataChangedEvent\u0026amp;gt;, InitializingBean { // 持有 DataChangedListener 集合 private List\u0026amp;lt;DataChangedListener\u0026amp;gt; listeners; // 事件变动时, 通知 DataChangedListener 的不同事件类型的方法 public void onApplicationEvent(final DataChangedEvent event) { for (DataChangedListener listener : listeners) { switch (event.getGroupKey()) { case APP_AUTH: listener.onAppAuthChanged((List\u0026amp;lt;AppAuthData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case PLUGIN: listener.onPluginChanged((List\u0026amp;lt;PluginData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case RULE: listener.onRuleChanged((List\u0026amp;lt;RuleData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case SELECTOR: listener.onSelectorChanged((List\u0026amp;lt;SelectorData\u0026amp;gt;) event.getSource(), event.getEventType()); break; case META_DATA: listener.onMetaDataChanged((List\u0026amp;lt;MetaData\u0026amp;gt;) event.getSource(), event.getEventType()); break; default: throw new IllegalStateException(\u0026amp;quot;Unexpected value: \u0026amp;quot; + event.getGroupKey()); } } } }  public interface DataChangedListener { default void onAppAuthChanged(List\u0026amp;lt;AppAuthData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onPluginChanged(List\u0026amp;lt;PluginData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onSelectorChanged(List\u0026amp;lt;SelectorData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onMetaDataChanged(List\u0026amp;lt;MetaData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} default void onRuleChanged(List\u0026amp;lt;RuleData\u0026amp;gt; changed, DataEventTypeEnum eventType) {} }  这两个的作用了解了, 那 AbstractDataChangedListener 又做了什么事情? 举个 onPluginChanged() 的例子:\npublic abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean { protected static final ConcurrentMap\u0026amp;lt;String, …","date":1611532800,"description":"ShenYu网关学习Http长轮询解析","dir":"blog/shenyu_source_learning_08_httplongpolling_01/","fuzzywordcount":2800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"030677cf3a18ffff3d2a754e13aee3b0bf0946b8","permalink":"/zh/blog/shenyu_source_learning_08_httplongpolling_01/","publishdate":"2021-01-25T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/shenyu_source_learning_08_httplongpolling_01/","summary":"后台与网关数据同步 (Http长轮询篇) 配置 后台信息模式切换 在上篇分析 Zookeeper 同步的文章 (ShenYu网关源码分析-11期) 中, 我们通过 DataSyncConfiguration 这个配置类","tags":["ShenYu"],"title":"ShenYu网关学习Http长轮询解析01","type":"blog","url":"/zh/blog/shenyu_source_learning_08_httplongpolling_01/","wordcount":2738},{"author":"fanjinpeng,zhuming","categories":"ShenYu","content":"  Fanjinpeng\n 1.前情回顾 在第4篇中，我们分析了 HTTP 用户业务系统接入 ShenYu网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后，会通过 websocket 长连接，将soul-admin 接收到的接口信息同步给 ShenYu网关（即 soul-bootstrap），今天就来接着继续分析，数据是怎么同步到 soul-bootstrap 的。\n不清楚流程的可以出门左转看下第4篇文章 【Soul源码阅读】4.HTTP 用户接入 ShenYu调用 /soul-client/springmvc-register 接口逻辑分析\n2.soul-admin 与 soul-bootstrap 数据同步 这里为了验证数据同步流程，其实也没必要非得启动业务系统，完全可以只启动 soul-admin 和 soul-bootstrap 两个系统即可，可以在页面打开或关闭插件，看看这个流程是怎么实现的。\n数据同步策略官网链接 https://dromara.org/zh-cn/docs/soul/user-dataSync.html\n2.1 启动2个系统 都是按照项目默认启动的，无需修改任何配置文件。\n2.2 页面操作查找接口 这里把 divide 插件启动，F12，看下前台会调用 soul-admin 哪个接口。\n可以看到前台向后台发送了一个 PUT 请求：http://localhost:9095/plugin/5\n2.3 后台接口 在项目中搜索这个接口\n// PluginController.java @RestController @RequestMapping(\u0026amp;quot;/plugin\u0026amp;quot;) public class PluginController { ... /** * update plugin. * * @param id primary key. * @param pluginDTO plugin. * @return {@linkplain SoulAdminResult} */ @PutMapping(\u0026amp;quot;/{id}\u0026amp;quot;) public SoulAdminResult updatePlugin(@PathVariable(\u0026amp;quot;id\u0026amp;quot;) final String id, @RequestBody final PluginDTO pluginDTO) { Objects.requireNonNull(pluginDTO); pluginDTO.setId(id); final String result = pluginService.createOrUpdate(pluginDTO); if (StringUtils.isNoneBlank(result)) { return SoulAdminResult.error(result); } return SoulAdminResult.success(SoulResultMessage.UPDATE_SUCCESS); } ... }  进到实现类里\n// PluginServiceImpl.java /** * create or update plugin. * * @param pluginDTO {@linkplain PluginDTO} * @return rows */ @Override @Transactional(rollbackFor = Exception.class) public String createOrUpdate(final PluginDTO pluginDTO) { final String msg = checkData(pluginDTO); if (StringUtils.isNoneBlank(msg)) { return msg; } PluginDO pluginDO = PluginDO.buildPluginDO(pluginDTO); DataEventTypeEnum eventType = DataEventTypeEnum.CREATE; if (StringUtils.isBlank(pluginDTO.getId())) { pluginMapper.insertSelective(pluginDO); } else { eventType = DataEventTypeEnum.UPDATE; pluginMapper.updateSelective(pluginDO); } // publish change event. eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, eventType, Collections.singletonList(PluginTransfer.INSTANCE.mapToData(pluginDO)))); return StringUtils.EMPTY; }  这里可以看出来，前半部分都是在操作数据库，把相关信息持久化；后半部分是发布了一个事件。\n2.4 发布事件 这里发布的事件用 DataChangedEvent 封装了一层，再看里面有1个枚举，这里有很多种类型：\n/** * configuration group. * * @author huangxiaofeng */ public enum ConfigGroupEnum { APP_AUTH, PLUGIN, RULE, SELECTOR, META_DATA; ... }  看到这几种类型，如果对第4篇还有印象的话，可以看出当时发送事件的类型就是 SELECTOR 和 RULE，现在是 PLUGIN，虽然类型不同，但不影响我们继续分析后面的逻辑，我们继续。\n另外一个 eventType 也是枚举，这里有 DELETE、CREATE、UPDATE、REFRESH、MYSELF 5种类型，此时是 UPDATE。\n/** * The enum Data event type. * * @author xiaoyu */ public enum DataEventTypeEnum { /** * delete event. */ DELETE, /** * insert event. */ CREATE, /** * update event. */ UPDATE, /** * REFRESH data event type enum. */ REFRESH, /** * Myself data event type enum. */ MYSELF; ... }  2.5 监听事件 找到监听事件的代码：\n// DataChangedEventDispatcher.java @Component public class DataChangedEventDispatcher implements …","date":1611273600,"description":"ShenYu Gateway Learns WebSocket Data Synchronization Analysis","dir":"blog/shenyu_source_learning_10_websocket/","fuzzywordcount":3900,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b9dddc73ebfda7bc397d3fc56921994c67a36308","permalink":"/blog/shenyu_source_learning_10_websocket/","publishdate":"2021-01-22T00:00:00Z","readingtime":8,"relpermalink":"/blog/shenyu_source_learning_10_websocket/","summary":"Fanjinpeng 1.前情回顾 在第4篇中，我们分析了 HTTP 用户业务系统接入 ShenYu网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后","tags":["ShenYu"],"title":"ShenYu Gateway Learns WebSocket Data Synchronization Analysis","type":"blog","url":"/blog/shenyu_source_learning_10_websocket/","wordcount":3874},{"author":"范金鹏,朱明","categories":"ShenYu","content":"  范金鹏\n 1.前情回顾 在第4篇中，我们分析了 HTTP 用户业务系统接入 ShenYu 网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后，会通过 websocket 长连接，将soul-admin 接收到的接口信息同步给 ShenYu 网关（即 soul-bootstrap），今天就来接着继续分析，数据是怎么同步到 soul-bootstrap 的。\n不清楚流程的可以出门左转看下第4篇文章 【Soul源码阅读】4.HTTP 用户接入 ShenYu 调用 /soul-client/springmvc-register 接口逻辑分析\n2.soul-admin 与 soul-bootstrap 数据同步 这里为了验证数据同步流程，其实也没必要非得启动业务系统，完全可以只启动 soul-admin 和 soul-bootstrap 两个系统即可，可以在页面打开或关闭插件，看看这个流程是怎么实现的。\n数据同步策略官网链接 https://dromara.org/zh-cn/docs/soul/user-dataSync.html\n2.1 启动2个系统 都是按照项目默认启动的，无需修改任何配置文件。\n2.2 页面操作查找接口 这里把 divide 插件启动，F12，看下前台会调用 soul-admin 哪个接口。\n可以看到前台向后台发送了一个 PUT 请求：http://localhost:9095/plugin/5\n2.3 后台接口 在项目中搜索这个接口\n// PluginController.java @RestController @RequestMapping(\u0026amp;quot;/plugin\u0026amp;quot;) public class PluginController { ... /** * update plugin. * * @param id primary key. * @param pluginDTO plugin. * @return {@linkplain SoulAdminResult} */ @PutMapping(\u0026amp;quot;/{id}\u0026amp;quot;) public SoulAdminResult updatePlugin(@PathVariable(\u0026amp;quot;id\u0026amp;quot;) final String id, @RequestBody final PluginDTO pluginDTO) { Objects.requireNonNull(pluginDTO); pluginDTO.setId(id); final String result = pluginService.createOrUpdate(pluginDTO); if (StringUtils.isNoneBlank(result)) { return SoulAdminResult.error(result); } return SoulAdminResult.success(SoulResultMessage.UPDATE_SUCCESS); } ... }  进到实现类里\n// PluginServiceImpl.java /** * create or update plugin. * * @param pluginDTO {@linkplain PluginDTO} * @return rows */ @Override @Transactional(rollbackFor = Exception.class) public String createOrUpdate(final PluginDTO pluginDTO) { final String msg = checkData(pluginDTO); if (StringUtils.isNoneBlank(msg)) { return msg; } PluginDO pluginDO = PluginDO.buildPluginDO(pluginDTO); DataEventTypeEnum eventType = DataEventTypeEnum.CREATE; if (StringUtils.isBlank(pluginDTO.getId())) { pluginMapper.insertSelective(pluginDO); } else { eventType = DataEventTypeEnum.UPDATE; pluginMapper.updateSelective(pluginDO); } // publish change event. eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, eventType, Collections.singletonList(PluginTransfer.INSTANCE.mapToData(pluginDO)))); return StringUtils.EMPTY; }  这里可以看出来，前半部分都是在操作数据库，把相关信息持久化；后半部分是发布了一个事件。\n2.4 发布事件 这里发布的事件用 DataChangedEvent 封装了一层，再看里面有1个枚举，这里有很多种类型：\n/** * configuration group. * * @author huangxiaofeng */ public enum ConfigGroupEnum { APP_AUTH, PLUGIN, RULE, SELECTOR, META_DATA; ... }  看到这几种类型，如果对第4篇还有印象的话，可以看出当时发送事件的类型就是 SELECTOR 和 RULE，现在是 PLUGIN，虽然类型不同，但不影响我们继续分析后面的逻辑，我们继续。\n另外一个 eventType 也是枚举，这里有 DELETE、CREATE、UPDATE、REFRESH、MYSELF 5种类型，此时是 UPDATE。\n/** * The enum Data event type. * * @author xiaoyu */ public enum DataEventTypeEnum { /** * delete event. */ DELETE, /** * insert event. */ CREATE, /** * update event. */ UPDATE, /** * REFRESH data event type enum. */ REFRESH, /** * Myself data event type enum. */ MYSELF; ... }  2.5 监听事件 找到监听事件的代码：\n// DataChangedEventDispatcher.java @Component public class DataChangedEventDispatcher implements …","date":1611273600,"description":"ShenYu网关学习WebSocket数据同步解析","dir":"blog/shenyu_source_learning_10_websocket/","fuzzywordcount":3900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"31e15933594521fa76d119d5d9c49c9f4f9991e9","permalink":"/zh/blog/shenyu_source_learning_10_websocket/","publishdate":"2021-01-22T00:00:00Z","readingtime":8,"relpermalink":"/zh/blog/shenyu_source_learning_10_websocket/","summary":"范金鹏 1.前情回顾 在第4篇中，我们分析了 HTTP 用户业务系统接入 ShenYu 网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后，会通","tags":["ShenYu"],"title":"ShenYu网关学习WebSocket数据同步解析","type":"blog","url":"/zh/blog/shenyu_source_learning_10_websocket/","wordcount":3862},{"author":"xiaoyu","categories":null,"content":" ShenYu source code reading (ShenYu 2021 first activity)  Date: Sunday, January 24, 2021 Time: 15:00 – 17:00 Location: Tencent Meeting  Activity Details 15:00-15:10 Opening introduction of dream code sharing process by kimming \u0026amp;amp; Cui\n15:10-15:25 data synchronization websocket by Ting\n15:25-15:50 Http Discovery Sharing by Zhu Ming\n15:50-16:10 Analysis based on the Sofa-Rpc protocol by Dongdong\n16:10-16:25 Metrics Monitoring by Ge Tianye\n16:25-16:40 Http Long Polling Sharing by Du Yuhang\n16:40-16:55 Sharing and introducing the overall architecture of data synchronization by Wentao Xia\n16:55-17:05 Microkernel Architecture Sharing by Shen Xiangjun\n17:05-17:20 Sharing the experience and insights of reading source code by JinZe\n17:20-17:30 Summary and Community Development Prospects by Xiaoyu\n","date":1611241200,"description":"","dir":"blog/apache-cloud-native-meet/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f6cb9d026e10a43448f10fade7b576d0f12b841c","permalink":"/blog/apache-cloud-native-meet/","publishdate":"2021-01-21T15:00:00Z","readingtime":1,"relpermalink":"/blog/apache-cloud-native-meet/","summary":"ShenYu source code reading (ShenYu 2021 first activity)  Date: Sunday, January 24, 2021 Time: 15:00 – 17:00 Location: Tencent Meeting  Activity Details 15:00-15:10 Opening introduction of dream code sharing process by kimming \u0026amp; Cui\n15:10-15:25 data synchronization websocket by Ting\n15:25-15:50 Http Discovery Sharing by Zhu Ming\n15:50-16:10 Analysis based on the Sofa-Rpc protocol by Dongdong\n16:10-16:25 Metrics Monitoring by Ge Tianye\n16:25-16:40 Http Long Polling Sharing by Du Yuhang","tags":["Apache","Reactor"],"title":"ShenYu source code 01 reading sharing session 01","type":"blog","url":"/blog/apache-cloud-native-meet/","wordcount":110},{"author":"xiaoyu","categories":null,"content":" ShenYu 源码阅读（Soul 2021 首次活动）  日期：2021年1月24日，星期日 时间：15:00 – 17:00 地点：线上腾讯会议室  活动详情 15:00 - 15:10 开场介绍梦码分享流程 by kimming \u0026amp;amp; 崔\n15:10 - 15:25 Soul 数据同步之websocket by 婷\n15:25 - 15:50 Http 探活分享 by 朱明\n15:50 - 16:10 基于Sofa-Rpc协议的分析 by 东东\n16:10 - 16:25 Metrics 监控 by 葛天野\n16:25 - 16:40 Http 长轮询分享 by 杜宇航\n16:40 - 16:55 数据同步整体架构分享与介绍 by 夏文涛\n16:55 - 17:05 微内核架构分享 by 沈祥俊\n17:05 - 17:20 分享读源码的心得与感悟 by 金泽\n17:20 - 17:30 Soul 作者 猫大人 总结与 社区发展 展望 by 猫大人\n","date":1611241200,"description":"","dir":"blog/apache-cloud-native-meet/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"15efaf7429f5d6efe31ee7d217fa1fd9321ebd9a","permalink":"/zh/blog/apache-cloud-native-meet/","publishdate":"2021-01-21T15:00:00Z","readingtime":1,"relpermalink":"/zh/blog/apache-cloud-native-meet/","summary":"ShenYu 源码阅读（Soul 2021 首次活动） 日期：2021年1月24日，星期日 时间：15:00 – 17:00 地点：线上腾讯会议室 活动详情 15:00 - 15:10 开场介绍梦码分享流程","tags":["ShenYu","Reactor"],"title":"ShenYu 源码01期阅读分享会01","type":"blog","url":"/zh/blog/apache-cloud-native-meet/","wordcount":222},{"author":"shenxiangjun","categories":"ShenYu","content":" 一、引言 插件是 ShenYu的灵魂。\nShenYu使用了插件化设计思想，实现了插件的热插拔，且极易扩展。内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。\nShenYu是如何实现插件化设计的呢？\n在探究插件化设计之前，我们需要先了解下微内核架构（又称插件化架构）。\n二、微内核架构 1、架构释义 微内核架构也被称为插件化架构，是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。\n应用逻辑被分割为独立的插件模块和核心系统，提供了可扩展性、灵活性、功能隔离和自定义处理逻辑的特性。\n微内核架构的本质，是将变化封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。\n2、设计关键点 核心系统设计的关键技术：\n 插件管理：当前有哪些插件可用？如何加载这些插件？什么时候加载插件？  常见的实现方法是插件注册表机制。\n 插件连接：插件如何连接到核心系统？  通常由核心系统制定连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n常见连接机制主要有：OSGi（Eclipse使用）、消息模式、依赖注入（Spring使用）。\n 插件通信：插件与插件、插件与核心系统如何通信？  通信必须经过核心系统，因此通常由核心系统提供插件通信机制。\n三、ShenYu的插件化设计 参照微内核架构来看，ShenYu的 soul-web 模块相当于核心系统，soul-plugin 下的子模块相当于插件模块。\n插件管理方面：\nsoul-bootstrap 模块的 pom 文件充当插件列表， 以硬编码的方式引入各插件。\n在容器启动阶段，借助 springboot 的 starter 机制自动扫描并注册插件 bean 到 Spring 容器。\n插件连接方面：\n借助 springboot 支持的多实例自动注入能力（ObjectProvider plugins），将插件 Bean 列表注入到网关的插件链，实现插件与网关的连接。\n插件通信方面：\n先在插件链初始化阶段完成插件排序，然后在插件处理时，借助贯穿整个插件链的 ServerWebExchange 完成向下游插件的定向传参，即某种意义上的插件通信机制。\n四、ShenYu的插件化实现 ShenYu网关中定义了一条插件链，所有的插件都在这条链上依次处理。\n在探究插件链之前，我们先来看看插件实现。\n1、插件实现 ShenYu中所有插件最终均继承自 SoulPlugin，其完整继承关系如下所示：\n可以看到，ShenYu的插件生态极其丰富，正是如此丰富的插件支撑起了 ShenYu网关强大的扩展能力。\n我们以常用的 DividePlugin 为例，分析插件内部所做工作。\nDividePlugin 继承结构：\nDividePlugin 继承自 AbstractSoulPlugin，最终实现了 SoulPlugin 接口。\n1）先关注 SoulPlugin，该插件接口结构如下：\n execute 方法：处理方法，需要传入 exchange交换区 和 SoulPluginChain插件链 getOrder 方法：取得序号，用作插件排序 named 方法：获得插件名 skip 方法：判断是否跳过本次处理  每次处理时，将先进行 skip 判断，不跳过则执行 excute 处理方法。\n2）再来看下 AbstractSoulPlugin，该抽象类结构如下：\n重点关注 execute 方法，其核心代码如下：\nif (pluginData.getEnable()){ // 获取插件数据 final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); // 获取选择器数据 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); final SelectorData selectorData = matchSelector(exchange, selectors); // 获取规则 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { //get last rule = rules.get(rules.size() - 1); } else { rule = matchRule(exchange, rules); } // 执行具体处理 return doExecute(exchange, chain, selectorData, rule); } // 继续执行后续插件处理 return chain.execute(exchange);  获取选择器数据和规则，然后传入 doExecute 方法进行具体处理，doExecute 方法为抽象方法，交由子类具体实现。\n3）查看插件子类 DividePlugin，其结构如下：\n重点关注 doExecute 方法，以下是核心代码：\n// 获取网关上下文和规则处理器 final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT); final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class); // 获取上游列表 final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId()); // 选择待分发的目标上游 final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress(); DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); // 设置 http url String domain = buildDomain(divideUpstream); String realURL = buildRealURL(domain, soulContext, exchange); …","date":1611187200,"description":"ShenYu Gateway Learning Plugin Chain Implementation","dir":"blog/shenyu_source_learning_15_plugin_chain/","fuzzywordcount":2500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"06e0cac2e11aece18f478d8025e833cb886b3520","permalink":"/blog/shenyu_source_learning_15_plugin_chain/","publishdate":"2021-01-21T00:00:00Z","readingtime":5,"relpermalink":"/blog/shenyu_source_learning_15_plugin_chain/","summary":"一、引言 插件是 ShenYu的灵魂。 ShenYu使用了插件化设计思想，实现了插件的热插拔，且极易扩展。内置丰富的插件支持，鉴权，限流，熔断，防","tags":["ShenYu"],"title":"ShenYu Gateway Learning Plugin Chain Implementation","type":"blog","url":"/blog/shenyu_source_learning_15_plugin_chain/","wordcount":2465},{"author":"liquan","categories":"ShenYu","content":" 启动admin，与网关。 admin操作，使用zookeeper同步数据到网关 上一篇，通过soul-admin启动过程为入口，分析了soul-admin 启动就会同步网关数据 rule、metaData、selector、plugin 等到 zookeeper。\n数据变化会发布 DataChangedEvent事件，监听事件将数据同步至zookeeper。 本篇接着上一篇继续跟踪源码分析zookeeper同步数据到网关原理：\n soul-admin 变更网关数据，跟踪数据同步过程。 soul-bootstrap 如何获取zookeeper数据的，如何感知网关数据变化的。  一、soul-admin 变更网关数据，跟踪数据同步过程 1、在网关后台尝试更改divide插件状态，debug跟踪。\n2、插件更新后会发布一个DataChangedEvent事件\n3、org.dromara.soul.admin.listener.DataChangedEventDispatcher \u0026amp;ndash;\u0026amp;gt; onApplicationEvent() 负责监听事件\n4、org.dromara.soul.admin.listener.zookeeper.ZookeeperDataChangedListener 负责同步数据至zookeeper\n二、soul-bootstrap 如何获取zookeeper数据的，如何感知网关数据变化的。 1、soul-bootstrap 依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2、soul-bootstrap 启动后会自动注入org.dromara.soul.spring.boot.sync.data.zookeeper.ZookeeperSyncDataConfiguration\n读取Zookeeper配置向容器中注入ZkClient。\nSyncDataService 向容器注入数据同步服务bean，从Spring容器中获取，ZkClient（zookeeper客户端）， pluginSubscriber（插件数据订阅）、metaSubscribers （元数据订阅）、authSubscribers（权限订阅）。\npublic class ZookeeperSyncDataConfiguration { /** * Sync data service sync data service. * @param zkClient the zk client * @param pluginSubscriber the plugin subscriber * @param metaSubscribers the meta subscribers * @param authSubscribers the auth subscribers * @return the sync data service */ @Bean public SyncDataService syncDataService(final ObjectProvider\u0026amp;lt;ZkClient\u0026amp;gt; zkClient, final ObjectProvider\u0026amp;lt;PluginDataSubscriber\u0026amp;gt; pluginSubscriber, final ObjectProvider\u0026amp;lt;List\u0026amp;lt;MetaDataSubscriber\u0026amp;gt;\u0026amp;gt; metaSubscribers, final ObjectProvider\u0026amp;lt;List\u0026amp;lt;AuthDataSubscriber\u0026amp;gt;\u0026amp;gt; authSubscribers) { log.info(\u0026amp;quot;you use zookeeper sync ShenYu data.......\u0026amp;quot;); return new ZookeeperSyncDataService(zkClient.getIfAvailable(), pluginSubscriber.getIfAvailable(), metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList)); } /** * register zkClient in spring ioc. * @param zookeeperConfig the zookeeper configuration * @return ZkClient {@linkplain ZkClient} */ @Bean public ZkClient zkClient(final ZookeeperConfig zookeeperConfig) { return new ZkClient(zookeeperConfig.getUrl(), zookeeperConfig.getSessionTimeout(), zookeeperConfig.getConnectionTimeout()); } }  3、org.dromara.soul.sync.data.zookeeper.ZookeeperSyncDataService 初始化，也就是soul-bootstrap启动后就会从zookeeper获取数据，同步至内存。 * watcherData()\u0026amp;ndash;\u0026amp;gt; watcherAll() \u0026amp;ndash;\u0026amp;gt; watcherPlugin() \u0026amp;ndash;\u0026amp;gt; cachePluginData()。 * zkClient.subscribeDataChanges() 监听 当前节点和子节点的内容修改、删除。\npublic class ZookeeperSyncDataService implements SyncDataService, AutoCloseable { private final ZkClient zkClient; private final PluginDataSubscriber pluginDataSubscriber; private final List\u0026amp;lt;MetaDataSubscriber\u0026amp;gt; metaDataSubscribers; private final List\u0026amp;lt;AuthDataSubscriber\u0026amp;gt; authDataSubscribers; /** * Instantiates a new Zookeeper cache manager. * @param zkClient …","date":1611187200,"description":"ShenYu Gateway Learns Zookeeper Data Synchronization","dir":"blog/shenyu_source_learning_13_zookeeper_02/","fuzzywordcount":1700,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3d5338cb1017e3f07ee38a85f4dfea0015026d20","permalink":"/blog/shenyu_source_learning_13_zookeeper_02/","publishdate":"2021-01-21T00:00:00Z","readingtime":4,"relpermalink":"/blog/shenyu_source_learning_13_zookeeper_02/","summary":"启动admin，与网关。 admin操作，使用zookeeper同步数据到网关 上一篇，通过soul-admin启动过程为入口，分析了soul-","tags":["ShenYu"],"title":"ShenYu Gateway Learns Zookeeper Data Synchronization 02","type":"blog","url":"/blog/shenyu_source_learning_13_zookeeper_02/","wordcount":1620},{"author":"李权","categories":"ShenYu","content":" 启动admin，与网关。 admin操作，使用zookeeper同步数据到网关 上一篇，通过soul-admin启动过程为入口，分析了soul-admin 启动就会同步网关数据 rule、metaData、selector、plugin 等到 zookeeper。\n数据变化会发布 DataChangedEvent事件，监听事件将数据同步至zookeeper。 本篇接着上一篇继续跟踪源码分析zookeeper同步数据到网关原理：\n soul-admin 变更网关数据，跟踪数据同步过程。 soul-bootstrap 如何获取zookeeper数据的，如何感知网关数据变化的。  一、soul-admin 变更网关数据，跟踪数据同步过程 1、在网关后台尝试更改divide插件状态，debug跟踪。\n2、插件更新后会发布一个DataChangedEvent事件\n3、org.dromara.soul.admin.listener.DataChangedEventDispatcher \u0026amp;ndash;\u0026amp;gt; onApplicationEvent() 负责监听事件\n4、org.dromara.soul.admin.listener.zookeeper.ZookeeperDataChangedListener 负责同步数据至zookeeper\n二、soul-bootstrap 如何获取zookeeper数据的，如何感知网关数据变化的。 1、soul-bootstrap 依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2、soul-bootstrap 启动后会自动注入org.dromara.soul.spring.boot.sync.data.zookeeper.ZookeeperSyncDataConfiguration\n读取Zookeeper配置向容器中注入ZkClient。\nSyncDataService 向容器注入数据同步服务bean，从Spring容器中获取，ZkClient（zookeeper客户端）， pluginSubscriber（插件数据订阅）、metaSubscribers （元数据订阅）、authSubscribers（权限订阅）。\npublic class ZookeeperSyncDataConfiguration { /** * Sync data service sync data service. * @param zkClient the zk client * @param pluginSubscriber the plugin subscriber * @param metaSubscribers the meta subscribers * @param authSubscribers the auth subscribers * @return the sync data service */ @Bean public SyncDataService syncDataService(final ObjectProvider\u0026amp;lt;ZkClient\u0026amp;gt; zkClient, final ObjectProvider\u0026amp;lt;PluginDataSubscriber\u0026amp;gt; pluginSubscriber, final ObjectProvider\u0026amp;lt;List\u0026amp;lt;MetaDataSubscriber\u0026amp;gt;\u0026amp;gt; metaSubscribers, final ObjectProvider\u0026amp;lt;List\u0026amp;lt;AuthDataSubscriber\u0026amp;gt;\u0026amp;gt; authSubscribers) { log.info(\u0026amp;quot;you use zookeeper sync soul data.......\u0026amp;quot;); return new ZookeeperSyncDataService(zkClient.getIfAvailable(), pluginSubscriber.getIfAvailable(), metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList)); } /** * register zkClient in spring ioc. * @param zookeeperConfig the zookeeper configuration * @return ZkClient {@linkplain ZkClient} */ @Bean public ZkClient zkClient(final ZookeeperConfig zookeeperConfig) { return new ZkClient(zookeeperConfig.getUrl(), zookeeperConfig.getSessionTimeout(), zookeeperConfig.getConnectionTimeout()); } }  3、org.dromara.soul.sync.data.zookeeper.ZookeeperSyncDataService 初始化，也就是soul-bootstrap启动后就会从zookeeper获取数据，同步至内存。 * watcherData()\u0026amp;ndash;\u0026amp;gt; watcherAll() \u0026amp;ndash;\u0026amp;gt; watcherPlugin() \u0026amp;ndash;\u0026amp;gt; cachePluginData()。 * zkClient.subscribeDataChanges() 监听 当前节点和子节点的内容修改、删除。\npublic class ZookeeperSyncDataService implements SyncDataService, AutoCloseable { private final ZkClient zkClient; private final PluginDataSubscriber pluginDataSubscriber; private final List\u0026amp;lt;MetaDataSubscriber\u0026amp;gt; metaDataSubscribers; private final List\u0026amp;lt;AuthDataSubscriber\u0026amp;gt; authDataSubscribers; /** * Instantiates a new Zookeeper cache manager. * @param zkClient the …","date":1611187200,"description":"ShenYu网关学习Zookeeper数据同步","dir":"blog/shenyu_source_learning_13_zookeeper_02/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"59dfaa75b84ebf31db4dc135b12f1f2f8a126b95","permalink":"/zh/blog/shenyu_source_learning_13_zookeeper_02/","publishdate":"2021-01-21T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/shenyu_source_learning_13_zookeeper_02/","summary":"启动admin，与网关。 admin操作，使用zookeeper同步数据到网关 上一篇，通过soul-admin启动过程为入口，分析了soul-","tags":["ShenYu"],"title":"ShenYu网关学习Zookeeper数据同步02","type":"blog","url":"/zh/blog/shenyu_source_learning_13_zookeeper_02/","wordcount":1620},{"author":"沈祥俊","categories":"ShenYu","content":" 一、引言 插件是 ShenYu 的灵魂。\nShenYu 使用了插件化设计思想，实现了插件的热插拔，且极易扩展。内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。\nShenYu 是如何实现插件化设计的呢？\n在探究插件化设计之前，我们需要先了解下微内核架构（又称插件化架构）。\n二、微内核架构 1、架构释义 微内核架构也被称为插件化架构，是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。\n应用逻辑被分割为独立的插件模块和核心系统，提供了可扩展性、灵活性、功能隔离和自定义处理逻辑的特性。\n微内核架构的本质，是将变化封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。\n2、设计关键点 核心系统设计的关键技术：\n 插件管理：当前有哪些插件可用？如何加载这些插件？什么时候加载插件？  常见的实现方法是插件注册表机制。\n 插件连接：插件如何连接到核心系统？  通常由核心系统制定连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n常见连接机制主要有：OSGi（Eclipse使用）、消息模式、依赖注入（Spring使用）。\n 插件通信：插件与插件、插件与核心系统如何通信？  通信必须经过核心系统，因此通常由核心系统提供插件通信机制。\n三、ShenYu 的插件化设计 参照微内核架构来看，ShenYu 的 soul-web 模块相当于核心系统，soul-plugin 下的子模块相当于插件模块。\n插件管理方面：\nsoul-bootstrap 模块的 pom 文件充当插件列表， 以硬编码的方式引入各插件。\n在容器启动阶段，借助 springboot 的 starter 机制自动扫描并注册插件 bean 到 Spring 容器。\n插件连接方面：\n借助 springboot 支持的多实例自动注入能力（ObjectProvider plugins），将插件 Bean 列表注入到网关的插件链，实现插件与网关的连接。\n插件通信方面：\n先在插件链初始化阶段完成插件排序，然后在插件处理时，借助贯穿整个插件链的 ServerWebExchange 完成向下游插件的定向传参，即某种意义上的插件通信机制。\n四、ShenYu 的插件化实现 ShenYu 网关中定义了一条插件链，所有的插件都在这条链上依次处理。\n在探究插件链之前，我们先来看看插件实现。\n1、插件实现 ShenYu 中所有插件最终均继承自 SoulPlugin，其完整继承关系如下所示：\n可以看到，ShenYu 的插件生态极其丰富，正是如此丰富的插件支撑起了 ShenYu 网关强大的扩展能力。\n我们以常用的 DividePlugin 为例，分析插件内部所做工作。\nDividePlugin 继承结构：\nDividePlugin 继承自 AbstractSoulPlugin，最终实现了 SoulPlugin 接口。\n1）先关注 SoulPlugin，该插件接口结构如下：\n execute 方法：处理方法，需要传入 exchange交换区 和 SoulPluginChain插件链 getOrder 方法：取得序号，用作插件排序 named 方法：获得插件名 skip 方法：判断是否跳过本次处理  每次处理时，将先进行 skip 判断，不跳过则执行 excute 处理方法。\n2）再来看下 AbstractSoulPlugin，该抽象类结构如下：\n重点关注 execute 方法，其核心代码如下：\nif (pluginData.getEnable()){ // 获取插件数据 final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); // 获取选择器数据 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); final SelectorData selectorData = matchSelector(exchange, selectors); // 获取规则 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { //get last rule = rules.get(rules.size() - 1); } else { rule = matchRule(exchange, rules); } // 执行具体处理 return doExecute(exchange, chain, selectorData, rule); } // 继续执行后续插件处理 return chain.execute(exchange);  获取选择器数据和规则，然后传入 doExecute 方法进行具体处理，doExecute 方法为抽象方法，交由子类具体实现。\n3）查看插件子类 DividePlugin，其结构如下：\n重点关注 doExecute 方法，以下是核心代码：\n// 获取网关上下文和规则处理器 final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT); final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class); // 获取上游列表 final List\u0026amp;lt;DivideUpstream\u0026amp;gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId()); // 选择待分发的目标上游 final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress(); DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip); // 设置 http url String domain = buildDomain(divideUpstream); String realURL = buildRealURL(domain, soulContext, exchange); …","date":1611187200,"description":"ShenYu网关学习插件链实现","dir":"blog/shenyu_source_learning_15_plugin_chain/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"8837b660b7813579b3d508d9b18f13308438874d","permalink":"/zh/blog/shenyu_source_learning_15_plugin_chain/","publishdate":"2021-01-21T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/shenyu_source_learning_15_plugin_chain/","summary":"一、引言 插件是 ShenYu 的灵魂。 ShenYu 使用了插件化设计思想，实现了插件的热插拔，且极易扩展。内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。 ShenYu 是如何实","tags":["ShenYu"],"title":"ShenYu网关学习插件链实现","type":"blog","url":"/zh/blog/shenyu_source_learning_15_plugin_chain/","wordcount":2420},{"author":"zenglinhui","categories":"ShenYu","content":" 源码分析  页面操作源码分析  在分析源码之前，先看下图，页面显示加载的插件列表会对应后端的请求，根据后端请求，找到对应的controller类 然后找到对应的方法，在上图可以看到这里是访问 plugin 中默认为空的 mapping，传入到分页相关的参数，然后去查询数据库中对应的插件记录 数据库中对应的表为下图所示，divide 状态是启用，在上一篇中，就是用这个插件来测试网关 同时请求的还有选择器，请求的 controller 见下图。在上篇的演示中，我们直接在页面把选择器中的条件 CRUD，可以实时反应到网关中去，而不需要重启网关，所以这里除了query方法中，增加、删除、和修改方法中,在保存到数据库之后都有一个 publishEvent 方法。就是这个事件方法，可以让用户直接在 ShenYu 后台配置规则，从而达到时时生效的目地 public int createOrUpdate(final SelectorDTO selectorDTO) { int selectorCount; SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO); List\u0026amp;lt;SelectorConditionDTO\u0026amp;gt; selectorConditionDTOs = selectorDTO.getSelectorConditions(); if (StringUtils.isEmpty(selectorDTO.getId())) { selectorCount = selectorMapper.insertSelective(selectorDO); selectorConditionDTOs.forEach(selectorConditionDTO -\u0026amp;gt; { selectorConditionDTO.setSelectorId(selectorDO.getId()); selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO)); }); } else { selectorCount = selectorMapper.updateSelective(selectorDO); //delete rule condition then add selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId())); selectorConditionDTOs.forEach(selectorConditionDTO -\u0026amp;gt; { selectorConditionDTO.setSelectorId(selectorDO.getId()); SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO); selectorConditionMapper.insertSelective(selectorConditionDO); }); } publishEvent(selectorDO, selectorConditionDTOs); return selectorCount; }   与ShenYu-bootstrap 数据同步(websocket)源码分析  之前介绍了 admin 页面操作之后把数据保存数据库，然后用了 spring 自带的响应式编程把数据同步到 bootstrap 项目，以达到动态刷新网关规则及插件，而不用添加配置后去重启网关。 当 ShenYu-bootstrap 启动时，看日志会打出来这么一段\n2021-01-21 00:33:39.620 INFO 14276 --- [0.0-9095-exec-5] o.d.s.a.l.websocket.WebsocketCollector : websocket on open successful....  那么问题来了，它用 websocket 和谁连接了，又是怎么连接的？下面通过找到打日志的代码，再通过打断点的方式来调试一下，这里是打日志出来的地方 先来分析一下这个代码： - 从 websocketConfig 这个配置里面拿到配的请求地址，这个配置文件当然是在下图的这个地方配的 - 拿到这个配置地址后，创建了一个定时的线程池，线程池大小为 urls.length，线程名称前缀为\u0026amp;rdquo;websocket-connect\u0026amp;rdquo;的守护线程。这里为什么要创建守护线程，因为这只是为了保证 bootstrap 和 admin 的 websocket 连接不断，类似于心跳的作用，所以用守护线程是最好的 - 根据创建的 client 端，一个一个的去请求配置文件配的地址，然后打印之前所找到的日志 - 后面就启动线程去判断 client 是否关闭，如果关闭就会去重新连接(初始间隔10秒，然后每30秒去执行一次检查，所以如果你看到控制台有时会打印多个连接成功的日志，说明重连了) - 我们再来看看在 admin 后台操作的数据是怎么同步到 bootstrap 中的呢，之前有说过，在后台保存或者更新数据之后，会调用 publishEvent 方法，这个是 spring 自带响应式编程的方法，既然是响应式，那就是基于事件的，那就得有 listener 一找果不其然，上图画红框的地方是不是很眼熟，没错，监听器，和websocket相关的监听器，如果还是有点看不明白监听和之前的 publishEvent 有什么关系，那就把监听器里的代码打上断点，调试一把。我这里为了方便，就点了这个同步所有数据 这里进的是 DataChangedEventDispatcher 这个类，调用了event 相关的方法，在左下角这个地方，是不是看到了熟悉了方法了，没错就是上面说的 publishEvent  然后会跳转到 WebsocketDataChangedListener 这个类中，这里重点看一下在调试方法中 send 方法  这里通过 send 方法把更新的数据发到 bootstrap 中，到此 admin 怎么同步数据到 bootstrap 中就真相大白了  与shenyu-bootstrap 数据同步(zookeeper)源码分析 话不多说，先上图，把 websocket 的配置先注释掉，打开 zookeeper 的配置，前提是把本地或者远程的 zookeeper 服务打开，然后启动 soul-admin 首先进入了 ZookeeperDataInit 类的 run 方法，这个方法执行完之后，奇怪的一点是跳到了 WebsocketDataChangedListener 类中去了 这一点没弄明白，等这个类里面的 onPluginChanged 方法执行完了之后， …","date":1611100800,"description":"ShenYu Gateway Learning Admin Source Code Analysis","dir":"blog/shenyu_resource_learning_07_admin/","fuzzywordcount":2300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"913c28f7c79985cbe0023b4e0a77c1e9c851562e","permalink":"/blog/shenyu_resource_learning_07_admin/","publishdate":"2021-01-20T00:00:00Z","readingtime":5,"relpermalink":"/blog/shenyu_resource_learning_07_admin/","summary":"源码分析 页面操作源码分析 在分析源码之前，先看下图，页面显示加载的插件列表会对应后端的请求，根据后端请求，找到对应的controller类 然后","tags":["ShenYu"],"title":"ShenYu Gateway Learning Admin Source Code Analysis","type":"blog","url":"/blog/shenyu_resource_learning_07_admin/","wordcount":2270},{"author":"liquan","categories":"ShenYu","content":" 启动 soul-admin、soul-bootstrap， 使用zookeeper同步数据到网关 一、配置环境 1、soul-admin 服务配置，需要重启服务\nsoul-admin/src/main/resources/application.yml\nsoul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  2、soul-bootstrap 网关服务配置，需要重启\nsoul-bootstrap/pom.xml\n\u0026amp;lt;!--ShenYu data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  soul-bootstrap/src/main/resources/application-local.yml\nShenYu : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  二、启动服务 1、 启动 zookeeper\nzookeeper ./bin/zkServer.sh start /usr/bin/java ZooKeeper JMX enabled by default Using config: /Documents/soft/zookeeper/bin/../conf/zoo.cfg Starting zookeeper ... STARTED  2、soul-admin 网关后台服务启动，服务启动后可以看到发起的ZooKeeper请求调用\n 2021-01-20 17:34:48.752 INFO 64500 --- [-localhost:2181] org.I0Itec.zkclient.ZkEventThread : Starting ZkClient event thread. 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:zookeeper.version=3.5.6-c11b7e26bc554b8523dc929761dd28808913f091, built on 10/08/2019 20:18 GMT 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:host.name=10.7.254.31 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:java.version=1.8.0_261 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:java.vendor=Oracle Corporation ...... 2021-01-20 17:34:48.806 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error) 2021-01-20 17:34:48.826 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Socket connection established, initiating session, client: /0:0:0:0:0:0:0:1:58214, server: localhost/0:0:0:0:0:0:0:1:2181 2021-01-20 17:34:48.857 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x1000b5e22f50001, negotiated timeout = 5000 2021-01-20 17:34:48.861 INFO 64500 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient : zookeeper state changed (SyncConnected)  3、soul-bootstrap 网关服务启动，服务启动后可以看到发起的ZooKeeper请求调用\n2021-01-20 17:35:58.996 INFO 64583 --- [ main] s.b.s.d.z.ZookeeperSyncDataConfiguration : you use zookeeper sync ShenYu data....... 2021-01-20 17:35:59.003 INFO 64583 --- [-localhost:2181] org.I0Itec.zkclient.ZkEventThread : Starting ZkClient event thread. ...... 2021-01-20 17:35:59.012 INFO 64583 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:user.home=/Users/liquan 2021-01-20 17:35:59.012 INFO 64583 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:os.memory.total=310MB 2021-01-20 17:35:59.018 …","date":1611100800,"description":"ShenYu Gateway Learns Zookeeper Data Synchronization","dir":"blog/shenyu_source_learning_13_zookeeper_01/","fuzzywordcount":2200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7b35f27382461fe4ad5885cf07fb4cf686ebb0bf","permalink":"/blog/shenyu_source_learning_13_zookeeper_01/","publishdate":"2021-01-20T00:00:00Z","readingtime":5,"relpermalink":"/blog/shenyu_source_learning_13_zookeeper_01/","summary":"启动 soul-admin、soul-bootstrap， 使用zookeeper同步数据到网关 一、配置环境 1、soul-admin 服务配置，需","tags":["ShenYu"],"title":"ShenYu Gateway Learns Zookeeper Data Synchronization 01","type":"blog","url":"/blog/shenyu_source_learning_13_zookeeper_01/","wordcount":2183},{"author":"曾林辉","categories":"ShenYu","content":" 源码分析  页面操作源码分析  在分析源码之前，先看下图，页面显示加载的插件列表会对应后端的请求，根据后端请求，找到对应的controller类 然后找到对应的方法，在上图可以看到这里是访问 plugin 中默认为空的 mapping，传入到分页相关的参数，然后去查询数据库中对应的插件记录 数据库中对应的表为下图所示，divide 状态是启用，在上一篇中，就是用这个插件来测试网关 同时请求的还有选择器，请求的 controller 见下图。在上篇的演示中，我们直接在页面把选择器中的条件 CRUD，可以实时反应到网关中去，而不需要重启网关，所以这里除了query方法中，增加、删除、和修改方法中,在保存到数据库之后都有一个 publishEvent 方法。就是这个事件方法，可以让用户直接在 soul 后台配置规则，从而达到时时生效的目地 public int createOrUpdate(final SelectorDTO selectorDTO) { int selectorCount; SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO); List\u0026amp;lt;SelectorConditionDTO\u0026amp;gt; selectorConditionDTOs = selectorDTO.getSelectorConditions(); if (StringUtils.isEmpty(selectorDTO.getId())) { selectorCount = selectorMapper.insertSelective(selectorDO); selectorConditionDTOs.forEach(selectorConditionDTO -\u0026amp;gt; { selectorConditionDTO.setSelectorId(selectorDO.getId()); selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO)); }); } else { selectorCount = selectorMapper.updateSelective(selectorDO); //delete rule condition then add selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId())); selectorConditionDTOs.forEach(selectorConditionDTO -\u0026amp;gt; { selectorConditionDTO.setSelectorId(selectorDO.getId()); SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO); selectorConditionMapper.insertSelective(selectorConditionDO); }); } publishEvent(selectorDO, selectorConditionDTOs); return selectorCount; }   与soul-bootstrap 数据同步(websocket)源码分析  之前介绍了 admin 页面操作之后把数据保存数据库，然后用了 spring 自带的响应式编程把数据同步到 bootstrap 项目，以达到动态刷新网关规则及插件，而不用添加配置后去重启网关。 当 soul-bootstrap 启动时，看日志会打出来这么一段\n2021-01-21 00:33:39.620 INFO 14276 --- [0.0-9095-exec-5] o.d.s.a.l.websocket.WebsocketCollector : websocket on open successful....  那么问题来了，它用 websocket 和谁连接了，又是怎么连接的？下面通过找到打日志的代码，再通过打断点的方式来调试一下，这里是打日志出来的地方 先来分析一下这个代码： - 从 websocketConfig 这个配置里面拿到配的请求地址，这个配置文件当然是在下图的这个地方配的 - 拿到这个配置地址后，创建了一个定时的线程池，线程池大小为 urls.length，线程名称前缀为\u0026amp;rdquo;websocket-connect\u0026amp;rdquo;的守护线程。这里为什么要创建守护线程，因为这只是为了保证 bootstrap 和 admin 的 websocket 连接不断，类似于心跳的作用，所以用守护线程是最好的 - 根据创建的 client 端，一个一个的去请求配置文件配的地址，然后打印之前所找到的日志 - 后面就启动线程去判断 client 是否关闭，如果关闭就会去重新连接(初始间隔10秒，然后每30秒去执行一次检查，所以如果你看到控制台有时会打印多个连接成功的日志，说明重连了) - 我们再来看看在 admin 后台操作的数据是怎么同步到 bootstrap 中的呢，之前有说过，在后台保存或者更新数据之后，会调用 publishEvent 方法，这个是 spring 自带响应式编程的方法，既然是响应式，那就是基于事件的，那就得有 listener 一找果不其然，上图画红框的地方是不是很眼熟，没错，监听器，和websocket相关的监听器，如果还是有点看不明白监听和之前的 publishEvent 有什么关系，那就把监听器里的代码打上断点，调试一把。我这里为了方便，就点了这个同步所有数据 这里进的是 DataChangedEventDispatcher 这个类，调用了event 相关的方法，在左下角这个地方，是不是看到了熟悉了方法了，没错就是上面说的 publishEvent  然后会跳转到 WebsocketDataChangedListener 这个类中，这里重点看一下在调试方法中 send 方法  这里通过 send 方法把更新的数据发到 bootstrap 中，到此 admin 怎么同步数据到 bootstrap 中就真相大白了  与soul-bootstrap 数据同步(zookeeper)源码分析 话不多说，先上图，把 websocket 的配置先注释掉，打开 zookeeper 的配置，前提是把本地或者远程的 zookeeper 服务打开，然后启动 soul-admin 首先进入了 ZookeeperDataInit 类的 run 方法，这个方法执行完之后，奇怪的一点是跳到了 WebsocketDataChangedListener 类中去了 这一点没弄明白，等这个类里面的 onPluginChanged 方法执行完了之后， …","date":1611100800,"description":"ShenYu网关学习Admin源码分析","dir":"blog/shenyu_resource_learning_07_admin/","fuzzywordcount":2300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"a3963ae9eb94f643128a14ef47766a3adb55ab57","permalink":"/zh/blog/shenyu_resource_learning_07_admin/","publishdate":"2021-01-20T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/shenyu_resource_learning_07_admin/","summary":"源码分析 页面操作源码分析 在分析源码之前，先看下图，页面显示加载的插件列表会对应后端的请求，根据后端请求，找到对应的controller类 然后","tags":["ShenYu"],"title":"ShenYu网关学习Admin源码分析","type":"blog","url":"/zh/blog/shenyu_resource_learning_07_admin/","wordcount":2262},{"author":"李权","categories":"ShenYu","content":" 启动 soul-admin、soul-bootstrap， 使用zookeeper同步数据到网关 一、配置环境 1、soul-admin 服务配置，需要重启服务\nsoul-admin/src/main/resources/application.yml\nsoul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  2、soul-bootstrap 网关服务配置，需要重启\nsoul-bootstrap/pom.xml\n\u0026amp;lt;!--soul data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  soul-bootstrap/src/main/resources/application-local.yml\nsoul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  二、启动服务 1、 启动 zookeeper\nzookeeper ./bin/zkServer.sh start /usr/bin/java ZooKeeper JMX enabled by default Using config: /Documents/soft/zookeeper/bin/../conf/zoo.cfg Starting zookeeper ... STARTED  2、soul-admin 网关后台服务启动，服务启动后可以看到发起的ZooKeeper请求调用\n 2021-01-20 17:34:48.752 INFO 64500 --- [-localhost:2181] org.I0Itec.zkclient.ZkEventThread : Starting ZkClient event thread. 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:zookeeper.version=3.5.6-c11b7e26bc554b8523dc929761dd28808913f091, built on 10/08/2019 20:18 GMT 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:host.name=10.7.254.31 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:java.version=1.8.0_261 2021-01-20 17:34:48.761 INFO 64500 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:java.vendor=Oracle Corporation ...... 2021-01-20 17:34:48.806 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error) 2021-01-20 17:34:48.826 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Socket connection established, initiating session, client: /0:0:0:0:0:0:0:1:58214, server: localhost/0:0:0:0:0:0:0:1:2181 2021-01-20 17:34:48.857 INFO 64500 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn : Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x1000b5e22f50001, negotiated timeout = 5000 2021-01-20 17:34:48.861 INFO 64500 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient : zookeeper state changed (SyncConnected)  3、soul-bootstrap 网关服务启动，服务启动后可以看到发起的ZooKeeper请求调用\n2021-01-20 17:35:58.996 INFO 64583 --- [ main] s.b.s.d.z.ZookeeperSyncDataConfiguration : you use zookeeper sync soul data....... 2021-01-20 17:35:59.003 INFO 64583 --- [-localhost:2181] org.I0Itec.zkclient.ZkEventThread : Starting ZkClient event thread. ...... 2021-01-20 17:35:59.012 INFO 64583 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:user.home=/Users/liquan 2021-01-20 17:35:59.012 INFO 64583 --- [ main] org.apache.zookeeper.ZooKeeper : Client environment:os.memory.total=310MB 2021-01-20 17:35:59.018 INFO …","date":1611100800,"description":"ShenYu网关学习Zookeeper数据同步","dir":"blog/shenyu_source_learning_13_zookeeper_01/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bc77382c1ae49d55c3c09c67ec07a2d238207aed","permalink":"/zh/blog/shenyu_source_learning_13_zookeeper_01/","publishdate":"2021-01-20T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/shenyu_source_learning_13_zookeeper_01/","summary":"启动 soul-admin、soul-bootstrap， 使用zookeeper同步数据到网关 一、配置环境 1、soul-admin 服务配置，需","tags":["ShenYu"],"title":"ShenYu网关学习Zookeeper数据同步01","type":"blog","url":"/zh/blog/shenyu_source_learning_13_zookeeper_01/","wordcount":2185},{"author":"fanjinpeng","categories":"ShenYu","content":" HTTP 用户接入 ShenYu网关注册逻辑分析 1. 注册入口 HTTP 用户接入 ShenYu网关时，会调用 soul-admin 一个接口，把需要 ShenYu网关管理的接口注册，今天就具体看看到底干了点儿啥。\n先看下调用的接口信息如下：\n// SpringMvcClientBeanPostProcessor.java /** * Instantiates a new ShenYuclient bean post processor. * * @param soulSpringMvcConfig the ShenYu spring mvc config */ public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) { ValidateUtils.validate(soulSpringMvcConfig); this.soulSpringMvcConfig = soulSpringMvcConfig; url = soulSpringMvcConfig.getAdminUrl() + \u0026amp;quot;/soul-client/springmvc-register\u0026amp;quot;; executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;()); }  2. springmvc-register 接口逻辑 全局搜索 \u0026amp;ldquo;springmvc-register\u0026amp;rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~\n// SoulClientController.java /** * Register spring mvc string. * * @param springMvcRegisterDTO the spring mvc register dto * @return the string */ @PostMapping(\u0026amp;quot;/springmvc-register\u0026amp;quot;) public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) { return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO); }  Service 层实现类：\n// SoulClientRegisterServiceImpl.java @Override @Transactional public String registerSpringMvc(final SpringMvcRegisterDTO dto) { if (dto.isRegisterMetaData()) { MetaDataDO exist = metaDataMapper.findByPath(dto.getPath()); if (Objects.isNull(exist)) { saveSpringMvcMetaData(dto); } } String selectorId = handlerSpringMvcSelector(dto); handlerSpringMvcRule(selectorId, dto); return SoulResultMessage.SUCCESS; }  dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。\n2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。 // SoulClientRegisterServiceImpl.java private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) { String contextPath = dto.getContext(); // 根据 contextPath 到数据库里查询，是否已经注册过。 SelectorDO selectorDO = selectorService.findByName(contextPath); String selectorId; String uri = String.join(\u0026amp;quot;:\u0026amp;quot;, dto.getHost(), String.valueOf(dto.getPort())); if (Objects.isNull(selectorDO)) { // 还没有注册过 selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri); } else { // 已经注册过，业务系统重启了会到这里 selectorId = selectorDO.getId(); //update upstream String handle = selectorDO.getHandle(); String handleAdd; DivideUpstream addDivideUpstream = buildDivideUpstream(uri); SelectorData selectorData = selectorService.buildByName(contextPath); if (StringUtils.isBlank(handle)) { handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream)); } else { List\u0026amp;lt;DivideUpstream\u0026amp;gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class); for (DivideUpstream upstream : exist) { if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) { return selectorId; } } exist.add(addDivideUpstream); handleAdd = GsonUtils.getInstance().toJson(exist); } selectorDO.setHandle(handleAdd); selectorData.setHandle(handleAdd); // update db …","date":1610928000,"description":"ShenYuLearning (2) HTTP Client Access Source Code Parsing","dir":"blog/shenyu_source_learning_02_http_client_register/","fuzzywordcount":2600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"768b8084906e3129cd273a64d867fab87b1d4bc8","permalink":"/blog/shenyu_source_learning_02_http_client_register/","publishdate":"2021-01-18T00:00:00Z","readingtime":6,"relpermalink":"/blog/shenyu_source_learning_02_http_client_register/","summary":"HTTP 用户接入 ShenYu网关注册逻辑分析 1. 注册入口 HTTP 用户接入 ShenYu网关时，会调用 soul-admin 一个接口，把需要 ShenYu网关管理的接口注册，今天就","tags":["ShenYu"],"title":"ShenYu Gateway Learning (2) HTTP Client Access Source Code Parsing","type":"blog","url":"/blog/shenyu_source_learning_02_http_client_register/","wordcount":2588},{"author":"范金鹏","categories":"ShenYu","content":" HTTP 用户接入 ShenYu 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 ShenYu 网关时，会调用 soul-admin 一个接口，把需要 ShenYu 网关管理的接口注册，今天就具体看看到底干了点儿啥。\n先看下调用的接口信息如下：\n// SpringMvcClientBeanPostProcessor.java /** * Instantiates a new ShenYu client bean post processor. * * @param soulSpringMvcConfig the soul spring mvc config */ public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) { ValidateUtils.validate(soulSpringMvcConfig); this.soulSpringMvcConfig = soulSpringMvcConfig; url = soulSpringMvcConfig.getAdminUrl() + \u0026amp;quot;/soul-client/springmvc-register\u0026amp;quot;; executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;()); }  2. springmvc-register 接口逻辑 全局搜索 \u0026amp;ldquo;springmvc-register\u0026amp;rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~\n// SoulClientController.java /** * Register spring mvc string. * * @param springMvcRegisterDTO the spring mvc register dto * @return the string */ @PostMapping(\u0026amp;quot;/springmvc-register\u0026amp;quot;) public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) { return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO); }  Service 层实现类：\n// SoulClientRegisterServiceImpl.java @Override @Transactional public String registerSpringMvc(final SpringMvcRegisterDTO dto) { if (dto.isRegisterMetaData()) { MetaDataDO exist = metaDataMapper.findByPath(dto.getPath()); if (Objects.isNull(exist)) { saveSpringMvcMetaData(dto); } } String selectorId = handlerSpringMvcSelector(dto); handlerSpringMvcRule(selectorId, dto); return SoulResultMessage.SUCCESS; }  dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。\n2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。 // SoulClientRegisterServiceImpl.java private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) { String contextPath = dto.getContext(); // 根据 contextPath 到数据库里查询，是否已经注册过。 SelectorDO selectorDO = selectorService.findByName(contextPath); String selectorId; String uri = String.join(\u0026amp;quot;:\u0026amp;quot;, dto.getHost(), String.valueOf(dto.getPort())); if (Objects.isNull(selectorDO)) { // 还没有注册过 selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri); } else { // 已经注册过，业务系统重启了会到这里 selectorId = selectorDO.getId(); //update upstream String handle = selectorDO.getHandle(); String handleAdd; DivideUpstream addDivideUpstream = buildDivideUpstream(uri); SelectorData selectorData = selectorService.buildByName(contextPath); if (StringUtils.isBlank(handle)) { handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream)); } else { List\u0026amp;lt;DivideUpstream\u0026amp;gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class); for (DivideUpstream upstream : exist) { if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) { return selectorId; } } exist.add(addDivideUpstream); handleAdd = GsonUtils.getInstance().toJson(exist); } selectorDO.setHandle(handleAdd); selectorData.setHandle(handleAdd); // update …","date":1610928000,"description":"ShenYu网关学习(2-3)Http客户端接入源码解析","dir":"blog/shenyu_source_learning_02_http_client_register/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"05b8a53f6e1674513bdb34783a7bc992954c53ef","permalink":"/zh/blog/shenyu_source_learning_02_http_client_register/","publishdate":"2021-01-18T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/shenyu_source_learning_02_http_client_register/","summary":"HTTP 用户接入 ShenYu 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 ShenYu 网关时，会调用 soul-admin 一个接口，把需要 ShenYu 网关管理的接口注册，今天就具体看看到底干了点儿啥。 先看下","tags":["ShenYu"],"title":"ShenYu网关学习(2-3)Http客户端接入源码解析","type":"blog","url":"/zh/blog/shenyu_source_learning_02_http_client_register/","wordcount":2524},{"author":"jipeng","categories":"ShenYu","content":" Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？\n可以想象一下大概是这几个步骤：\n 1.解析url 2.查看配置文件，看这个url是对应于哪个业务线 3.读配置文件，获取该业务线在网关注册的所有api列表 4.判断该用户的这个api请求在不在业务的api列表里面 5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超） 6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略 7.网关向具体的业务API发起请求 8.网关将收到的业务API的response发送给用户  这篇笔记主要来学习一下suol网关是怎么转发http请求的。\n先看一下官方文档的相关介绍http用户、Divide插件\n官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：\n \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shengyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shengyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--if you use http proxy end this--\u0026amp;gt;  那么可以知道http请求的代理与plugin-divide,plugin-httpclient这两个插件有关。\n插件链 官方文档中说到divide这个插件是实现http请求代理的核心，下面看一下ShenYu-plugin/ShenYu-plugin-divide这个模块的代码，可以看到有一个DividePlugin类，继承自AbstractPlugin，而AbstractPlugin实现了ShenYuPlugin接口\n可以看到ShenYuPlugin是DividePlugin的父类，那么猜测一下ShenYuPlugin是所有插件的父类。全局搜索一下ShenYuPlugin果然如此，它是诸多插件的父类。\n在全局搜索ShenYuPlugin的时候，发现shenyu-web/src/main/java/org/dromara/shenyu/web/handler里有一个类ShenYuWebHandler里面有一个属性是List\u0026amp;lt;ShenYuPlugin\u0026amp;gt;，猜测ShenYuWebHandler可以操作多个插件。\n看一下ShenYuWebHandler的继承关系图，发现它是继承了WebHandler，而WebHandler是spring框架里面的一个接口。\n由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。\n而ShenYu网关的源码里面，自己实现了一个实现了WebHandler接口的ShenYuWebHandler类，无疑是希望框架使用ShenYu实现的这套东西来处理请求。\n在shenyu-web/src/main/java/org/dromara/shenyu/web/configuration里的ShenYuConfiguration类，它在类头上声明了注解@Configuration，表明它是一个配置。ShenYuConfiguration类里面向spring容器注入了一个名为webHandler的bean，该bean是ShenYuWebHandler类型的。Application会在启动的时候扫描被@Configuration注解的类，所以通过以下代码，ShenYuWebHandler就被注入到spring容器中去了。\n @Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public ShenyuWebHandler shenyuWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;ShenyuPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;ShenyuPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); List\u0026amp;lt;ShenyuPlugin\u0026amp;gt; shenyuPlugins = pluginList.stream() .sorted(Comparator.comparingInt(ShenyuPlugin::getOrder)).collect(Collectors.toList()); shenyuPlugins.forEach(shenyuPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, shenyuPlugin.named(), shenyuPlugin.getClass().getName())); return new ShenyuWebHandler(shenyuPlugins); }  初始化ShenYuWebHandler的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以DividePlugin为例，看下它的order属性是从一个枚举类里面来的。\n @Override public int getOrder() { return PluginEnum.DIVIDE.getCode(); }  而各个插件的order的具体值是在shenyu-common/src/main/java/org/dromara/shenyu/common/enums/PluginEnums这个枚举类里面定义的。PluginEnum的code即为各个插件的order。\n插件的顺序为：global -\u0026amp;gt; sign -\u0026amp;gt; waf -\u0026amp;gt; rate-limiter -\u0026amp;gt; hystrix -\u0026amp;gt; resilience4j -\u0026amp;gt; divide -\u0026amp;gt; webClient -\u0026amp;gt; …………\n每次有一个请求的时候，WebHandler即ShenYuWebHandler …","date":1610841600,"description":"How Does The Divide Plugin Forward HTTP Requests","dir":"blog/shenyu_source_larning_02_divide_plugin_source/","fuzzywordcount":3200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"dc0202526448d7a5fa8704caa4b4c279a1b6384d","permalink":"/blog/shenyu_source_larning_02_divide_plugin_source/","publishdate":"2021-01-17T00:00:00Z","readingtime":7,"relpermalink":"/blog/shenyu_source_larning_02_divide_plugin_source/","summary":"Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/fi","tags":["ShenYu"],"title":"ShenYuLearning(2) How Does The Divide Plugin Forward Http Requests","type":"blog","url":"/blog/shenyu_source_larning_02_divide_plugin_source/","wordcount":3108},{"author":"季鹏","categories":"ShenYu","content":" Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？\n可以想象一下大概是这几个步骤：\n 1.解析url 2.查看配置文件，看这个url是对应于哪个业务线 3.读配置文件，获取该业务线在网关注册的所有api列表 4.判断该用户的这个api请求在不在业务的api列表里面 5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超） 6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略 7.网关向具体的业务API发起请求 8.网关将收到的业务API的response发送给用户  这篇笔记主要来学习一下suol网关是怎么转发http请求的。\n先看一下官方文档的相关介绍http用户、Divide插件\n官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：\n \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--if you use http proxy end this--\u0026amp;gt;  那么可以知道http请求的代理与plugin-divide,plugin-httpclient这两个插件有关。\n插件链 官方文档中说到divide这个插件是实现http请求代理的核心，下面看一下soul-plugin/soul-plugin-divide这个模块的代码，可以看到有一个DividePlugin类，继承自AbstractPlugin，而AbstractPlugin实现了SoulPlugin接口\n可以看到SoulPlugin是DividePlugin的父类，那么猜测一下SoulPlugin是所有插件的父类。全局搜索一下SoulPlugin果然如此，它是诸多插件的父类。\n在全局搜索SoulPlugin的时候，发现soul-web/src/main/java/org/dromara/soul/web/handler里有一个类SoulWebHandler里面有一个属性是List\u0026amp;lt;SoulPlugin\u0026amp;gt;，猜测SoulWebHandler可以操作多个插件。\n看一下SoulWebHandler的继承关系图，发现它是继承了WebHandler，而WebHandler是spring框架里面的一个接口。\n由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。\n而soul网关的源码里面，自己实现了一个实现了WebHandler接口的SoulWebHandler类，无疑是希望框架使用soul实现的这套东西来处理请求。\n在soul-web/src/main/java/org/dromara/soul/web/configuration里的SoulConfiguration类，它在类头上声明了注解@Configuration，表明它是一个配置。SoulConfiguration类里面向spring容器注入了一个名为webHandler的bean，该bean是SoulWebHandler类型的。Application会在启动的时候扫描被@Configuration注解的类，所以通过以下代码，SoulWebHandler就被注入到spring容器中去了。\n @Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;SoulPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); final List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); soulPlugins.forEach(soulPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, soulPlugin.named(), soulPlugin.getClass().getName())); return new SoulWebHandler(soulPlugins); }  初始化SoulWebHandler的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以DividePlugin为例，看下它的order属性是从一个枚举类里面来的。\n @Override public int getOrder() { return PluginEnum.DIVIDE.getCode(); }  而各个插件的order的具体值是在soul-common/src/main/java/org/dromara/soul/common/enums/PluginEnums这个枚举类里面定义的。PluginEnum的code即为各个插件的order。\n插件的顺序为：global -\u0026amp;gt; sign -\u0026amp;gt; waf -\u0026amp;gt; rate-limiter -\u0026amp;gt; hystrix -\u0026amp;gt; resilience4j -\u0026amp;gt; divide -\u0026amp;gt; webClient -\u0026amp;gt; …………\n每次有一个请求的时候，WebHandler即SoulWebHandler的handle方法都会被调用，该方法里面最主要的就是初始化了一个插件链DefaultSoulPluginChain，并执行该插件链。\n看一 …","date":1610841600,"description":"ShenYu网关学习(2-2)divide插件源码解析","dir":"blog/shenyu_source_learning_02_divide_plugin_source/","fuzzywordcount":3100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"978e21fa1989b69994c47567327284a1e9833b2d","permalink":"/zh/blog/shenyu_source_learning_02_divide_plugin_source/","publishdate":"2021-01-17T00:00:00Z","readingtime":7,"relpermalink":"/zh/blog/shenyu_source_learning_02_divide_plugin_source/","summary":"Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/fi","tags":["ShenYu"],"title":"ShenYu网关学习(2-2)Http代理之divide插件源码解析","type":"blog","url":"/zh/blog/shenyu_source_learning_02_divide_plugin_source/","wordcount":3042},{"author":"yuanjie","categories":"ShenYu","content":" Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配置文件可以看到，两者是通过WebSocket协议进行数据同步：\n通过bootstrap日志也可以看到：\n所谓的数据同步是指将soul-admin中配置的数据，同步到soul集群中的JVM内存里面，是网关高性能的关键。\n我们启动两个项目之后就可以通过后台管理系统测试divide插件了。\n二、divide插件介绍 divide插件是网关处理http协议请求的核心处理插件，也是soul唯一默认开启的插件：\n我们可以想象一下网关到底是做什么的，去猜测一下处理http请求的divide插件可能具备哪些功能呢？\n首先，作为微服务网关，它的背后一定存在多条业务线的分布式微服务集群，而网关作为所有服务的统一入口，必须具备的能力就是流量分发/路由/负载均衡等，而divide这个单词顾名思义就是分配、分发的意思，所以我们可以猜测divide插件就是对http请求进行各种规则的路由转发，这也是网关最基础的能力。\n我们打开管理界面上的插件列表，可以看到所有插件都是由两部分组成：选择器（selector）和选择器规则。\n插件化设计思想是soul网关最核心的设计思想，而选择器和规则这两个概念也是soul网关的灵魂所在，理论上来说，我们掌握好它，就能对任何接入网关的流量进行管理。\n一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n选择器  名称：为你的选择器起一个容易分辨的名字 类型：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 匹配方式：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 条件：\n uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配：  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。  是否开启：打开才会生效 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。\n选择器规则   可以看到，规则的配置和选择器类似，可以理解为更细粒度的自定义配置。\n三、divide插件使用 废话少说，我们直接运行soul提供的examples模块来演示divide插件。\n注意，我们最终运行的是soul-examples-http模块。配置文件可以使用默认的，也可以自定义contextPath和appName，如上图。\n我们需要注意，contextPath这个属性非常重要，相当于是我们所有http请求的namespace，和选择器一一对齐。一般来说，我们可以配置一个业务对应一个contextPath，一个业务下面配置相同contextPath的多个服务实例会自动映射到同一个选择器进行负载均衡。\n我们启动端口为8188的这个进程后，可以发现管理控制台divide插件列表中自动配置了这个实例对应的选择器、规则：\n可以看到我启动的这个8188项目地址自动注册上去了：\n测试网关路由 通过postman先测试不经过网关转发：\nhttp://localhost:8188/order/findById?id=1  然后再测试通过网关转发到这个接口：\nhttp://localhost:9195/my-http/order/findById?id=1  看日志发现确实经过了网关转发到了8188接口地址：\n测试负载均衡 我们修改端口为8189，启动第二个进程。\n注意IDEA需要取消 Single instance only 的限制：\n我们再进入管理控制台，发现my-http选择器下出现两个配置地址：\n此时我们继续测试，发现负载均衡策略确实生效了：\n今天只是演示了divide插件最基础的配置，还有其他各种规则配置后面都可以试一试~\n","date":1610755200,"description":"ShenYuLearning(2) Use Divide Plugin","dir":"blog/shenyu_source_learning_02_divide_plugin/","fuzzywordcount":1700,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"2395b296a9d0ddafeb310c1b46b6daa70a006227","permalink":"/blog/shenyu_source_learning_02_divide_plugin/","publishdate":"2021-01-16T00:00:00Z","readingtime":4,"relpermalink":"/blog/shenyu_source_learning_02_divide_plugin/","summary":"Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配","tags":["ShenYu"],"title":"ShenYuLearning(2) Use Divide Plugin","type":"blog","url":"/blog/shenyu_source_learning_02_divide_plugin/","wordcount":1671},{"author":"袁杰","categories":"ShenYu","content":" Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配置文件可以看到，两者是通过WebSocket协议进行数据同步：\n通过bootstrap日志也可以看到：\n所谓的数据同步是指将soul-admin中配置的数据，同步到soul集群中的JVM内存里面，是网关高性能的关键。\n我们启动两个项目之后就可以通过后台管理系统测试divide插件了。\n二、divide插件介绍 divide插件是网关处理http协议请求的核心处理插件，也是soul唯一默认开启的插件：\n我们可以想象一下网关到底是做什么的，去猜测一下处理http请求的divide插件可能具备哪些功能呢？\n首先，作为微服务网关，它的背后一定存在多条业务线的分布式微服务集群，而网关作为所有服务的统一入口，必须具备的能力就是流量分发/路由/负载均衡等，而divide这个单词顾名思义就是分配、分发的意思，所以我们可以猜测divide插件就是对http请求进行各种规则的路由转发，这也是网关最基础的能力。\n我们打开管理界面上的插件列表，可以看到所有插件都是由两部分组成：选择器（selector）和选择器规则。\n插件化设计思想是soul网关最核心的设计思想，而选择器和规则这两个概念也是soul网关的灵魂所在，理论上来说，我们掌握好它，就能对任何接入网关的流量进行管理。\n一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n选择器 * **名称**：为你的选择器起一个容易分辨的名字 * **类型**：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 * **匹配方式**：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 * **条件**： * uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） * header：是指根据请求头里面的字段来筛选流量。 * query：是指根据uri的查询条件来进行筛选流量。 * ip：是指根据你请求的真实ip，来筛选流量。 * host：是指根据你请求的真实host，来筛选流量。 * post：建议不要使用。 * 条件匹配： * match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） * = : 前后值相等，才能匹配。 * regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 * like ：字符串模糊匹配。 * **是否开启**：打开才会生效 * **打印日志**：打开的时候，当匹配上的时候，会打印匹配日志。 * **执行顺序**：当多个选择器的时候，执行顺序小的优先执行。  选择器规则 可以看到，规则的配置和选择器类似，可以理解为更细粒度的自定义配置。\n三、divide插件使用 废话少说，我们直接运行soul提供的examples模块来演示divide插件。\n注意，我们最终运行的是soul-examples-http模块。配置文件可以使用默认的，也可以自定义contextPath和appName，如上图。\n我们需要注意，contextPath这个属性非常重要，相当于是我们所有http请求的namespace，和选择器一一对齐。一般来说，我们可以配置一个业务对应一个contextPath，一个业务下面配置相同contextPath的多个服务实例会自动映射到同一个选择器进行负载均衡。\n我们启动端口为8188的这个进程后，可以发现管理控制台divide插件列表中自动配置了这个实例对应的选择器、规则：\n可以看到我启动的这个8188项目地址自动注册上去了：\n测试网关路由 通过postman先测试不经过网关转发：\nhttp://localhost:8188/order/findById?id=1  然后再测试通过网关转发到这个接口：\nhttp://localhost:9195/my-http/order/findById?id=1  看日志发现确实经过了网关转发到了8188接口地址：\n测试负载均衡 我们修改端口为8189，启动第二个进程。\n注意IDEA需要取消 Single instance only 的限制：\n我们再进入管理控制台，发现my-http选择器下出现两个配置地址：\n此时我们继续测试，发现负载均衡策略确实生效了：\n今天只是演示了divide插件最基础的配置，还有其他各种规则配置后面都可以试一试~\n","date":1610755200,"description":"ShenYu网关学习(2-1)divide插件使用","dir":"blog/shenyu_source_learning_02_divide_plugin/","fuzzywordcount":1800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"8a108dcfe9643a3bf7c103eafd3f565af84071df","permalink":"/zh/blog/shenyu_source_learning_02_divide_plugin/","publishdate":"2021-01-16T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/shenyu_source_learning_02_divide_plugin/","summary":"Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配","tags":["ShenYu"],"title":"ShenYu网关学习(2-1)Http代理之divide插件使用","type":"blog","url":"/zh/blog/shenyu_source_learning_02_divide_plugin/","wordcount":1717},{"author":"zhuming","categories":"ShenYu","content":" 插件链总结 从一个类关系图说起:\n其中两个最基本的插件类:\n SoulPlugin: 定义插件职责的接口, 重点方法execute() 被上层调用, skip() 方法可以使某些插件在某些请求中被跳过.\n AbstractPlugin: 抽象类, 实现接口的 execute(), 定义一套通用的执行流程, 并使用模板方法的设计模式, 提供doExecute()抽象方法供实现类写自己的逻辑.\n  AbstractSoulPlugin 具体分析下 AbstractSoulPlugin 类的 execute():\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { String pluginName = named(); final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); // 如果 pluginData.getEnabled() 为 false, 会直接跳到下个插件, 仅有为数不多的插件会进入这个条件判断 (DividePlugin、AlibabaDubboPlugin等) if (pluginData != null \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { // 获得插件上的所有选择器 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); if (CollectionUtils.isEmpty(selectors)) { return CheckUtils.checkSelector(pluginName, exchange, chain); } // 检查上下文中的请求路径, 是否与选择器匹配, 并得到唯一一个匹配的选择器数据 final SelectorData selectorData = matchSelector(exchange, selectors); if (Objects.isNull(selectorData)) { if (PluginEnum.WAF.getName().equals(pluginName)) { return doExecute(exchange, chain, null, null); } return CheckUtils.checkSelector(pluginName, exchange, chain); } if (selectorData.getLoged()) { log.info(\u0026amp;quot;{} selector success match , selector name :{}\u0026amp;quot;, pluginName, selectorData.getName()); } // 获得选择器中的各个资源规则 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); if (CollectionUtils.isEmpty(rules)) { if (PluginEnum.WAF.getName().equals(pluginName)) { return doExecute(exchange, chain, null, null); } return CheckUtils.checkRule(pluginName, exchange, chain); } RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { rule = rules.get(rules.size() - 1); } else { // 匹配路径, 获得唯一一个规则 rule = matchRule(exchange, rules); } if (Objects.isNull(rule)) { return CheckUtils.checkRule(pluginName, exchange, chain); } if (rule.getLoged()) { log.info(\u0026amp;quot;{} rule success match ,rule name :{}\u0026amp;quot;, pluginName, rule.getName()); } // 执行子类的方法 return doExecute(exchange, chain, selectorData, rule); } // 执行插件链上的下个插件 return chain.execute(exchange); }  通过代码分析, 可以得到一些结论:\n execute() 有两个逻辑: 一是请求路径与选择器和规则的匹配, 最终确认一个唯一规则, 并调用子类 doExecute(); 二是执行插件链上的下个插件. execute() 实际抽象了一套规则匹配逻辑, 供所有\u0026amp;rdquo;转发类型\u0026amp;rdquo;的插件使用的, 转发类型的插件目前我了解的有 DividePlugin (http请求) 和 AlibabaDubboPlugin (dubbo请求), 其他类型的插件如果不重写 execute() 的方法, 会直接走入下个插件.  SoulPluginChain 这里还有个点, 就是插件链的形成与链式调用, 我们来分析下 SoulPluginChain 这块:\nSoulPluginChain 接口同样定义了 execute() 方法供调用者使用, 它的唯一子类 DefaultSoulPluginChain 实现了链式调用:\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange) { return Mono.defer(() -\u0026amp;gt; { // plugins 中包含所有网关加载的插件 if (this.index \u0026amp;lt; plugins.size()) { // 每次调用execute()方法, index索引自增, 会调用到下一个插件 SoulPlugin plugin = plugins.get(this.index++); // 结合上下文判断当前插件是否需要跳过 Boolean skip = plugin.skip(exchange); if (skip) { return this.execute(exchange); } else { return plugin.execute(exchange, this); } } else { return Mono.empty(); } }); } …","date":1610668800,"description":"ShenYu Gateway learning plugin chain and load balancing analysis","dir":"blog/shenyu_source_learning_05_plugin/","fuzzywordcount":3600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f695a448e9cb286c4621158efdb5ad2b87731200","permalink":"/blog/shenyu_source_learning_05_plugin/","publishdate":"2021-01-15T00:00:00Z","readingtime":8,"relpermalink":"/blog/shenyu_source_learning_05_plugin/","summary":"插件链总结 从一个类关系图说起: 其中两个最基本的插件类: SoulPlugin: 定义插件职责的接口, 重点方法execute() 被上层调用, skip() 方法可以使某些插件在某些","tags":["ShenYu"],"title":"ShenYu Gateway learning plugin chain and load balancing analysis","type":"blog","url":"/blog/shenyu_source_learning_05_plugin/","wordcount":3567},{"author":"chenxi","categories":"ShenYu","content":" Analysis of ShenYu (1) Set up ShenYu environment  ShenYu is a High-Performance Java API Gateway\nGitHub：https://github.com/apache/incubator-shenyu\ndocument：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. Prepare source code 1.1. Fork dromara/soul repository to my github cchenxi/soul 1.2. Clone the repository git clone https://github.com/cchenxi/soul.git  1.3.Open the source code with idea 1.4. Compile the ShenYu source code You can compile the project as follows.\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. Startup soul 2.1. Startup soul-admin module  soul-admin is the management system for soul.\n Choose to use MySQL to storage gateway data and modify the datasource config.\nRun org.dromara.soul.admin.SoulAdminBootstrap.\nWhen success, please visit the website http://localhost:9095/, then jump to the login page, and input the corresponding user name and password to log in.\nThe user name is admin and the password is 123456.\n2.2. Startup soul-bootstrap module  soul-bootstrap is the core of soul.\n Check the configuration of soul-bootstrap.\nPlease make sure the ip and the port has been configured for soul-admin.\nIf the console output as follows, it means the startup is successful.\n2021-01-14 15:01:15.832 INFO 17943 --- [ main] b.s.s.d.w.WebsocketSyncDataConfiguration : you use websocket sync ShenYu data....... 2021-01-14 15:01:15.924 INFO 17943 --- [ main] o.d.s.p.s.d.w.WebsocketSyncDataService : websocket connection is successful..... 2021-01-14 15:01:16.113 INFO 17943 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; log4j:WARN No appenders could be found for logger (com.alibaba.dubbo.common.logger.LoggerFactory). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 2021-01-14 15:01:17.150 INFO 17943 --- [ main] o.s.b.web.embedded.netty.NettyWebServer : Netty started on port(s): 9195 2021-01-14 15:01:17.154 INFO 17943 --- [ main] o.d.s.b.SoulBootstrapApplication : Started SoulBootstrapApplication in 5.508 seconds (JVM running for 6.762)  3. Test  Add the soul-examples module to soul\u0026amp;rsquo;s pom.xml for test.\n 3.1. Startup an HTTP backend service Startup soul-examples-http\nYou can see the dependency in soul-examples-http\u0026amp;rsquo;s pom.xml.\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Configure the application.yml\nsoul: http: adminUrl: http://localhost:9095 port: 8188 contextPath: /http appName: http full: false  If soul.http.full=false, you need to add the @SoulSpringMvcClient annotation in controller or controller method.\n3.1.1. Test the service Visit http://localhost:8188/test/findByUserId?userId=1 and the result as follows.\n3.1.2. Test forward HTTP request Visit …","date":1610668800,"description":"ShenYuLearning(1) Environment Configuration","dir":"blog/shenyu_source_learning_01/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"aaaea3a731aa59857c77d778ecc64d7297b6ac5b","permalink":"/blog/shenyu_source_learning_01/","publishdate":"2021-01-15T00:00:00Z","readingtime":5,"relpermalink":"/blog/shenyu_source_learning_01/","summary":"Analysis of ShenYu (1) Set up ShenYu environment  ShenYu is a High-Performance Java API Gateway\nGitHub：https://github.com/apache/incubator-shenyu\ndocument：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. Prepare source code 1.1. Fork dromara/soul repository to my github cchenxi/soul 1.2. Clone the repository git clone https://github.com/cchenxi/soul.git  1.3.Open the source code with idea 1.4. Compile the ShenYu source code You can compile the project as follows.\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. Startup soul 2.","tags":["ShenYu"],"title":"ShenYuLearning(1) Environment Configuration","type":"blog","url":"/blog/shenyu_source_learning_01/","wordcount":933},{"author":"陈曦","categories":"ShenYu","content":" Soul源码分析（1） 环境配置  soul is a High-Performance Java API Gateway\nGitHub：https://github.com/apache/incubator-shenyu\n官方文档：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. 源代码准备 1.1. fork dromara/soul源代码至自己的仓库cchenxi/soul 1.2. clone自己仓库中的soul源代码至本地 git clone https://github.com/cchenxi/soul.git  1.3.使用idea打开soul源代码 1.4.编译soul源代码 执行以下maven命令，等待编译完成\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. 启动 soul 2.1. 启动soul-admin模块  soul-admin是soul网关的后台管理系统\n 选择使用MySQL数据库存储网关数据，修改数据源配置为自己的数据库配置。\n运行启动类 org.dromara.soul.admin.SoulAdminBootstrap。\n启动成功后，访问地址 http://localhost:9095/ ，跳转到登录页↓\n使用用户名admin，密码 123456 登录。\n2.2. 启动soul-bootstrap模块  soul-bootstrap是网关系统的核心\n 检查soul-bootstrap的配置\n这里需要配置成 soul-admin的ip和端口\n控制台输出如下内容表示 soul-bootstrap启动成功\n2021-01-14 15:01:15.832 INFO 17943 --- [ main] b.s.s.d.w.WebsocketSyncDataConfiguration : you use websocket sync soul data....... 2021-01-14 15:01:15.924 INFO 17943 --- [ main] o.d.s.p.s.d.w.WebsocketSyncDataService : websocket connection is successful..... 2021-01-14 15:01:16.113 INFO 17943 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; log4j:WARN No appenders could be found for logger (com.alibaba.dubbo.common.logger.LoggerFactory). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 2021-01-14 15:01:17.150 INFO 17943 --- [ main] o.s.b.web.embedded.netty.NettyWebServer : Netty started on port(s): 9195 2021-01-14 15:01:17.154 INFO 17943 --- [ main] o.d.s.b.SoulBootstrapApplication : Started SoulBootstrapApplication in 5.508 seconds (JVM running for 6.762)  3. 测试http请求转发  为了方便测试，把soul-examples模块添加到soul的pom里\n 3.1. 启动一个服务 启动soul-examples-http项目\nsoul-examples-http的pom中引入了依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在 application.yml中配置\nsoul: http: adminUrl: http://localhost:9095 port: 8188 contextPath: /http appName: http full: false  如果soul.http.full=false，则需要在具体的http接口上配置 @SoulSpringMvcClient 注解\n3.1.1. 测试http服务 执行http请求 http://localhost:8188/test/findByUserId?userId=1 结果如下图\n3.1.2. 测试网关转发 执行http请求 http://localhost:9195/http/test/findByUserId?userId=1 结果如下图\n在soul-bootstrap的控制台中输出如下信息\n2021-01-14 20:42:57.123 INFO 29812 --- [work-threads-11] o.d.soul.plugin.base.AbstractSoulPlugin : divide selector success match , selector name :/http 2021-01-14 20:42:57.125 INFO 29812 --- [work-threads-11] o.d.soul.plugin.base.AbstractSoulPlugin : divide selector success match , selector name :/http/test/** 2021-01-14 20:42:57.126 INFO 29812 --- [work-threads-11] o.d.s.plugin.httpclient.WebClientPlugin : The request urlPath is http://172.27.121.155:8188/test/findByUserId?userId=1, retryTimes is 0  可以观察到网关可以将请求正常转发。\n3.2. 启动两个服务模拟负载均衡 勾选 Allow parallel run，修改端口为8189，再次启 …","date":1610668800,"description":"ShenYu网关学习(1)环境配置","dir":"blog/shenyu_source_learning_01/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e8d196b656091663fd7a0e99c3cc9037cc99b71c","permalink":"/zh/blog/shenyu_source_learning_01/","publishdate":"2021-01-15T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/shenyu_source_learning_01/","summary":"Soul源码分析（1） 环境配置 soul is a High-Performance Java API Gateway GitHub：https://github.com/apache/incubator-sheny","tags":["ShenYu"],"title":"ShenYu网关学习(1)环境配置","type":"blog","url":"/zh/blog/shenyu_source_learning_01/","wordcount":1636},{"author":"朱明","categories":"ShenYu","content":" 插件链总结 从一个类关系图说起:\n其中两个最基本的插件类:\n SoulPlugin: 定义插件职责的接口, 重点方法execute() 被上层调用, skip() 方法可以使某些插件在某些请求中被跳过.\n AbstractPlugin: 抽象类, 实现接口的 execute(), 定义一套通用的执行流程, 并使用模板方法的设计模式, 提供doExecute()抽象方法供实现类写自己的逻辑.\n  AbstractSoulPlugin 具体分析下 AbstractSoulPlugin 类的 execute():\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) { String pluginName = named(); final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName); // 如果 pluginData.getEnabled() 为 false, 会直接跳到下个插件, 仅有为数不多的插件会进入这个条件判断 (DividePlugin、AlibabaDubboPlugin等) if (pluginData != null \u0026amp;amp;\u0026amp;amp; pluginData.getEnabled()) { // 获得插件上的所有选择器 final Collection\u0026amp;lt;SelectorData\u0026amp;gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName); if (CollectionUtils.isEmpty(selectors)) { return CheckUtils.checkSelector(pluginName, exchange, chain); } // 检查上下文中的请求路径, 是否与选择器匹配, 并得到唯一一个匹配的选择器数据 final SelectorData selectorData = matchSelector(exchange, selectors); if (Objects.isNull(selectorData)) { if (PluginEnum.WAF.getName().equals(pluginName)) { return doExecute(exchange, chain, null, null); } return CheckUtils.checkSelector(pluginName, exchange, chain); } if (selectorData.getLoged()) { log.info(\u0026amp;quot;{} selector success match , selector name :{}\u0026amp;quot;, pluginName, selectorData.getName()); } // 获得选择器中的各个资源规则 final List\u0026amp;lt;RuleData\u0026amp;gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId()); if (CollectionUtils.isEmpty(rules)) { if (PluginEnum.WAF.getName().equals(pluginName)) { return doExecute(exchange, chain, null, null); } return CheckUtils.checkRule(pluginName, exchange, chain); } RuleData rule; if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) { rule = rules.get(rules.size() - 1); } else { // 匹配路径, 获得唯一一个规则 rule = matchRule(exchange, rules); } if (Objects.isNull(rule)) { return CheckUtils.checkRule(pluginName, exchange, chain); } if (rule.getLoged()) { log.info(\u0026amp;quot;{} rule success match ,rule name :{}\u0026amp;quot;, pluginName, rule.getName()); } // 执行子类的方法 return doExecute(exchange, chain, selectorData, rule); } // 执行插件链上的下个插件 return chain.execute(exchange); }  通过代码分析, 可以得到一些结论:\n execute() 有两个逻辑: 一是请求路径与选择器和规则的匹配, 最终确认一个唯一规则, 并调用子类 doExecute(); 二是执行插件链上的下个插件. execute() 实际抽象了一套规则匹配逻辑, 供所有\u0026amp;rdquo;转发类型\u0026amp;rdquo;的插件使用的, 转发类型的插件目前我了解的有 DividePlugin (http请求) 和 AlibabaDubboPlugin (dubbo请求), 其他类型的插件如果不重写 execute() 的方法, 会直接走入下个插件.  SoulPluginChain 这里还有个点, 就是插件链的形成与链式调用, 我们来分析下 SoulPluginChain 这块:\nSoulPluginChain 接口同样定义了 execute() 方法供调用者使用, 它的唯一子类 DefaultSoulPluginChain 实现了链式调用:\npublic Mono\u0026amp;lt;Void\u0026amp;gt; execute(final ServerWebExchange exchange) { return Mono.defer(() -\u0026amp;gt; { // plugins 中包含所有网关加载的插件 if (this.index \u0026amp;lt; plugins.size()) { // 每次调用execute()方法, index索引自增, 会调用到下一个插件 SoulPlugin plugin = plugins.get(this.index++); // 结合上下文判断当前插件是否需要跳过 Boolean skip = plugin.skip(exchange); if (skip) { return this.execute(exchange); } else { return plugin.execute(exchange, this); } } else { return Mono.empty(); } }); } …","date":1610668800,"description":"ShenYu网关学习插件链与负载均衡解析","dir":"blog/shenyu_source_learning_05_plugin/","fuzzywordcount":3600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"cc8dc2fa55d2d9586d4813f14928c723a5ea8daf","permalink":"/zh/blog/shenyu_source_learning_05_plugin/","publishdate":"2021-01-15T00:00:00Z","readingtime":8,"relpermalink":"/zh/blog/shenyu_source_learning_05_plugin/","summary":"插件链总结 从一个类关系图说起: 其中两个最基本的插件类: SoulPlugin: 定义插件职责的接口, 重点方法execute() 被上层调用, skip() 方法可以使某些插件在某些","tags":["ShenYu"],"title":"ShenYu网关学习插件链与负载均衡解析","type":"blog","url":"/zh/blog/shenyu_source_learning_05_plugin/","wordcount":3569},{"author":"xiaoyu","categories":null,"content":" ShenYu Dream Code Book Club（ShenYu 2020 event introduction）  Date: Sunday, December 27, 2020  Activity background  In order to increase the enthusiasm of community participants, promote the construction of the ShenYu community, exercise everyone\u0026amp;rsquo;s expressive ability and improve the core strength of technology, the community organized this event in the form of source code reading.  Activity purpose, meaning and goal  Increase motivation Improve technical strength and expand everyone\u0026amp;rsquo;s horizons Exercise language skills Promote the harmony, unity and progress of the community Make the ShenYu community bigger and bigger  Activity development  The activity is divided into multiple phases. First, twelve members are selected for a 12-day source code reading, and two online sharing is carried out during the period. In order to improve everyone\u0026amp;rsquo;s consciousness, we have set up a punishment system. First hand over 500 yuan to the administrator. If homework is not submitted at 8 am the next day, 100 yuan will be deducted for sharing latecomers. Those who ask for leave in advance do not need to be punished. Each person writes to their homework submission area in text based on the content they read every day.  Activity leader and main participants Principal  Cui, Kimming, Xiaoyu  The main participants  ShenYu community member  ","date":1609081200,"description":"","dir":"blog/apache-activites-introduce/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7d96d9c1a8354a9530ce4ca46c2eb4038d5e9ded","permalink":"/blog/apache-activites-introduce/","publishdate":"2020-12-27T15:00:00Z","readingtime":1,"relpermalink":"/blog/apache-activites-introduce/","summary":"ShenYu Dream Code Book Club（ShenYu 2020 event introduction）  Date: Sunday, December 27, 2020  Activity background  In order to increase the enthusiasm of community participants, promote the construction of the ShenYu community, exercise everyone\u0026rsquo;s expressive ability and improve the core strength of technology, the community organized this event in the form of source code reading.  Activity purpose, meaning and goal  Increase motivation Improve technical strength and expand everyone\u0026rsquo;s horizons Exercise language skills Promote the harmony, unity and progress of the community Make the ShenYu community bigger and bigger  Activity development  The activity is divided into multiple phases.","tags":["DreamCode","Apache","GateWay"],"title":"ShenYu Dream Code Book Club Introduction","type":"blog","url":"/blog/apache-activites-introduce/","wordcount":203},{"author":"xiaoyu","categories":null,"content":" ShenYu 梦码读书会（ShenYu 2020 活动介绍）  日期：2020年12月27日，星期日  活动背景  为了提高社区参与者的积极性, 促进ShenYu社区的建设, 锻炼大家的表达能力和提升技术核心力量, 社区以源码阅读形式自发行的组织本次活动  活动目的,意义和目标  提高积极性 提升技术力量,扩展大家视野 锻炼语言表达能力 促进社区的和谐、团结、共进 将ShenYu社区做的越来越大  活动开展  活动分多期,先是挑选十二位组员进行为期12天的源码阅读,期间进行两次线上分享 为了提高大家的自觉性我们设立了惩罚制度,先交出500元/人给管理员,隔天的早上8点作业未提交,分享迟到者扣100元/次,提前请假者无需惩罚 每人根据每天阅读的内容,以文字形式写到各自的作业提交区  活动负责人以及主要参与者 负责人  崔,kimming,猫大人  主要参与者  ShenYu 社区组员  ","date":1609081200,"description":"","dir":"blog/apache-activites-introduce/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3e25040162cb121d23dc0392a2708108b4f67a53","permalink":"/zh/blog/apache-activites-introduce/","publishdate":"2020-12-27T15:00:00Z","readingtime":1,"relpermalink":"/zh/blog/apache-activites-introduce/","summary":"ShenYu 梦码读书会（ShenYu 2020 活动介绍） 日期：2020年12月27日，星期日 活动背景 为了提高社区参与者的积极性, 促进ShenYu社区的建设, 锻","tags":["DreamCode","ShenYu","GateWay"],"title":"ShenYu 梦码读书会介绍","type":"blog","url":"/zh/blog/apache-activites-introduce/","wordcount":347},{"author":"xiaoyu","categories":"Apache ShenYu","content":" Let\u0026amp;rsquo;s take a look at the new features first, and then I would like to share my story.\n Completely pluggable architecture design, plug-in hot swap. Fully supports all versions of Dubbo, Alibaba-Dubbo, Apache-Dubbo. Support Dubbo generalization call, multi-parameter, complex parameter interface. Enhance the monitor plug-in and remove the Influxdb, add metrics such as memory, CPU, QPS, TPS, response delay, and support access to Prometheus. The SpringCloud plugin supports Eureka and Nacos two registration centers. The waf plugin is enhanced to support black or white lists and mixed modes. Remove the Hystrix circuit breaker to be an independent plug-in. Fix the Zookeeper data synchronization bug, and add the data synchronization method implemented by Nacos. Support multiple kinds of soul-client, such as traditional Spring and Springboot. Optimize the soul-admin user interface. Fix load balancing algorithm bug. Fix uploading large files bug. etc.  Experience the new architecture and get a high-availability and high-performance gateway in 10 minutes! Bootstrap soul-admin  Please download soul-admin.jar, and bootstrap it. Please access http://localhost:9095/index.html , and the default user name is admin, password is 123456。\n\u0026amp;gt; wget https://yu199195.github.io/jar/soul-admin.jar \u0026amp;gt; java -jar soul-admin.jar --spring.datasource.url=\u0026amp;quot;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; --spring.datasource.username=\u0026#39;you username\u0026#39; --spring.datasource.password=\u0026#39;you password\u0026#39;  Build your own gateway  Firstly, you should create an empty Springboot project, please refer to soul-bootstrap. You can also visit the Spring official website :[https://spring.io/quickstart] Secondly, please add Maven dependency like follows：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--ShenYu gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--ShenYu data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Please add the following configuration to your application.yaml:\nspring: main: allow-bean-definition-overriding: true management: health: defaults: enabled: false ShenYu : sync: websocket : urls: ws://localhost:9095/websocket //Set to youe soul-admin address.   Experience plug-in hot swap under the new …","date":1592352000,"description":"Apache ShenYu released version 2.2.0 with new architecture that makes gateways so easy. ","dir":"community/shenyu-2.2.0/","fuzzywordcount":1700,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3f3537c97a94d434501dd433f7fd80566e9b3325","permalink":"/community/shenyu-2.2.0/","publishdate":"2020-06-17T00:00:00Z","readingtime":4,"relpermalink":"/community/shenyu-2.2.0/","summary":"Let\u0026rsquo;s take a look at the new features first, and then I would like to share my story. Completely pluggable architecture design, plug-in hot swap. Fully supports all versions of Dubbo, Alibaba-Dubbo, Apache-Dubbo. Support Dubbo generalization call, multi-parameter, complex parameter interface. Enhance the monitor plug-in and remove the Influxdb, add metrics such as memory, CPU, QPS, TPS, response delay, and support access to Prometheus. The SpringCloud plugin supports Eureka and","tags":["Apache ShenYu"],"title":"【Apache ShenYu gateway version2.2.0 release】Make high-performance gateways so easy!","type":"community","url":"/community/shenyu-2.2.0/","wordcount":1648},{"author":"xiaoyu","categories":"ShenYu","content":" 我们还是先来看看新增功能，然后再讲故事。\n 完全的插件化架构设计，插件热插拔。 完整支持dubbo所有版本，alibaba-dubbo ，apache-dubbo。 支持dubbo泛化调用，多参数，复杂参数接口。 增强monitor插件，移除influxdb支持，新增内存，CPU，QPS，TPS，响应迟延等metrics，支持接入Prometheus。 springCloud插件支持eureka与nacos二种注册中心。 waf插件增强,支持黑白名单，以及混合模式。 抽离Hystrix熔断功能，独立成插件支持。 修护Zookeeper数据同步方式bug，新增nacos同步数据方式。 多种soul-client支持，提供传统spring，以及springboot等方式接入。 优化 soul-admin后台控制界面。 负载均衡算法bug修护。 修护大文件上传时候的bug。 …….太多了不一一列举了。  体验新架构，10分钟搞定一个高可用高性能网关。 启动 soul-admin - 下载soul-admin.jar包，并启动.\n\u0026amp;gt; wget https://yu199195.github.io/jar/soul-admin.jar \u0026amp;gt; java -jar soul-admin.jar --spring.datasource.url=\u0026amp;quot;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; --spring.datasource.username=\u0026#39;you username\u0026#39; --spring.datasource.password=\u0026#39;you password\u0026#39;   访问 http://localhost:9095/index.html 默认的用户名：admin 密码:123456。  搭建属于你的网关\n 首先你新建一个空的springboot项目，可以参考 soul-bootstrap. 也可以在spring官网:[https://spring.io/quickstart] 引入如下jar包：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在你的 application.yaml 文件中加上如下配置：\nspring: main: allow-bean-definition-overriding: true management: health: defaults: enabled: false soul : sync: websocket : urls: ws://localhost:9095/websocket //设置成你的soul-admin地址  这样网关的环境就已经搭建完成。\n  体验新架构下的插件热插拔  问：我想使用熔断功能，应该如何做呢？\n 答：你可以在pom.xml文件 引入以下依赖,更多的还请看：https://dromara.org/zh-cn/docs/soul/soul.html\n\u0026amp;lt;!-- soul hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul hystrix plugin end--\u0026amp;gt;  问:我怎么接入dubbo服务呢？\n 答： 1）如果你使用的是alibaba-dubbo，那么你应该引入如下：\n\u0026amp;lt;!--soul alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul alibaba dubbo plugin end--\u0026amp;gt;  2） 如果你使用apache-dubbo，那么你应该引入如下：\n\u0026amp;lt;!--soul apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; …","date":1592352000,"description":"Apache ShenYu发布全新的架构2.2.0版本 让网关变得如此简单","dir":"community/shenyu-2.2.0/","fuzzywordcount":3400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"ff092783fc20cebff426b04f01c28470e761b923","permalink":"/zh/community/shenyu-2.2.0/","publishdate":"2020-06-17T00:00:00Z","readingtime":7,"relpermalink":"/zh/community/shenyu-2.2.0/","summary":"我们还是先来看看新增功能，然后再讲故事。 完全的插件化架构设计，插件热插拔。 完整支持dubbo所有版本，alibaba-dubbo ，apach","tags":["Apache ShenYu"],"title":"【Apache ShenYu网关发布2.2.0】让高性能网关变得如此简单！","type":"community","url":"/zh/community/shenyu-2.2.0/","wordcount":3326},{"author":"xiaoyu","categories":"ShenYu","content":" Soul 网关自从去年10月我开源以来，经历了一年的事情，接受到了来自社区很多朋友的建议，并进行持续不断的优化，已经提供了非常丰富的功能，很多功能都是高度自定义，可视化，高度可扩展的，现在做一个归纳总结。\n插件\n- 提供了系统自带的各种插件，比如签名，监控，限流，熔断，http代理，dubbo代理，websocket等等。\n 支持用户快速的进行插件的自定义开发。\n 插件的所有数据，开关状态支持动态变更。\n  数据同步 - 提供了 http长轮询，zookeeper，websocket 三种不同的数据同步策略，让用户自由选择。 - 推荐用户使用websocket方式，最轻量，在集群环境下，效率更高。\n对于用户 - 首先我们提供了便于用户接入的 client包，用户可以把快速的把自己的项目接入到soul 网关。 - 默认情况下，用户完全不用关心 soul网关的选择器，规则等配置。 - 用户之前的接口完全是零侵入，不需要任何更改，只是需要把访问域名改成网关的域名即可。 - 比如 dubbo用户，几乎就是http的方式完成了 http协议到 dubbo协议的互相转换。 - soul 使用的是http协议，那么注定它就是跨语言的，net程序员，php程序员等等，要和java进行数据交互，那么就大大的可行了。\n举个列子 ，比如你有一个 dubbo接口 参数定义是一个java bean,\npublic void insert(final DubboTest dubboTest) { } public class DubboTest implements Serializable { private String id; private String name; }  如果你使用 soul网关要发起对它的调用，你的http传参数 就是在 body 里面 传一个json字符串 ，和普通的http调用无差别。\n{\u0026amp;quot;id\u0026amp;quot;:\u0026amp;quot;123\u0026amp;quot;,\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;xiaoyu\u0026amp;quot;}  对于开发者(程序员)\n 随着使用者越来越多，每个公司使用情况又不一样,soul 网关在2.1.X版本，处处留出来更多的高度自定义扩展性，让开发者，更加方便或者有信心融入进来。 比如，自定义插件，过滤器，dubbo参数解析器，iphost解析器，返回结果等等。。这里我着重说一下自定义返回结果。 我们知道，soul 网关默认的返回结果是：\n{\u0026amp;quot;code\u0026amp;quot;:200, \u0026amp;quot;message \u0026amp;quot;: \u0026amp;quot;成功!\u0026amp;quot;,\u0026amp;quot;data\u0026amp;quot; :\u0026amp;quot;helloWorld!\u0026amp;quot;}   但是，在运用 soul 网关对你的业务系统进行调用的时候，你的业务系统可能定义的结果并不是上述结构，可能你的 字段叫 msg,这样就会造成结构不一样，给前端处理带来了困扰。我们注意到了这个事情 ：https://github.com/apache/incubator-shenyu/issues/109 , 现在已经优化，用户可以定制化的来定义返回结果,具体的要看 soul 文档。\n说了这么多，吹了这么多牛逼，那么我们来看看 soul网关到底可以在什么场景下能发挥大作用。\n后台管理web\n 首先随便微服务的流行，我们的后台都划分成很多的微服务，我相信你们每个公司都有一个后台管理系统吧，如果我没猜错的话，他们大体上是如下架构。   很简单对吧，就是有个运营管理平台的web项目，去调用每个微服务，来进行后台的查看等等。随着你们业务需要的加大，可能这里需要调用的微服务越来越多，你的 controller越来越多，现在比如你修改了 商品模块的 接口，你要发版会造成所有其他的模块也操作不了（就是你发版影响了其他模块的使用，别杠这里只是比方，不要整蓝绿发版啥的，明白意思吧）。 如果有运营人员在操作其他模块，会不会吐槽你？  假如你是公司架构师，我说的是假如，那么你要怎么解决这个问题呢？当然，我们把这样一个大的web系统，拆分成很多小web系统，单独的进行发布，但是这样会引入一个问题，怎么统一登陆，鉴权？（很多后台管理系统还有权限的划分） ，这个时候，soul 网关 就能发挥重要的作用了，下面我只是列举了一下简单的调用图。\n这样多方便，集成了网关，每个微服务注册到网关，网关根据路由规则来进行调用。自动发现服务，连运维配置 nginx的工作都省了，把运维的工资给你，美滋滋。\n公司入口网关（开放平台）  如果一个公司要做开放平台或者入口网关，鉴权，限流，监控，熔断肯定少不了。\n 如果贵公司是dubbo体系，开发人员写了dubbo服务后，还要傻乎乎的新增一个web项目，来提供接口给别人调用吗？\n 如果一个接口被攻击，你怎么处理呢？如果被大流量攻击，你怎么处理呢？\n 不巧，soul 在设计之初就是来干这种事情的，我们来看一下整体的架构图。\n  零零总总还有很多其他功能  比如支持 websocket 代理。 比如支持文件上传下载。\n 比如你可以自定义的开发你的插件啊。\n  最后最后  github地址 ：https://github.com/apache/incubator-shenyu\n gitee地址 ：https://gitee.com/dromara/soul\n 文档：https://dromara.org/zh-cn/docs/soul/soul.html\n 欢迎大家关注，如果贵公司有使用到，或者需要学习交流，或者提供代码参与开发的朋友也可以加群来进行讨论 ，qq群（429951241）\n 最后 3.0 已经在进行开源了，3.0是经历过2年双11大并发场景验证过的，现在一步一步将它开源出来，希望给大家带来帮助.\n  ","date":1576108800,"description":"​Apache ShenYu网关发布2.1.X之后，它到底有多方便？","dir":"community/shenyu-2.1.x/","fuzzywordcount":2100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"d2876dc171df8492bee1d56077dbc3b9d1f2c7c2","permalink":"/zh/community/shenyu-2.1.x/","publishdate":"2019-12-12T00:00:00Z","readingtime":5,"relpermalink":"/zh/community/shenyu-2.1.x/","summary":"Soul 网关自从去年10月我开源以来，经历了一年的事情，接受到了来自社区很多朋友的建议，并进行持续不断的优化，已经提供了非常丰富的功能，很多功能都","tags":["Apache ShenYu"],"title":"Apache ShenYu网关发布的2.1.X版本，到底有多方便？","type":"community","url":"/zh/community/shenyu-2.1.x/","wordcount":2014},{"author":"xiaoyu","categories":"Apache ShenYu","content":" It has been a year since I open sourced ShenYu gateway in October last year, and received many suggestions from you guys in community. It has provided very rich functions after optimization, many of functions are highly cusmized, visualized, and highly extensible, now let\u0026amp;rsquo;s make a summary.\nPlugin  Provides various plug-ins, such as signature, monitoring, rate limiting, circuit breaker, Http proxy, Dubbo proxy, Websocket, etc.\n Support users to quickly develop plug-ins.\n All plug-in data and switch state support dynamic changes.\n  Data Synchronization  Provides three different data synchronization strategies: Http long polling, Zookeeper, and Websocket, allowing users to choose freely. It is recommended to use Websocket, which is the lightest and more efficient in a cluster environment.  For Users  First of all, we provide a client package that is convenient for users to access. Users can quickly register their projects to the ShenYu gateway. By default, users don\u0026amp;rsquo;t need to care about ShenYu Gateway\u0026amp;rsquo;s selectors, rules and other configurations. The user\u0026amp;rsquo;s previous interface is completely zero intrusion, It is only need to change to the domain name of the ShenYu gateway. For Dubbo users, the conversion from Http protocol to Dubbo protocol is almost completed by Http. ShenYu gataway uses the Http protocol, so it is destined to be cross-language, It is feasible for .Net programmers, PHP programmers to interact with Java program.  For example, if you have a Dubbo interface, the parameter definition is a java bean,\npublic void insert(final DubboTest dubboTest) { } public class DubboTest implements Serializable { private String id; private String name; }  If you use the ShenYu gateway to call this method, your Http parameter is to pass a json string in the body, which is no different from a normal http call.\n{\u0026amp;quot;id\u0026amp;quot;:\u0026amp;quot;123\u0026amp;quot;,\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;xiaoyu\u0026amp;quot;}  For Developers  With more and more users, the situation of each company is different. ShenYu gateway in 2.1.X version are more extensible, making it convenient for developers . For example, there are may things could be extensible, such as Plug-ins, Filters, Dubbo parameter parser, iphost parser, return results, etc. We know that the default return result of the ShenYu gateway is:  {\u0026amp;quot;code\u0026amp;quot;:200, \u0026amp;quot;message \u0026amp;quot;: \u0026amp;quot;成功!\u0026amp;quot;,\u0026amp;quot;data\u0026amp;quot; :\u0026amp;quot;helloWorld!\u0026amp;quot;}  However, when using the ShenYu gateway to call your business system, your business system may define the result that is not confirm the above structure. Maybe your field is called msg, which will cause a different structure and bring confusion to the front-end processing. We have noticed this thing: https://github.com/apache/incubator-shenyu/issues/109, now it has been optimized, users can customize the return results to define, the specifics depend on the ShenYu document.\nWhat scenarios of ShenYu gateway are suitable, and what should you pay attention to? First of all, I …","date":1576108800,"description":"How convenient is the 2.1.X version of ShenYu Gateway?","dir":"community/shenyu-2.1.x/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"cb514836ed89a362be8616d7d9b21b838149bc09","permalink":"/community/shenyu-2.1.x/","publishdate":"2019-12-12T00:00:00Z","readingtime":2,"relpermalink":"/community/shenyu-2.1.x/","summary":"It has been a year since I open sourced ShenYu gateway in October last year, and received many suggestions from you guys in community. It has provided very rich functions after optimization, many of functions are highly cusmized, visualized, and highly extensible, now let\u0026rsquo;s make a summary. Plugin Provides various plug-ins, such as signature, monitoring, rate limiting, circuit breaker, Http proxy, Dubbo proxy, Websocket, etc. Support users to quickly develop","tags":["Apache ShenYu"],"title":"How convenient is the 2.1.X version of Apache ShenYu Gateway?","type":"community","url":"/community/shenyu-2.1.x/","wordcount":966},{"author":"xiaoyu","categories":"Apache ShenYu","content":" Development Guidelines  Write codes with heart. Pursue clean, simplified and extremely elegant codes. Agree with concepts in \u0026amp;lt;Refactoring: Improving the Design of Existing Code\u0026amp;gt; and \u0026amp;lt;Clean Code: A Handbook of Agile Software Craftsmanship\u0026amp;gt;. Be familiar with codes already had, to keep consistent with the style and use. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time.  Contributor Covenant Submitting of Conduct  Make sure all the test cases are passed, Make sure ./mvnw clean install can be compiled and tested successfully. Make sure the test coverage rate is not lower than the master branch. Make sure to check codes with Checkstyle. codes that violate check rules should have special reasons. Find checkstyle template from https://github.com/apache/incubator-shenyu/blob/master/script/shenyu_checkstyle.xml, please use checkstyle 8.8 to run the rules. Careful consideration for each pull request; Small and frequent pull request with complete unit function is welcomed. Conform to Contributor Covenant Code of Conduct below.  Contributor Covenant Code of Conduct  Use linux line separators. Keep indents (including blank lines) consistent with the previous one. Keep one blank line after class definition. No meaningless blank lines. Please extract private methods to instead of blank lines if too long method body or different logic code fragments. Use meaningful class, method and variable names, avoid to use abbreviate. Return values are named with result; Variables in the loop structure are named with each; Replace each with entry in map. Name property files with Spinal Case(a variant of Snake Case which uses hyphens - to separate words). Split codes that need to add notes with it into small methods, which are explained with method names. Have constants on the left and variable on the right in = and equals conditional expressions; Have variable on the left and constants on the right in greater than and less than conditional expressions. Beside using same names as input parameters and global fields in assign statement, avoid using this modifier. Design class as final class except abstract class for extend. Make nested loop structures a new method. Order of members definition and parameters should be consistent during classes and methods. Use guard clauses in priority. Minimize the access permission for classes and methods. Private method should be just next to the method in which it is used; writing private methods should be in the same as the appearance order of private methods. No null parameters or return values. Replace if else return and assign statement with ternary operator in priority. Use LinkedList in priority. Use ArrayList for use index to get element only. Use capacity based Collection such as ArrayList, HashMap must indicate initial capacity to avoid recalculate capacity. Use English in all the logs and javadoc. Include Javadoc, todo and fixme only in the comments. Only public classes and …","date":1554768000,"description":"Apache ShenYu Coding Guide","dir":"community/code-conduct/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"ea617ce247cdad7f25b55bb540027302d81b08f5","permalink":"/community/code-conduct/","publishdate":"2019-04-09T00:00:00Z","readingtime":4,"relpermalink":"/community/code-conduct/","summary":"Development Guidelines  Write codes with heart. Pursue clean, simplified and extremely elegant codes. Agree with concepts in \u0026lt;Refactoring: Improving the Design of Existing Code\u0026gt; and \u0026lt;Clean Code: A Handbook of Agile Software Craftsmanship\u0026gt;. Be familiar with codes already had, to keep consistent with the style and use. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time.  Contributor Covenant Submitting of Conduct  Make sure all the test cases are passed, Make sure .","tags":["Code Conduct"],"title":"Apache ShenYu Code Conduct","type":"community","url":"/community/code-conduct/","wordcount":708},{"author":"xiaoyu","categories":"Apache ShenYu","content":" 开发理念  用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理念，追求整洁优雅代码。 一致 代码风格、命名以及使用方式保持完全一致。 精简 极简代码，以最少的代码表达最正确的意思。高度复用，无重复代码和配置。及时删除无用代码。 抽象 层次划分清晰，概念提炼合理。保持方法、类、包以及模块处于同一抽象层级。  代码提交行为规范  确保通过全部测试用例，确保执行./mvnw clean install可以编译和测试通过。 确保覆盖率不低于master分支。 确保使用Checkstyle检查代码，违反验证规则的需要有特殊理由。模板位置在https://github.com/apache/incubator-shenyu/blob/master/script/shenyu_checkstyle.xml，请使用checkstyle 8.8运行规则。 应尽量将设计精细化拆分；做到小幅度修改，多次数提交，但应保证提交的完整性。 确保遵守编码规范。  编码规范  使用linux换行符。 缩进（包含空行）和上一行保持一致。 类声明后与下面的变量或方法之间需要空一行。 不应有无意义的空行。请提炼私有方法，代替方法体过长或代码段逻辑闭环而采用的空行间隔。 类、方法和变量的命名要做到顾名思义，避免使用缩写。 返回值变量使用result命名；循环中使用each命名循环变量；map中使用entry代替each。 配置文件使用Spinal Case命名（一种使用-分割单词的特殊Snake Case）。 需要注释解释的代码尽量提成小方法，用方法名称解释。 equals和==条件表达式中，常量在左，变量在右；大于小于等条件表达式中，变量在左，常量在右。 除了构造器入参与全局变量名称相同的赋值语句外，避免使用this修饰符。 除了用于继承的抽象类之外，尽量将类设计为final。 嵌套循环尽量提成方法。 成员变量定义顺序以及参数传递顺序在各个类和方法中保持一致。 优先使用卫语句。 类和方法的访问权限控制为最小。 方法所用到的私有方法应紧跟该方法，如果有多个私有方法，书写私有方法应与私有方法在原方法的出现顺序相同。 方法入参和返回值不允许为null。 优先使用三目运算符代替if else的返回和赋值语句。 优先考虑使用LinkedList，只有在需要通过下标获取集合中元素值时再使用ArrayList。 ArrayList，HashMap等可能产生扩容的集合类型必须指定集合初始大小，避免扩容。 日志与注释一律使用英文。 注释只能包含javadoc，todo和fixme。 公开的类和方法必须有javadoc，其他类和方法以及覆盖自父类的方法无需javadoc。  单元测试规范  测试代码和生产代码需遵守相同代码规范。 单元测试需遵循AIR（Automatic, Independent, Repeatable）设计理念。  自动化（Automatic）：单元测试应全自动执行，而非交互式。禁止人工检查输出结果，不允许使用System.out，log等，必须使用断言进行验证。 独立性（Independent）：禁止单元测试用例间的互相调用，禁止依赖执行的先后次序。每个单元测试均可独立运行。 可重复执行（Repeatable）：单元测试不能受到外界环境的影响，可以重复执行。  单元测试需遵循BCDE（Border, Correct, Design, Error）设计原则。  边界值测试（Border）：通过循环边界、特殊数值、数据顺序等边界的输入，得到预期结果。 正确性测试（Correct）：通过正确的输入，得到预期结果。 合理性设计（Design）：与生产代码设计相结合，设计高质量的单元测试。 容错性测试（Error）：通过非法数据、异常流程等错误的输入，得到预期结果。  如无特殊理由，测试需全覆盖。 每个测试用例需精确断言。 准备环境的代码和测试代码分离。 只有junit Assert，hamcrest CoreMatchers，Mockito相关可以使用static import。 单数据断言，应使用assertTrue，assertFalse，assertNull和assertNotNull。 多数据断言，应使用assertThat。 精确断言，尽量不使用not，containsString断言。 测试用例的真实值应名为为actualXXX，期望值应命名为expectedXXX。 测试类和@Test标注的方法无需javadoc。  ","date":1554768000,"description":"Apache ShenYu 编码指南","dir":"community/code-conduct/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"22df9e9a0a733a840588663c176c4ed5d20213e8","permalink":"/zh/community/code-conduct/","publishdate":"2019-04-09T00:00:00Z","readingtime":4,"relpermalink":"/zh/community/code-conduct/","summary":"开发理念 用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理","tags":["Code Conduct"],"title":"Apache ShenYu Code Conduct","type":"community","url":"/zh/community/code-conduct/","wordcount":1807},{"author":"xiaoyu","categories":"Apache ShenYu","content":" Committer Promotion After you have made a lot of contributions, the community will nominate. Become a committer you will have\n Permissions written by ShenYu repository Idea is used legally  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  A committer needs to review every day the Pull Request and issue list to be processed by the community, and assign a suitable committer, that is, Assignee.\n After a committer is assigned with an issue, the following work is required:\n   Estimate whether it is a long-term issue. If it is, please label it as pending; Add issue labels, such as bug, enhancement, discussion, etc; Add milestone.  Notice: Whether it is a community issue or not, there must be Assignee until the issue is completed.\n","date":1554768000,"description":"Apache ShenYu Committer's Guide","dir":"community/committer/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f44374337804e9f8e3a7e125c830c6508eb4b4e2","permalink":"/community/committer/","publishdate":"2019-04-09T00:00:00Z","readingtime":1,"relpermalink":"/community/committer/","summary":"Committer Promotion After you have made a lot of contributions, the community will nominate. Become a committer you will have\n Permissions written by ShenYu repository Idea is used legally  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  A committer needs to review every day the Pull Request and issue list to be processed by the community, and assign a suitable committer, that is, Assignee.","tags":["Committer"],"title":"Apache ShenYu Committer","type":"community","url":"/community/committer/","wordcount":149},{"author":"xiaoyu","categories":"Apache ShenYu","content":" 提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有\n shenyu仓库写的权限 idea 正版使用  提交者责任  开发新功能； 代码重构； 及时和可靠的评审Pull Request； 思考和接纳新特性请求； 解答问题； 维护文档和代码示例； 改进流程和工具； 引导新的参与者融入社区。  日常工作  committer需要每天查看社区待处理的Pull Request和issue列表，指定给合适的committer，即assignee。\n assignee在被分配issue后，需要进行如下判断：\n 判断是否是长期issue，如是，则标记为pending。 判断issue类型，如：bug，enhancement，discussion等。 判断Milestone，并标记。   注意\n无论是否是社区issue，都必须有assignee，直到issue完成。\n","date":1554768000,"description":"Apache shenyu-committer提交者指南","dir":"community/committer/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bae0cef61b35dccd484146aa60358356a1a18576","permalink":"/zh/community/committer/","publishdate":"2019-04-09T00:00:00Z","readingtime":1,"relpermalink":"/zh/community/committer/","summary":"提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有 shenyu仓库写的权限 idea 正版使用 提交者责任 开发新功能； 代码重","tags":["Committer"],"title":"Apache ShenYu Committer","type":"community","url":"/zh/community/committer/","wordcount":359},{"author":"xiaoyu","categories":"Apache ShenYu","content":" You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title. Fill in necessary information according to the template. Choose a label after the issue is created, for example: bug，enhancement，discussion. Please pay attention to your issue, you may need to provide more information during discussion.  Developer Flow Fork ShenYu repo\n Fork a ShenYu repo to your own repo to work, then setting upstream.  git remote add upstream https://github.com/apache/incubator-shenyu.git  Choose Issue\n Please choose the issue to be edited. If it is a new issue discovered or a new function enhancement to offer, please create an issue and set the right label for it. After choosing the relevant issue, please reply with a deadline to indicate that you are working on it.  Create Branch\n Switch to forked master branch, pull codes from upstream, then create a new branch.  git checkout master git pull upstream master git checkout -b issueNo  Notice ：We will merge PR using squash, commit log will be different from upstream if you use the old branch.\nCoding\n Please obey the Code of Conduct during the process of development and finish the check before submitting the pull request. push code to your fork repo.  git add modified-file-names git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  Submit Pull Request\n Send a pull request to the master branch. The mentor will do code review before discussing some details (including the design, the implementation and the performance) with you. The request will be merged into the branch of current development version after the edit is well enough. At last, congratulate to be an official contributor of ShenYu.  Delete Branch\n You can delete the remote branch (origin/issueNo) and the local branch (issueNo) associated with the remote branch (origin/issueNo) after the mentor merged the pull request into the master branch of ShenYu.  git checkout master git branch -d issueNo git push origin --delete issueNo  Notice: Please note that in order to show your id in the contributor list, don\u0026amp;rsquo;t forget the configurations below:\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  FAQ\n After each Pull Request (PR), you need to execute the following operations, otherwise, the previous PR commit records will be mixed with this PR commit records. The specific operation process is as follows:  git checkout master git fetch upstream git reset --hard upstream/master git push -f  ","date":1554768000,"description":"Apache ShenYu Contributor's Guide","dir":"community/contributor/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"2c389d2bd468152d1dcf31b15437678c15f345af","permalink":"/community/contributor/","publishdate":"2019-04-09T00:00:00Z","readingtime":3,"relpermalink":"/community/contributor/","summary":"You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title.","tags":["Contributor"],"title":"Apache ShenYu Contributor","type":"community","url":"/community/contributor/","wordcount":447},{"author":"xiaoyu","categories":"ShenYu","content":" 您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。\n提交issue  在提交issue之前，请经过充分的搜索，确定该issue不是通过简单的检索即可以解决的问题。 查看issue列表，确定该issue不是一个重复的问题。 新建一个issue并选择您的issue类型。 使用一个清晰并有描述性的标题来定义issue。 根据模板填写必要信息。 在提交issue之后，对该issue分配合适的标签。如：bug，enhancement，discussion等。 请对自己提交的issue保持关注，在讨论中进一步提供必要信息。  开发流程 Fork分支到本地\n 从 ShenYu 的repo上fork一个分支到您自己的repo来开始工作，并设置upstream为 ShenYu 的repo。  git remote add upstream https://github.com/apache/incubator-shenyu.git  选择issue\n 请在选择您要修改的issue。如果是您新发现的问题或想提供issue中没有的功能增强，请先新建一个issue并设置正确的标签。 在选中相关的issue之后，请回复以表明您当前正在这个issue上工作。并在回复的时候为自己设置一个deadline，添加至回复内容中。  创建分支\n 切换到fork的master分支，拉取最新代码，创建本次的分支。  git checkout master git pull upstream master git checkout -b issueNo  注意 ：PR会按照squash的方式进行merge，如果不创建新分支，本地和远程的提交记录将不能保持同步。\n编码\n 请您在开发过程中遵循 ShenYu 的 开发规范。并在准备提交pull request之前完成相应的检查。 将修改的代码push到fork库的分支上。  git add 修改代码 git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  提交PR\n 发送一个pull request到 ShenYu 的master分支。 接着导师做CodeReview，然后他会与您讨论一些细节（包括设计，实现，性能等）。当导师对本次修改满意后，会将提交合并到当前开发版本的分支中。 最后，恭喜您已经成为了ShenYu的贡献者！  删除分支\n 在导师将pull request合并到 ShenYu 的master分支中之后，您就可以将远程的分支（origin/issueNo）及与远程分支（origin/issueNo）关联的本地分支（issueNo）删除。  git checkout master git branch -d issueNo git push origin --delete issueNo  注意\n为了让您的id显示在contributor列表中，别忘了以下设置：\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  常见问题\n 每次Pull Request(PR)后,你需要执行以下操作,否则,之前PR的提交记录会和这次的提交记录混在一起,具体操作流程如下:  git checkout master git fetch upstream git reset --hard upstream/master git push -f  ","date":1554768000,"description":"Apache shenyu-contributor贡献者指南","dir":"community/contributor/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e1fd990481d2f9589fc61eef9848665a07131b69","permalink":"/zh/community/contributor/","publishdate":"2019-04-09T00:00:00Z","readingtime":3,"relpermalink":"/zh/community/contributor/","summary":"您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。 提交issue 在提交issue之前，请经过充分的搜索，确定该iss","tags":["Contributor"],"title":"Apache ShenYu Contributor","type":"community","url":"/zh/community/contributor/","wordcount":1014},{"author":"xiaoyu","categories":"Apache ShenYu","content":" ShenYu Gateway released version 1.0.4-RELEASE  Fix the bug that appeared in the Soul-admin of version 1.0.3. The serialization method supports custom extensions. The default serialization method has been changed from Kroy to Java serialization method. Dubbo support.  Changes Dubbo usage  In the previous version (1.0.2 or 1.0.3), the parameters of Dubbo are passed through the header, and in the 1.0.4 version it is passed through the body.\n Relevant document information has been updated.\n  Recommendations on using version 1.0.4  Version 1.0.4 supports user-defined plug-in, and supports regular expression matching.\n The change of Dubbo parameter transfer and it would be more friendly to use.\n  If you used version 1.0.2 before and want to update to version 1.0.4.  Add role field in the plug-in table.\n Restart the Soul-admin of version 1.0.4.\n Perform synchronization of all plug-ins (because of serialization changes)\n Start the soul-web service of version 1.0.4.\n  For more information  QQ group: 429951241\n Official website document: https://dromara.org/website/zh-cn/docs/soul/soul.html\n Github: https://github.com/apache/incubator-shenyu\n Gitee: https://gitee.com/dromara/soul\n  ","date":1554768000,"description":"Apache ShenYu Gateway released version 1.0.4-RELEASE","dir":"community/shenyu-1.0.4/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"58853467dc4538e5a9e98bf530e40a2beadf1a1d","permalink":"/community/shenyu-1.0.4/","publishdate":"2019-04-09T00:00:00Z","readingtime":1,"relpermalink":"/community/shenyu-1.0.4/","summary":"ShenYu Gateway released version 1.0.4-RELEASE  Fix the bug that appeared in the Soul-admin of version 1.0.3. The serialization method supports custom extensions. The default serialization method has been changed from Kroy to Java serialization method. Dubbo support.  Changes Dubbo usage  In the previous version (1.0.2 or 1.0.3), the parameters of Dubbo are passed through the header, and in the 1.0.4 version it is passed through the body.","tags":["Apache ShenYu"],"title":"Apache ShenYu Gateway released version 1.0.4-RELEASE","type":"community","url":"/community/shenyu-1.0.4/","wordcount":158},{"author":"xiaoyu","categories":"Apache ShenYu","content":" ShenYu网关发布1.0.4-RELEASE版本  修复在1.0.3版本的后台管理中，出现的bug。 配置信息序列化方式支持自定义扩展。默认的序列化方式由kroy 改为了java序列化方式。 dubbo框架支持的更改。  对dubbo用户使用的更改。  在以前的版本中（1.0.2 or 1.0.3），dubbo的参数是通过header头上传递，在1.0.4版本中是通过body传递\n 更新了相关的文档信息。\n  关于使用1.0.4版本的建议。  1.0.4 版本支持用户自定义插件开发，支持正则表达式的匹配。\n dubbo参数传递的更改，我觉得这样会更加友好。\n  如果您之前使用的1.0.2版本，想要更新到1.0.4版本。  在插件表新增role字段。\n 重新启动1.0.4版本的管理后台。\n 执行同步所有插件（因为序列化方式的更改）\n 启动1.0.4版本的soul-web服务。\n  遇到问题？  添加qq群（429951241）\n 官网文档：https://dromara.org/website/zh-cn/docs/soul/soul.html\n github地址: https://github.com/apache/incubator-shenyu\n gitee地址： https://gitee.com/dromara/soul\n  ","date":1554768000,"description":"Apache ShenYu网关发布1.0.4-RELEASE版本","dir":"community/shenyu-1.0.4/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"ca97433b64733d5e662f684331928aa3ce223e63","permalink":"/zh/community/shenyu-1.0.4/","publishdate":"2019-04-09T00:00:00Z","readingtime":1,"relpermalink":"/zh/community/shenyu-1.0.4/","summary":"ShenYu网关发布1.0.4-RELEASE版本 修复在1.0.3版本的后台管理中，出现的bug。 配置信息序列化方式支持自定义扩展。默认的序","tags":["ShenYu"],"title":"Apache ShenYu网关发布1.0.4-RELEASE版本","type":"community","url":"/zh/community/shenyu-1.0.4/","wordcount":454},{"author":null,"categories":null,"content":" Description  This document focuses on how to access gateways for HTTP services in other languages. How to customize the development of soul-http-client.  Customize Http Client  Request Method: POST Request Path: http://soul-admin/soul-client/springmvc-register, soul-admin represents IP + Port of admin Request Params：passing JSON type parameters through the body.  { \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;context\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //required \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //required \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;port\u0026amp;quot;: xxx, //required \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //required \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //required }  ","date":-62135596800,"description":"A multilingual HTTP client","dir":"projects/shenyu-2.3.0/developer-soul-client/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"daafb93e6ac8c863d340f3a29d01103ac20f762c","permalink":"/projects/shenyu-2.3.0/developer-soul-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/developer-soul-client/","summary":" Description  This document focuses on how to access gateways for HTTP services in other languages. How to customize the development of soul-http-client.  Customize Http Client  Request Method: POST Request Path: http://soul-admin/soul-client/springmvc-register, soul-admin represents IP + Port of admin Request Params：passing JSON type parameters through the body.  { \u0026quot;appName\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;context\u0026quot;: \u0026quot;/xxx\u0026quot;, //required \u0026quot;path\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;pathDesc\u0026quot;: \u0026quot;xxx\u0026quot;, \u0026quot;rpcType\u0026quot;: \u0026quot;http\u0026quot;, //required \u0026quot;host\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;port\u0026quot;: xxx, //required \u0026quot;ruleName\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;enabled\u0026quot;: \u0026quot;true\u0026quot;, //required \u0026quot;registerMetaData\u0026quot;: \u0026quot;true\u0026quot; //required }  ","tags":null,"title":"A multilingual HTTP client","type":"projects","url":"/projects/shenyu-2.3.0/developer-soul-client/","wordcount":77},{"author":null,"categories":null,"content":" Description  This document focuses on how to access gateways for HTTP services in other languages. How to customize the development of shenyu-http-client.  Customize Http Client  Request Method: POST Request Path: http://soul-admin/soul-client/springmvc-register, shenyu-admin represents IP + Port of admin Request Params：passing JSON type parameters through the body.  { \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;context\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //required \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //required \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;port\u0026amp;quot;: xxx, //required \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //required \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //required \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //required }  ","date":-62135596800,"description":"A multilingual HTTP client","dir":"projects/shenyu/developer-shenyu-client/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"44c76be8713cdf61362b91486fdb01cee96068b9","permalink":"/projects/shenyu/developer-shenyu-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/developer-shenyu-client/","summary":" Description  This document focuses on how to access gateways for HTTP services in other languages. How to customize the development of shenyu-http-client.  Customize Http Client  Request Method: POST Request Path: http://soul-admin/soul-client/springmvc-register, shenyu-admin represents IP + Port of admin Request Params：passing JSON type parameters through the body.  { \u0026quot;appName\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;context\u0026quot;: \u0026quot;/xxx\u0026quot;, //required \u0026quot;path\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;pathDesc\u0026quot;: \u0026quot;xxx\u0026quot;, \u0026quot;rpcType\u0026quot;: \u0026quot;http\u0026quot;, //required \u0026quot;host\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;port\u0026quot;: xxx, //required \u0026quot;ruleName\u0026quot;: \u0026quot;xxx\u0026quot;, //required \u0026quot;enabled\u0026quot;: \u0026quot;true\u0026quot;, //required \u0026quot;registerMetaData\u0026quot;: \u0026quot;true\u0026quot; //required }  ","tags":null,"title":"A multilingual HTTP client","type":"projects","url":"/projects/shenyu/developer-shenyu-client/","wordcount":77},{"author":null,"categories":null,"content":" What is the Aapche ShenYu? This is an asynchronous, high-performance, cross-language, responsive API gateway.\nFeatures  Support various languages (http protocol), support Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars and other protocols. Plugin design idea, plugin hot swap, easy to expand. Flexible flow filtering to meet various flow control. Built-in rich plugin support, authentication, limiting, fuse, firewall, etc. Dynamic flow configuration, high performance. Support cluster deployment, A/B Test, blue-green release.  Architecture Diagram ","date":-62135596800,"description":"This is an asynchronous, high-performance, cross-language, responsive API gateway.","dir":"projects/shenyu/overview/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"2dd558ddaae88e41b15c072473437506b43637e7","permalink":"/projects/shenyu/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/overview/","summary":" What is the Aapche ShenYu? This is an asynchronous, high-performance, cross-language, responsive API gateway.\nFeatures  Support various languages (http protocol), support Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars and other protocols. Plugin design idea, plugin hot swap, easy to expand. Flexible flow filtering to meet various flow control. Built-in rich plugin support, authentication, limiting, fuse, firewall, etc. Dynamic flow configuration, high performance. Support cluster deployment, A/B Test, blue-green release.  Architecture Diagram ","tags":null,"title":"Aapche ShenYu Introduction","type":"projects","url":"/projects/shenyu/overview/","wordcount":70},{"author":null,"categories":null,"content":" 什么是 Apache ShenYu 这是一个异步的，高性能的，跨语言的，响应式的API网关。\n功能  支持各种语言(http 协议)，支持 Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars 等协议。 插件化设计思想，插件热插拔，易扩展。 灵活的流量筛选，能满足各种流量控制。 内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。 流量配置动态化，性能极高。 支持集群部署，支持 A/B Test，蓝绿发布。  架构图 ","date":-62135596800,"description":"Apache ShenYu 是一个异步的，高性能的，跨语言的，响应式的API网关。","dir":"projects/shenyu/overview/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"13c522ca9a06a483e1ee3a2054870d86c1507358","permalink":"/zh/projects/shenyu/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/overview/","summary":"什么是 Apache ShenYu 这是一个异步的，高性能的，跨语言的，响应式的API网关。 功能 支持各种语言(http 协议)，支持 Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars 等协议。 插件化设计思想，","tags":null,"title":"Apache ShenYu 介绍","type":"projects","url":"/zh/projects/shenyu/overview/","wordcount":159},{"author":null,"categories":null,"content":" Description  This article introduces the flow of synchronizing to the gateway after the data operation of admin backend system.  Usage  User can arbitrary modify data in soul-admin backend and this will immediately synchronize to the jvm memory of the gateway. Synchronize the plugin data of soul,selector,rule data, metadata, signature data, etc. All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.\n Data Flow Chart:   Feature  All the configurations of user can be dynamically updated, there is no need to restart the service for any modification. Local cache is used to provide efficient performance during high concurrency.  ","date":-62135596800,"description":"Configuration Flow Introduction","dir":"projects/shenyu-2.3.0/config/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"c78d27012bc61ebe8fff8cdb1e4fb4de99556bd1","permalink":"/projects/shenyu-2.3.0/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/config/","summary":"Description  This article introduces the flow of synchronizing to the gateway after the data operation of admin backend system.  Usage  User can arbitrary modify data in soul-admin backend and this will immediately synchronize to the jvm memory of the gateway. Synchronize the plugin data of soul,selector,rule data, metadata, signature data, etc. All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.","tags":null,"title":"Configuration Flow Introduction","type":"projects","url":"/projects/shenyu-2.3.0/config/","wordcount":103},{"author":null,"categories":null,"content":" Description  This article introduces the flow of synchronizing to the gateway after the data operation of shenyu-admin backend system.  Usage  User can arbitrary modify data in shenyu-admin backend and this will immediately synchronize to the jvm memory of the gateway. Synchronize the plugin data of ShenYu, selector,rule data, metadata, signature data, etc. All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.\n Data Flow Chart:   Feature  All the configurations of user can be dynamically updated, there is no need to restart the service for any modification. Local cache is used to provide efficient performance during high concurrency.  ","date":-62135596800,"description":"Configuration Flow Introduction","dir":"projects/shenyu/config/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b94018d451251358562e91b9dc461be91fb7f1fa","permalink":"/projects/shenyu/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/config/","summary":"Description  This article introduces the flow of synchronizing to the gateway after the data operation of shenyu-admin backend system.  Usage  User can arbitrary modify data in shenyu-admin backend and this will immediately synchronize to the jvm memory of the gateway. Synchronize the plugin data of ShenYu, selector,rule data, metadata, signature data, etc. All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.","tags":null,"title":"Configuration Flow Introduction","type":"projects","url":"/projects/shenyu/config/","wordcount":104},{"author":null,"categories":null,"content":" 说明  soul网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; context_path 设置为开启。 在网关的 pom.xml 文件中添加 context_path 的支持。 如果用户不需要，可以把插件禁用。  \u0026amp;lt;!-- soul context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul context_path plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。 只有匹配的请求，并且配置规则才会进行重写contextPath。  场景  顾名思义，context_path插件就是对uri的contextPath重新定义。 当匹配到请求后，设置自定义的contextPath，那么就会根据请求的Url截取自定义的contextPath获取真正的Url，例如请求路径为/soul/http/order， 配置的contextPath为/soul/http，那么真正请求的url为/order。  ","date":-62135596800,"description":"context_path插件","dir":"projects/shenyu-2.3.0/context-path-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7c010528f5dbaf23c35c4fdbff8e0fa9a679733a","permalink":"/zh/projects/shenyu-2.3.0/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/context-path-plugin/","summary":"说明 soul网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; context_path 设置为开启。 在网","tags":null,"title":"Context Path插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/context-path-plugin/","wordcount":340},{"author":null,"categories":null,"content":" 说明  ShenYu 网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; context_path 设置为开启。 在网关的 pom.xml 文件中添加 context_path 的支持。 如果用户不需要，可以把插件禁用。  \u0026amp;lt;!-- shenyu context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu context_path plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。 只有匹配的请求，并且配置规则才会进行重写contextPath。  场景  顾名思义，context_path插件就是对uri的contextPath重新定义。 当匹配到请求后，设置自定义的contextPath，那么就会根据请求的Url截取自定义的contextPath获取真正的Url，例如请求路径为/shenyu/http/order， 配置的contextPath为/shenyu/http，那么真正请求的url为/order。  ","date":-62135596800,"description":"context_path插件","dir":"projects/shenyu/context-path-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"f2e504196a26ad755b294543c02d1513e9950f7c","permalink":"/zh/projects/shenyu/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/context-path-plugin/","summary":"说明 ShenYu 网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; context_path 设置为开启。 在网关的 pom.xml","tags":null,"title":"Context Path插件","type":"projects","url":"/zh/projects/shenyu/context-path-plugin/","wordcount":341},{"author":null,"categories":null,"content":" Description  Plugins are core executors of soul gateway. Every plugin handles matched requests when enabled. There are two kinds of plugins in the soul gateway. The first type is a call chain with a single responsibility, and traffic cannot be customized. The other one can do its own chain of responsibility for matched traffic. You could reference from soul-plugin module and develop plugins by yourself. Please fire pull requests of your wonderful plugins without hesitate.  Single Responsibility Plugins  Add following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.SoulPlugin\n  public interface SoulPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link SoulPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, SoulPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must offer the right name. * if you impl AbstractSoulPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }  Detailed instruction of interface methods:\n execute() core method, you can do any task here freely. getOrder() get the order of current plugin. named() acquire the name of specific plugin. skip() determines whether this plugin should be skipped under certain conditions. Register plugin in Spring as a Bean, or simply apply @Component in implementation class.  @Bean public SoulPlugin a() { return new A(); }  Matching Traffic Processing Plugin  Introduce the following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add a new class A, inherit from org.dromara.soul.plugin.base.AbstractSoulPlugin\n examples down below:\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractSoulPlugin so you must user soul-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractSoulPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int */ @Override …","date":-62135596800,"description":"plugins","dir":"projects/shenyu-2.3.0/custom-plugin/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f123ad4e9cfcee7c7cd1be4eff8f164cd0529e3f","permalink":"/projects/shenyu-2.3.0/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu-2.3.0/custom-plugin/","summary":"Description  Plugins are core executors of soul gateway. Every plugin handles matched requests when enabled. There are two kinds of plugins in the soul gateway. The first type is a call chain with a single responsibility, and traffic cannot be customized. The other one can do its own chain of responsibility for matched traffic. You could reference from soul-plugin module and develop plugins by yourself. Please fire pull requests of your wonderful plugins without hesitate.","tags":null,"title":"Custom Plugin","type":"projects","url":"/projects/shenyu-2.3.0/custom-plugin/","wordcount":965},{"author":null,"categories":null,"content":" Description  Plugins are core executors of ShenYu gateway. Every plugin handles matched requests when enabled. There are two kinds of plugins in the ShenYu gateway. The first type is a call chain with a single responsibility, and traffic cannot be customized. The other one can do its own chain of responsibility for matched traffic. You could reference from shenyu-plugin module and develop plugins by yourself. Please fire pull requests of your wonderful plugins without hesitate.  Single Responsibility Plugins  Add following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.apache.shenyu.plugin.api.ShenyuPlugin\n  public interface ShenyuPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link ShenyuPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, ShenyuPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must offer the right name. * if you impl AbstractShenyuPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }  Detailed instruction of interface methods:\n execute() core method, you can do any task here freely. getOrder() get the order of current plugin. named() acquire the name of specific plugin. skip() determines whether this plugin should be skipped under certain conditions. Register plugin in Spring as a Bean, or simply apply @Component in implementation class.  @Bean public ShenyuPlugin a() { return new A(); }  Matching Traffic Processing Plugin  Introduce the following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add a new class A, inherit from org.apache.shenyu.plugin.base.AbstractShenyuPlugin\n examples down below:\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractShenyuPlugin so you must user shenyu-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractShenyuPlugin { /** * return plugin order . * The same plugin he executes in …","date":-62135596800,"description":"plugins","dir":"projects/shenyu/custom-plugin/","fuzzywordcount":900,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"582b2c8a5bdc8d074de1dd6d9b7ac37159d6e170","permalink":"/projects/shenyu/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu/custom-plugin/","summary":"Description  Plugins are core executors of ShenYu gateway. Every plugin handles matched requests when enabled. There are two kinds of plugins in the ShenYu gateway. The first type is a call chain with a single responsibility, and traffic cannot be customized. The other one can do its own chain of responsibility for matched traffic. You could reference from shenyu-plugin module and develop plugins by yourself. Please fire pull requests of your wonderful plugins without hesitate.","tags":null,"title":"Custom Plugin","type":"projects","url":"/projects/shenyu/custom-plugin/","wordcount":887},{"author":null,"categories":null,"content":" Description  This doc offers examples for customising response structure. The response body structure in gateways should be unified, it is recommended for specify yours.  Default Implementation  The default implementation class is org.dromara.soul.plugin.api.result.DefaultSoulResult. Following is the response structure.  public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   The returned json as follows:\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //response code, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //hint messages \u0026amp;quot;data\u0026amp;quot;: null // business data }  Extensions  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.result.SoulResult  public interface SoulResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  T is a generic parameter for your response data.\n Register defined class as a Spring Bean.\n  @Bean public SoulResult a() { return new A(); }  ","date":-62135596800,"description":"customising response structure","dir":"projects/shenyu-2.3.0/custom-result/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"0de8cb2334fdec26063242e7fca2228061798a75","permalink":"/projects/shenyu-2.3.0/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/custom-result/","summary":"Description This doc offers examples for customising response structure. The response body structure in gateways should be unified, it is recommended for specify yours. Default Implementation The default implementation class is org.dromara.soul.plugin.api.result.DefaultSoulResult. Following is the response structure. public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; } The returned json as follows: { \u0026quot;code\u0026quot;: -100, //response code,","tags":null,"title":"Custom Response","type":"projects","url":"/projects/shenyu-2.3.0/custom-result/","wordcount":211},{"author":null,"categories":null,"content":" Description  This doc offers examples for customising response structure. The response body structure in gateways should be unified, it is recommended for specify yours.  Default Implementation  The default implementation class is org.apache.shenyu.plugin.api.result.DefaultShenyuResult. Following is the response structure.  public class ShenyuDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   The returned json as follows:\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //response code, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //hint messages \u0026amp;quot;data\u0026amp;quot;: null // business data }  Extensions  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.apache.shenyu.plugin.api.result.ShenyuResult  public interface ShenyuResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  T is a generic parameter for your response data.\n Register defined class as a Spring Bean.\n  @Bean public ShenyuResult a() { return new A(); }  ","date":-62135596800,"description":"customising response structure","dir":"projects/shenyu/custom-result/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"83ee9894311cd22e471bb6ee12aecc2f3fcefde3","permalink":"/projects/shenyu/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/custom-result/","summary":"Description This doc offers examples for customising response structure. The response body structure in gateways should be unified, it is recommended for specify yours. Default Implementation The default implementation class is org.apache.shenyu.plugin.api.result.DefaultShenyuResult. Following is the response structure. public class ShenyuDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; } The returned json as follows: { \u0026quot;code\u0026quot;: -100, //response code,","tags":null,"title":"Custom Response","type":"projects","url":"/projects/shenyu/custom-result/","wordcount":211},{"author":null,"categories":null,"content":" Description  Users can customize the signature authentication algorithm to achieve verification.  Extension  The default implementation is org.dromara.soul.plugin.sign.service.DefaultSignService. Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.SignService.  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   When returning true in Pair, the sign verification passes. If there\u0026amp;rsquo;s false, the String in Pair will be return to the frontend to show. Register defined class as a Spring Bean.  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"specify sign plugins for examination","dir":"projects/shenyu-2.3.0/custom-sign-algorithm/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"74c5f20a09695491f8d6c939de32e64289ae8df3","permalink":"/projects/shenyu-2.3.0/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/custom-sign-algorithm/","summary":"Description  Users can customize the signature authentication algorithm to achieve verification.  Extension  The default implementation is org.dromara.soul.plugin.sign.service.DefaultSignService. Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.dromara.soul.plugin.api.SignService.  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026lt;Boolean, String\u0026gt; signVerify(ServerWebExchange exchange); }   When returning true in Pair, the sign verification passes. If there\u0026rsquo;s false, the String in Pair will be return to the frontend to show.","tags":null,"title":"Custom Sign Algorithm","type":"projects","url":"/projects/shenyu-2.3.0/custom-sign-algorithm/","wordcount":91},{"author":null,"categories":null,"content":" Description  Users can customize the signature authentication algorithm to achieve verification.  Extension  The default implementation is org.apache.shenyu.plugin.sign.service.DefaultSignService. Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.apache.shenyu.plugin.api.SignService.  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   When returning true in Pair, the sign verification passes. If there\u0026amp;rsquo;s false, the String in Pair will be return to the frontend to show. Register defined class as a Spring Bean.  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"specify sign plugins for examination","dir":"projects/shenyu/custom-sign-algorithm/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3eeff5e2f2615e81758fd9bbe05b1db91fabdd2c","permalink":"/projects/shenyu/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/custom-sign-algorithm/","summary":"Description  Users can customize the signature authentication algorithm to achieve verification.  Extension  The default implementation is org.apache.shenyu.plugin.sign.service.DefaultSignService. Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.apache.shenyu.plugin.api.SignService.  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026lt;Boolean, String\u0026gt; signVerify(ServerWebExchange exchange); }   When returning true in Pair, the sign verification passes. If there\u0026rsquo;s false, the String in Pair will be return to the frontend to show.","tags":null,"title":"Custom Sign Algorithm","type":"projects","url":"/projects/shenyu/custom-sign-algorithm/","wordcount":91},{"author":null,"categories":null,"content":" Description This article mainly explains three ways of database synchronization and their principles.\nPreface Gateway is the entrance of request and it is a very important part in micro service architecture, therefore the importance of gateway high availability is self-evident. When we use gateway, we have to change configuration such as flow rule, route rule for satisfying business requirement. Therefore, the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway. Then, how does Soul support dynamic configuration?\nAnyone who has used Soul knows, Soul plugin are hot swap,and the selector, rule of all plugins are dynamic configured, they take effect immediately without restarting service.But during using Soul gateway, users also report many problems\n Rely on zookeeper, this troubles users who use etcd consul and nacos registry Rely on redis,influxdb, I have not used the limiting plugin, monitoring plugin, why do I need these  Therefore,we have done a partial reconstruction of Soul,after two months of version iteration,we released version 2.0\n Data Synchronization removes the strong dependence on zookeeper,and we add http long polling and websocket Limiting plugin and monitoring plugin realize real dynamic configuration,we use admin backend for dynamic configuration instead of yml configuration before  Q: Someone may ask me,why don\u0026amp;rsquo;t you use configuration center for synchronization?\nFirst of all, it will add extra costs, not only for maintenance, but also make Soul heavy; In addition, using configuration center, data format is uncontrollable and it is not convenient for soul-admin to do configuration management.\nQ: Someone may also ask,dynamic configuration update?Every time I can get latest data from database or redis,why are you making it complicated?\nAs a gateway, soul cached all the configuration in the HashMap of JVM in order to provide higher response speed and we use local cache for every request, It\u0026amp;rsquo;s very fast. So this article can also be understood as three ways of memory synchronization in a distributed environment.\nPrinciple Analysis This is a HD uncoded image, it shows the flow of Soul data synchronization, when Soul gateway starts, it will synchronize configuration data from the configuration service and support push-pull mode to obtain configuration change information, and update the local cache.When administrator changes user,rule,plugin,flow configuration in the backend, modified information will synchronize to the Soul gateway through the push-pull mode,whether it is the push mode or the pull mode depends on the configuration.About the configuration synchronization module, it is actually a simplified configuration center. At version 1.x ,configuration service depends on zookeeper,management backend push the modified information to gateway.But version 2.x supports webosocket,http,zookeeper,it can specify the corresponding synchronization strategy through …","date":-62135596800,"description":"Data Synchronization Design","dir":"projects/shenyu-2.3.0/data-sync/","fuzzywordcount":1500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d163e4c3f0601bd91d72af43208076d621f82a75","permalink":"/projects/shenyu-2.3.0/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/projects/shenyu-2.3.0/data-sync/","summary":"Description This article mainly explains three ways of database synchronization and their principles.\nPreface Gateway is the entrance of request and it is a very important part in micro service architecture, therefore the importance of gateway high availability is self-evident. When we use gateway, we have to change configuration such as flow rule, route rule for satisfying business requirement. Therefore, the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway.","tags":null,"title":"Data Synchronization Design","type":"projects","url":"/projects/shenyu-2.3.0/data-sync/","wordcount":1423},{"author":null,"categories":null,"content":" Description This article mainly explains three ways of database synchronization and their principles.\nPreface Gateway is the entrance of request and it is a very important part in micro service architecture, therefore the importance of gateway high availability is self-evident. When we use gateway, we have to change configuration such as flow rule, route rule for satisfying business requirement. Therefore, the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway. Then, how does ShenYu support dynamic configuration?\nAnyone who has used ShenYu knows, ShenYu plugin are hot swap,and the selector, rule of all plugins are dynamic configured, they take effect immediately without restarting service.But during using ShenYu gateway, users also report many problems\n Rely on zookeeper, this troubles users who use etcd consul and nacos registry Rely on redis,influxdb, I have not used the limiting plugin, monitoring plugin, why do I need these  Therefore,we have done a partial reconstruction of ShenYu,after two months of version iteration,we released version 2.0\n Data Synchronization removes the strong dependence on zookeeper,and we add http long polling and websocket Limiting plugin and monitoring plugin realize real dynamic configuration,we use shenyu-admin backend for dynamic configuration instead of yml configuration before  Q: Someone may ask me,why don\u0026amp;rsquo;t you use configuration center for synchronization?\nFirst of all, it will add extra costs, not only for maintenance, but also make ShenYu heavy; In addition, using configuration center, data format is uncontrollable and it is not convenient for shenyu-admin to do configuration management.\nQ: Someone may also ask,dynamic configuration update?Every time I can get latest data from database or redis,why are you making it complicated?\nAs a gateway, ShenYu cached all the configuration in the HashMap of JVM in order to provide higher response speed and we use local cache for every request, It\u0026amp;rsquo;s very fast. So this article can also be understood as three ways of memory synchronization in a distributed environment.\nPrinciple Analysis This is a HD uncoded image, it shows the flow of ShenYu data synchronization, when ShenYu gateway starts, it will synchronize configuration data from the configuration service and support push-pull mode to obtain configuration change information, and update the local cache.When administrator changes user,rule,plugin,flow configuration in the backend, modified information will synchronize to the ShenYu gateway through the push-pull mode,whether it is the push mode or the pull mode depends on the configuration.About the configuration synchronization module, it is actually a simplified configuration center. At version 1.x ,configuration service depends on zookeeper,management backend push the modified information to gateway.But version 2.x supports webosocket,http,zookeeper,it can specify the corresponding synchronization …","date":-62135596800,"description":"Data Synchronization Design","dir":"projects/shenyu/data-sync/","fuzzywordcount":1500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"ae7826edaa2c2175d3b636eaa96d01eead65f3d0","permalink":"/projects/shenyu/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/projects/shenyu/data-sync/","summary":"Description This article mainly explains three ways of database synchronization and their principles.\nPreface Gateway is the entrance of request and it is a very important part in micro service architecture, therefore the importance of gateway high availability is self-evident. When we use gateway, we have to change configuration such as flow rule, route rule for satisfying business requirement. Therefore, the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway.","tags":null,"title":"Data Synchronization Design","type":"projects","url":"/projects/shenyu/data-sync/","wordcount":1422},{"author":null,"categories":null,"content":" Plugin use database to store plugin, selector, rule configuration data and relationship.\n The Database Table UML Diagram:  Detailed design:\n One plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n One selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a kind of data of JSON string type.You can view detail during the use of admin.\n Plugin use database to store user name,role,resource data and relationship.\n  The Permission Table UML Diagram:  Detailed design:\n one user corresponds to multiple role,one role corresponds to multiple resources.   ","date":-62135596800,"description":"Database Design","dir":"projects/shenyu-2.3.0/database-design/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"a1caeabda3611e85643d545ae186e246dc7c9a54","permalink":"/projects/shenyu-2.3.0/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/database-design/","summary":"Plugin use database to store plugin, selector, rule configuration data and relationship.\n The Database Table UML Diagram:  Detailed design:\n One plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n One selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a kind of data of JSON string type.You can view detail during the use of admin.","tags":null,"title":"Database Design","type":"projects","url":"/projects/shenyu-2.3.0/database-design/","wordcount":100},{"author":null,"categories":null,"content":" Plugin Design  Plugin use database to store plugin, selector, rule configuration data and relationship.\n The Database Table UML Diagram:  Detailed design:\n One plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n One selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a kind of data of JSON string type.You can view detail during the use of shenyu-admin.\n   Resource Permission Desgin  The resource are the menus and buttons in the shenyu-admin console.\n Resource Permission use database to store user name,role,resource data and relationship.\n The Resource Permission Table UML Diagram:  Detailed design:\n one user corresponds to multiple role,one role corresponds to multiple resources.   Data Permissin Design  Data Permission use database to store the relationship between users, selectors and rules.\n The Data Permission Table UML Diagram:  Detailed design:\n The most important table is data_permission, where a user corresponds to multiple data permissions. The field data_type distinguishes between different types of data, which corresponds to the following: 0 -\u0026amp;gt; selector, 1 -\u0026amp;gt; rule. The field data_id holds the primary key id of the corresponding type.   ","date":-62135596800,"description":"Database Design","dir":"projects/shenyu/database-design/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"34e1211b49c0aa4d244af09078a4ceec39ea8001","permalink":"/projects/shenyu/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/database-design/","summary":"Plugin Design  Plugin use database to store plugin, selector, rule configuration data and relationship.\n The Database Table UML Diagram:  Detailed design:\n One plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n One selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a kind of data of JSON string type.","tags":null,"title":"Database Design","type":"projects","url":"/projects/shenyu/database-design/","wordcount":188},{"author":null,"categories":null,"content":" Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql  CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;primary key id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;type\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary encoding\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary name\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary value\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary description or remarks\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;sort\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;whether it is enabled\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;   The current usage scenario is when the plugin handle configuring the data_type=3 (select box)  eg. degradeRuleGrade is one of fields of sentinel\u0026amp;rsquo;s handle json\nWhen it adds rules, it automatically looks up all the general dictionaries of type=\u0026#39;degradeRuleGrade\u0026#39; in the soul_dict table as a select-box when you edit the General rules field\n","date":-62135596800,"description":"dict management explanation","dir":"projects/shenyu-2.3.0/dictionary-management/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"bec5c40c0fa44eee99d6881771bd86be501be0ef","permalink":"/projects/shenyu-2.3.0/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/dictionary-management/","summary":"Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql  CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'primary key id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'type', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary encoding', `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary name', `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary value', `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary description or remarks', `sort` int(4) NOT NULL COMMENT 'sort', `enabled` tinyint(4) DEFAULT NULL COMMENT 'whether it is enabled', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;   The current usage scenario is when the plugin handle configuring the data_type=3 (select box)  eg.","tags":null,"title":"Dict Management","type":"projects","url":"/projects/shenyu-2.3.0/dictionary-management/","wordcount":175},{"author":null,"categories":null,"content":" Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql  CREATE TABLE IF NOT EXISTS `shenyu_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;primary key id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;type\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary encoding\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary name\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary value\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary description or remarks\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;sort\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;whether it is enabled\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;   The current usage scenario is when the plugin handle configuring the data_type=3 (select box)  eg. degradeRuleGrade is one of fields of Sentinel\u0026amp;rsquo;s handle json. When it adds rules, it automatically looks up all the general dictionaries of type=\u0026#39;degradeRuleGrade\u0026#39; in the shenyu_dict table as a select-box when you edit the General rules field.\n","date":-62135596800,"description":"dict management explanation","dir":"projects/shenyu/dictionary-management/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"698ebc2392639bd83b2fc21c5db29ccbc8be7409","permalink":"/projects/shenyu/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/dictionary-management/","summary":"Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql  CREATE TABLE IF NOT EXISTS `shenyu_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'primary key id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'type', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary encoding', `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary name', `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary value', `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary description or remarks', `sort` int(4) NOT NULL COMMENT 'sort', `enabled` tinyint(4) DEFAULT NULL COMMENT 'whether it is enabled', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;   The current usage scenario is when the plugin handle configuring the data_type=3 (select box)  eg.","tags":null,"title":"Dict Management","type":"projects","url":"/projects/shenyu/dictionary-management/","wordcount":175},{"author":null,"categories":null,"content":" Explanation  Divide is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing. Selectors and rules, please refer to: selector. Http configuration is the real invoked configuration after the gateway matches the traffic; You can set multiple configurations and concrete load balancing weights in the rules.  Configuration Detail:  The first box: hostName, generally fill in localhost, which is temporarily unused.\n The second box: http protocol, usually fill in http:// or https://, if not, the default is: http://. The third box: ip and port, where you fill in the ip+port of your real service. The fourth box: load balancing weight.\n  Ip + Port Detection  In soul-admin, there is a scheduled task to scan the configured ip and port. If it is found that the ip and port is offline, it will be removed. It can be configured as follows:    soul.upstream.check: true //Default is ture, if setting false, program will not detect. soul.upstream.scheduledTime: 10 //Timing detection interval, default 10 seconds.  ","date":-62135596800,"description":"divide plugin","dir":"projects/shenyu-2.3.0/divide-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"57ae2db71ce6a714bbe25e60cccb4fc2d4e890bf","permalink":"/projects/shenyu-2.3.0/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/divide-plugin/","summary":"Explanation  Divide is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, soul-admin \u0026ndash;\u0026gt; plugin management\u0026ndash;\u0026gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing.","tags":null,"title":"Divide Plugin","type":"projects","url":"/projects/shenyu-2.3.0/divide-plugin/","wordcount":218},{"author":null,"categories":null,"content":" Explanation  Divide is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing. Selectors and rules, please refer to: selector. Http configuration is the real invoked configuration after the gateway matches the traffic; You can set multiple configurations and concrete load balancing weights in the rules.  Configuration Detail:  The first box: hostName, generally fill in localhost, which is temporarily unused.\n The second box: http protocol, usually fill in http:// or https://, if not, the default is: http://. The third box: ip and port, where you fill in the ip+port of your real service. The fourth box: load balancing weight.\n  Ip + Port Detection  In shenyu-admin, there is a scheduled task to scan the configured ip and port. If it is found that the ip and port is offline, it will be removed. It can be configured as follows:    shenyu.upstream.check: true //Default is ture, if setting false, program will not detect. shenyu.upstream.scheduledTime: 10 //Timing detection interval, default 10 seconds.  ","date":-62135596800,"description":"divide plugin","dir":"projects/shenyu/divide-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"458b484dda606c55fa86e4a02681852ad13182eb","permalink":"/projects/shenyu/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/divide-plugin/","summary":"Explanation  Divide is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, shenyu-admin \u0026ndash;\u0026gt; plugin management\u0026ndash;\u0026gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing.","tags":null,"title":"Divide Plugin","type":"projects","url":"/projects/shenyu/divide-plugin/","wordcount":218},{"author":null,"categories":null,"content":" 说明  divide插件是网关处理 http协议请求的核心处理插件。  插件设置  开启插件，soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; divide 设置为启用。 divide插件，配合如下 starter一起才能生效，具体请看：http用户。  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件讲解  divide插件是进行http正向代理的插件，所有http类型的请求，都是由该插件进行负载均衡的调用。\n 选择器和规则，请详细看：选择器规则。\n http配置，是网关匹配到流量以后，真实调用的http配置，可以配置多个，设置负载均衡权重，具体的负载均衡策略，在规则中指定。\n 配置详解：\n 第一个框：hostName，一般填写 localhost，该字段暂时没使用。\n 第二个框：http协议，一般填写 http:// 或者 https:// ，不填写默认为:http://\n 第三个框：ip与端口，这里填写你真实服务的 ip + 端口。\n 第四个框：负载均衡权重。\n  ip + port 检测\n 在soul-admin 会有一个定时任务来扫描 配置的ip端口，如果发现下线，则会删除该 ip + port\n 可以进行如下配置 ：\n    soul.upstream.check:true 默认为 ture，设置为false，不检测 soul.upstream.scheduledTime:10 定时检测时间间隔，默认10秒  ","date":-62135596800,"description":"divide插件","dir":"projects/shenyu-2.3.0/divide-plugin/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"13aa319a0dd4d40939cc5402bbb07d960554a409","permalink":"/zh/projects/shenyu-2.3.0/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/divide-plugin/","summary":"说明 divide插件是网关处理 http协议请求的核心处理插件。 插件设置 开启插件，soul-admin \u0026ndash;\u0026gt; 插件管理\u0026ndash;\u0026gt; divide 设置为","tags":null,"title":"Divide插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/divide-plugin/","wordcount":475},{"author":null,"categories":null,"content":" 说明  divide插件是网关处理 http协议请求的核心处理插件。  插件设置  开启插件，shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; divide 设置为启用。 divide插件，配合如下 starter一起才能生效，具体请看：http用户。  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件讲解  divide插件是进行http正向代理的插件，所有http类型的请求，都是由该插件进行负载均衡的调用。\n 选择器和规则，请详细看：选择器规则。\n http配置，是网关匹配到流量以后，真实调用的http配置，可以配置多个，设置负载均衡权重，具体的负载均衡策略，在规则中指定。\n 配置详解：\n 第一个框：hostName，一般填写 localhost，该字段暂时没使用。\n 第二个框：http协议，一般填写 http:// 或者 https:// ，不填写默认为:http://\n 第三个框：ip与端口，这里填写你真实服务的 ip + 端口。\n 第四个框：负载均衡权重。\n  ip + port 检测\n 在shenyu-admin 会有一个定时任务来扫描 配置的ip端口，如果发现下线，则会删除该 ip + port\n 可以进行如下配置 ：\n    shenyu.upstream.check:true 默认为 ture，设置为false，不检测 shenyu.upstream.scheduledTime:10 定时检测时间间隔，默认10秒  ","date":-62135596800,"description":"divide插件","dir":"projects/shenyu/divide-plugin/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"304ba915811df5a8ca20e6dae609878b2993306a","permalink":"/zh/projects/shenyu/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/divide-plugin/","summary":"说明 divide插件是网关处理 http协议请求的核心处理插件。 插件设置 开启插件，shenyu-admin \u0026ndash;\u0026gt; 插件管理\u0026ndash;\u0026gt; divide 设","tags":null,"title":"Divide插件","type":"projects","url":"/zh/projects/shenyu/divide-plugin/","wordcount":479},{"author":null,"categories":null,"content":" PDF  English 中文  ","date":-62135596800,"description":"Doc Download","dir":"projects/shenyu-2.3.0/download/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d9bffd69fc77145442d3de7842c14c1e57d4cccd","permalink":"/projects/shenyu-2.3.0/download/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/download/","summary":"PDF English 中文","tags":null,"title":"Doc Download","type":"projects","url":"/projects/shenyu-2.3.0/download/","wordcount":4},{"author":null,"categories":null,"content":" Latest Releases Apache ShenYu is released as source code tarballs with corresponding binary tarballs for convenience.\nApache Shenyu - Version: 2.3.0 ( Release Date: Apr 2, 2020 )\n Source Codes: zip tar ShenYu-admin Binary Distribution: tar ShenYu-bootstrap Binary Distribution: tar  Apache Shenyu Dashboard - Version: 2.3.0 ( Release Date: Apr 2, 2020 )\n Source Codes: zip tar ShenYu-dashboard Binary Distribution: tar  PDF Apache ShenYu provides a packaged and downloaded PDF of the blog for users and developers to use.\n English  ","date":-62135596800,"description":"Doc Download","dir":"projects/shenyu/download/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"46a1f865d888f0a661894e4953a33d9f19143e20","permalink":"/projects/shenyu/download/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/download/","summary":"Latest Releases Apache ShenYu is released as source code tarballs with corresponding binary tarballs for convenience.\nApache Shenyu - Version: 2.3.0 ( Release Date: Apr 2, 2020 )\n Source Codes: zip tar ShenYu-admin Binary Distribution: tar ShenYu-bootstrap Binary Distribution: tar  Apache Shenyu Dashboard - Version: 2.3.0 ( Release Date: Apr 2, 2020 )\n Source Codes: zip tar ShenYu-dashboard Binary Distribution: tar  PDF Apache ShenYu provides a packaged and downloaded PDF of the blog for users and developers to use.","tags":null,"title":"Doc Download","type":"projects","url":"/projects/shenyu/download/","wordcount":80},{"author":null,"categories":null,"content":" Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol and it is also the key for gateway to realize dubbo generic service. Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData. Apache dubbo and alibaba dubbo users both use the same plugin.  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibab-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; dubbo setting enable.\n In the configuration of dubbo plugin, the configuration is as follows: Configure the registration center of dubbo.\n  {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   Plugin needs to cooperate with starter to take effect, please refer to: user-dubbo.\n Selectors and rules, please refer to: selector.\n  Metadata  Every dubbo interface method corresponds to a piece of metadata, which can be found in soul-admin \u0026amp;ndash;\u0026amp;gt;metadata management. Path: your http request. RPC extension parameters, corresponding to some configurations of dubbo interface; If you want to adjust, please modify here, which support json format like the following fields:  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}  ","date":-62135596800,"description":"dubbo plugin","dir":"projects/shenyu-2.3.0/dubbo-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d806bc5af3cc4706a9154688c64310966fea41df","permalink":"/projects/shenyu-2.3.0/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/dubbo-plugin/","summary":"Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol and it is also the key for gateway to realize dubbo generic service. Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData. Apache dubbo and alibaba dubbo users both use the same plugin.  \u0026lt;!--if you use dubbo start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-alibab-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; dubbo setting enable.","tags":null,"title":"Dubbo Plugin","type":"projects","url":"/projects/shenyu-2.3.0/dubbo-plugin/","wordcount":167},{"author":null,"categories":null,"content":" Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol and it is also the key for gateway to realize dubbo generic service. Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData. Apache dubbo and alibaba dubbo users both use the same plugin.  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-alibab-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; dubbo setting enable.\n In the configuration of dubbo plugin, the configuration is as follows: Configure the registration center of dubbo.\n  {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   Plugin needs to cooperate with starter to take effect, please refer to: user-dubbo.\n Selectors and rules, please refer to: selector.\n  Metadata  Every dubbo interface method corresponds to a piece of metadata, which can be found in shenyu-admin \u0026amp;ndash;\u0026amp;gt;metadata management. Path: your http request. RPC extension parameters, corresponding to some configurations of dubbo interface; If you want to adjust, please modify here, which support json format like the following fields:  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}  ","date":-62135596800,"description":"dubbo plugin","dir":"projects/shenyu/dubbo-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"63bb6768a47e6842f0b71eb3da6fb9308a5f2705","permalink":"/projects/shenyu/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/dubbo-plugin/","summary":"Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol and it is also the key for gateway to realize dubbo generic service. Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData. Apache dubbo and alibaba dubbo users both use the same plugin.  \u0026lt;!--if you use dubbo start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-alibab-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; dubbo setting enable.","tags":null,"title":"Dubbo Plugin","type":"projects","url":"/projects/shenyu/dubbo-plugin/","wordcount":167},{"author":null,"categories":null,"content":" 说明  此篇文章是 dubbo 用户使用 dubbo 插件支持，以及自己的 dubbo 服务接入 ShenYu 网关的教程。 支持 alibaba dubbo（\u0026amp;lt; 2.7.x） 以及 apache dubbo (\u0026amp;gt;=2.7.x)。 接入前，请正确的启动 shenyu-admin，以及搭建环境 Ok。  引入网关对dubbo支持的插件  在网关的 pom.xml 文件中增加如下依赖：\n alibaba dubbo 用户, dubbo 版本换成你的，注册中心的 jar 包换成你的，以下是参考。  \u0026amp;lt;!--shenyu alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   apache dubbo 用户，dubbo 版本换成你的，使用什么注册中心换成你的, 以下是参考≥≥使用什么注册中心，就引入啥。  \u0026amp;lt;!--shenyu apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency end --\u0026amp;gt;  重启网关服务。\n  dubbo 服务接入网关，可以参考：shenyu-examples-dubbo  alibaba dubbo …","date":-62135596800,"description":"dubbo 接入 ShenYu 网关","dir":"projects/shenyu/dubbo-proxy/","fuzzywordcount":2100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e13f0373c703c535c95c093e049e69f85ea21b54","permalink":"/zh/projects/shenyu/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/zh/projects/shenyu/dubbo-proxy/","summary":"说明 此篇文章是 dubbo 用户使用 dubbo 插件支持，以及自己的 dubbo 服务接入 ShenYu 网关的教程。 支持 alibaba dubbo（\u0026lt; 2.7.x） 以及 apache dubbo (\u0026gt;=2.7.x)","tags":null,"title":"Dubbo 接入 ShenYu 网关","type":"projects","url":"/zh/projects/shenyu/dubbo-proxy/","wordcount":2072},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Dubbo接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin和soul-bootstrap，另外如果你的dubbo如果使用zookeeper需提前下载启动。\n运行soul-examples-dubbo项目 下载soul-examples-dubbo，调整spring-dubbo.xml 的注册地址为你本地，如：\n\u0026amp;lt;dubbo:registry address=\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;/\u0026amp;gt;  运行TestApacheDubboApplicationmain方法启动dubbo项目。 成功启动会有如下日志：\n2021-02-06 20:58:01.807 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.entity.DubboTest\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.821 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Get all data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findAll\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.833 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Query by Id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findById\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;java.lang.String\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.844 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo …","date":-62135596800,"description":"Dubbo快速开始","dir":"projects/shenyu-2.3.0/quick-start-dubbo/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"4bf56b7ea80b05c62111be3172f7c20e78194d39","permalink":"/zh/projects/shenyu-2.3.0/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-dubbo/","summary":"本文档将演示了如何快速使用Dubbo接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动soul-ad","tags":null,"title":"Dubbo快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-dubbo/","wordcount":792},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Dubbo接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动shenyu-admin和shenyu-bootstrap，另外如果你的dubbo如果使用zookeeper需提前下载启动。\n运行shenyu-examples-dubbo项目 下载shenyu-examples-dubbo，调整spring-dubbo.xml 的注册地址为你本地，如：\n\u0026amp;lt;dubbo:registry address=\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;/\u0026amp;gt;  运行TestApacheDubboApplicationmain方法启动dubbo项目。 成功启动会有如下日志：\n2021-02-06 20:58:01.807 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.entity.DubboTest\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.821 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Get all data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findAll\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.833 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Query by Id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findById\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;java.lang.String\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.844 INFO 3724 --- [pool-2-thread-1] …","date":-62135596800,"description":"Dubbo快速开始","dir":"projects/shenyu/quick-start-dubbo/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5cc99a35ac9d3dd41ed57c7ce2dace4b4f8fd212","permalink":"/zh/projects/shenyu/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/quick-start-dubbo/","summary":"本文档将演示了如何快速使用Dubbo接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动sheny","tags":null,"title":"Dubbo快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-dubbo/","wordcount":805},{"author":null,"categories":null,"content":" 说明  此篇文章是dubbo用户使用dubbo插件支持，以及自己的dubbo服务接入soul网关的教程。 支持 alibaba dubbo（\u0026amp;lt; 2.7.x） 以及 apache dubbo (\u0026amp;gt;=2.7.x)。 接入前，请正确的启动 soul-admin，以及搭建环境 Ok。  引入网关对dubbo支持的插件  在网关的 pom.xml 文件中增加如下依赖：\n alibaba dubbo 用户, dubbo版本换成你的，注册中心的jar包换成你的，以下是参考。  \u0026amp;lt;!--soul alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   apache dubbo 用户，dubbo版本换成你的，使用什么注册中心换成你的,以下是参考,使用什么注册中心，就引入啥。  \u0026amp;lt;!--soul apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency end --\u0026amp;gt;  重启网关服务。\n  dubbo服务接入网关，可以参考：soul-examples-dubbo  alibaba dubbo 用户\n springboot\n 引入以下依赖   \u0026amp;lt;dependency\u0026amp;gt; …","date":-62135596800,"description":"dubbo接入soul网关","dir":"projects/shenyu-2.3.0/dubbo-proxy/","fuzzywordcount":2300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0ae4f65d2a363a984ef8897c5cf002b3ae5080f8","permalink":"/zh/projects/shenyu-2.3.0/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/zh/projects/shenyu-2.3.0/dubbo-proxy/","summary":"说明 此篇文章是dubbo用户使用dubbo插件支持，以及自己的dubbo服务接入soul网关的教程。 支持 alibaba dubbo（\u0026lt; 2.7.x） 以","tags":null,"title":"Dubbo接入soul网关","type":"projects","url":"/zh/projects/shenyu-2.3.0/dubbo-proxy/","wordcount":2282},{"author":null,"categories":null,"content":" 说明  dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。 dubbo插件需要配合元数据才能实现dubbo的调用，具体请看: 元数据。 apache dubbo 和 alibaba dubbo用户，都是使用该同一插件。  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; dubbo 设置为开启。\n 在dubbo插件的配置中，配置如下：配置dubbo的注册中心。\n{\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   插件需要配合依赖 starter 进行使用,具体请看：dubbo用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个dubbo接口方法，都会对应一条元数据，可以在 soul-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为dubbo接口的一些配置，调整的化，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}   ","date":-62135596800,"description":"dubbo插件","dir":"projects/shenyu-2.3.0/dubbo-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"6db660b27baee06b6d7a86778eb63ae4a73c5d45","permalink":"/zh/projects/shenyu-2.3.0/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/dubbo-plugin/","summary":"说明 dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。 dubbo插件需要配合元数据才能实现du","tags":null,"title":"Dubbo插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/dubbo-plugin/","wordcount":345},{"author":null,"categories":null,"content":" 说明  dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。 dubbo插件需要配合元数据才能实现dubbo的调用，具体请看: 元数据。 apache dubbo 和 alibaba dubbo用户，都是使用该同一插件。  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; dubbo 设置为开启。\n 在dubbo插件的配置中，配置如下：配置dubbo的注册中心。\n{\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   插件需要配合依赖 starter 进行使用,具体请看：dubbo用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个dubbo接口方法，都会对应一条元数据，可以在 shenyu-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为dubbo接口的一些配置，调整的化，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}   ","date":-62135596800,"description":"dubbo插件","dir":"projects/shenyu/dubbo-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"2d7b31a1c8d3f4abfad49191399d26c6c5a3bac8","permalink":"/zh/projects/shenyu/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/dubbo-plugin/","summary":"说明 dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。 dubbo插件需要配合元数据才能实现du","tags":null,"title":"Dubbo插件","type":"projects","url":"/zh/projects/shenyu/dubbo-plugin/","wordcount":345},{"author":null,"categories":null,"content":" Features  Soul is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With soul you can easily create application with your own gateway. System Requirement: JDK 1.8+, Mysql 5.5.20 +.  Soul-Admin remote download  2.3.0 download soul-admin-bin-2.3.0-RELEASE.tar.gz\n tar soul-admin-bin-2.3.0-RELEASE.tar.gz. cd /bin.\n use h2 store.\n\u0026amp;gt; windwos : start.bat --spring.profiles.active = h2 \u0026amp;gt; linux : ./start.sh --spring.profiles.active = h2  use mysql store. cd /conf and then modify mysql config in application.yaml.\n\u0026amp;gt; windwos : start.bat \u0026amp;gt; linux : ./start.sh   docker \u0026amp;gt; docker pull dromara/soul-admin \u0026amp;gt; docker network create soul   use h2 store\n\u0026amp;gt; docker run -d -p 9095:9095 --net soul dromara/soul-admin  use mysql store.\n\u0026amp;gt; docker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -d -p 9095:9095 --net soul dromara/soul-admin   If you want to override environment variables, you can do like this.\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -e \u0026amp;quot;spring.datasource.url=jdbc:mysql://192.168.1.9:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; -e \u0026amp;quot;spring.datasource.password=123456\u0026amp;quot; -d -p 9095:9095 --net soul dromara/soul-admin  Another way, bind volume and mounts\nPut your application.yml in xxx directory, then run like this.\ndocker run -v D:\\tmp\\conf:/opt/soul-admin/conf/ -d -p 9095:9095 --net soul dromara/soul-admin  local  download\n\u0026amp;gt; git clone https://github.com/dromara/soul.git \u0026amp;gt; cd soul \u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  setup for SoulAdminBootstrap.\n if use h2 store please set env --spring.profiles.active = h2\n if use mysql store, please modify mysql config in application.yaml.\n   Visit http://localhost:9095/index.html default username：admin password: 123456.\nSoul-Bootstrap remote download  2.3.0 download soul-bootstrap-bin-2.3.0-RELEASE.tar.gz\n tar soul-bootstrap-bin-2.3.0-RELEASE.tar.gz, ant then cd /bin.\n\u0026amp;gt; windwos : start.bat \u0026amp;gt; linux : ./start.sh   docker \u0026amp;gt; docker network create soul \u0026amp;gt; docker pull dromara/soul-bootstrap \u0026amp;gt; docker run -d -p 9195:9195 --net soul dromara/soul-bootstrap  local \u0026amp;gt; git clone https://github.com/dromara/soul.git \u0026amp;gt; cd soul \u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests   setup for SoulBootstrap.  Build your own gateway（recommend）  First of all, create a new Spring Boot project. You can refer to the way how you start the soul-bootstrap, or visit Spring Initializer\n Add these JAR into your Maven pom.xml:\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; …","date":-62135596800,"description":"Environment Setup","dir":"projects/shenyu-2.3.0/soul-set-up/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"e1895f7318e142e6f9dffcdd25ea1b2376d4288c","permalink":"/projects/shenyu-2.3.0/soul-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/soul-set-up/","summary":"Features Soul is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With soul you can easily create application with your own gateway. System Requirement: JDK 1.8+, Mysql 5.5.20 +. Soul-Admin remote download 2.3.0 download soul-admin-bin-2.3.0-RELEASE.tar.gz tar soul-admin-bin-2.3.0-RELEASE.tar.gz. cd /bin. use h2 store. \u0026gt; windwos : start.bat --spring.profiles.active = h2 \u0026gt; linux : ./start.sh --spring.profiles.active = h2 use mysql store. cd /conf and then modify mysql","tags":null,"title":"Environment Setup","type":"projects","url":"/projects/shenyu-2.3.0/soul-set-up/","wordcount":438},{"author":null,"categories":null,"content":" Features  ShenYu is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With shenyu you can easily create application with your own gateway. System Requirement: JDK 1.8+, Mysql 5.5.20 +.  Shenyu-Admin remote download  2.3.0 download shenyu-admin-bin-2.3.0-RELEASE.tar.gz\n tar shenyu-admin-bin-2.3.0-RELEASE.tar.gz. cd /bin.\n use h2 store.\n\u0026amp;gt; windwos : start.bat --spring.profiles.active = h2 \u0026amp;gt; linux : ./start.sh --spring.profiles.active = h2  use mysql store. cd /conf and then modify mysql config in application.yaml.\n\u0026amp;gt; windwos : start.bat \u0026amp;gt; linux : ./start.sh   docker \u0026amp;gt; docker pull dromara/shenyu-admin \u0026amp;gt; docker network create shenyu   use h2 store\n\u0026amp;gt; docker run -d -p 9095:9095 --net shenyu dromara/shenyu-admin  use mysql store.\n\u0026amp;gt; docker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -d -p 9095:9095 --net shenyu dromara/shenyu-admin   If you want to override environment variables, you can do like this.\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -e \u0026amp;quot;spring.datasource.url=jdbc:mysql://192.168.1.9:3306/shenyu?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; -e \u0026amp;quot;spring.datasource.password=123456\u0026amp;quot; -d -p 9095:9095 --net shenyu dromara/shenyu-admin  Another way, bind volume and mounts\nPut your application.yml in xxx directory, then run like this.\ndocker run -v D:\\tmp\\conf:/opt/shenyu-admin/conf/ -d -p 9095:9095 --net shenyu dromara/shenyu-admin  local  download\n\u0026amp;gt; git clone https://github.com/apache/incubator-shenyu.git \u0026amp;gt; cd shenyu \u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  setup for ShenyuAdminBootstrap.\n if use h2 store please set env --spring.profiles.active = h2\n if use mysql store, please modify mysql config in application.yaml.\n   Visit http://localhost:9095/index.html default username：admin password: 123456.\nShenyu-Bootstrap remote download  2.3.0 download shenyu-bootstrap-bin-2.3.0-RELEASE.tar.gz\n tar shenyu-bootstrap-bin-2.3.0-RELEASE.tar.gz, ant then cd /bin.\n\u0026amp;gt; windwos : start.bat \u0026amp;gt; linux : ./start.sh   docker \u0026amp;gt; docker network create shenyu \u0026amp;gt; docker pull dromara/shenyu-bootstrap \u0026amp;gt; docker run -d -p 9195:9195 --net shenyu dromara/shenyu-bootstrap  local \u0026amp;gt; git clone https://github.com/apache/incubator-shenyu.git \u0026amp;gt; cd shenyu \u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests   setup for ShenyuBootstrap.  Build your own gateway（recommend）  First of all, create a new Spring Boot project. You can refer to the way how you start the shenyu-bootstrap, or visit Spring Initializer\n Add these JAR into your Maven pom.xml:\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"Environment Setup","dir":"projects/shenyu/shenyu-set-up/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3baa6d293981a6335bd9442a65b277515bee0448","permalink":"/projects/shenyu/shenyu-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/shenyu-set-up/","summary":"Features ShenYu is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With shenyu you can easily create application with your own gateway. System Requirement: JDK 1.8+, Mysql 5.5.20 +. Shenyu-Admin remote download 2.3.0 download shenyu-admin-bin-2.3.0-RELEASE.tar.gz tar shenyu-admin-bin-2.3.0-RELEASE.tar.gz. cd /bin. use h2 store. \u0026gt; windwos : start.bat --spring.profiles.active = h2 \u0026gt; linux : ./start.sh --spring.profiles.active = h2 use mysql store. cd /conf and then modify mysql","tags":null,"title":"Environment Setup","type":"projects","url":"/projects/shenyu/shenyu-set-up/","wordcount":439},{"author":null,"categories":null,"content":" Description  This doc demonstrates how to get correct IP address and host when soul serves behind nginx reverse proxy. After fetched real IP and host, you can match them with plugins and selectors.  Default Implementation  The embedded implementation in soul is :org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  Implement through a Plugin  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.RemoteAddressResolver.  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   Register defined class as a Spring Bean.  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"Fetching correct IP address and host","dir":"projects/shenyu-2.3.0/custom-parsing-ip-and-host/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"e6a67b9d84e23654aad5726c2bd6902825912006","permalink":"/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","summary":"Description  This doc demonstrates how to get correct IP address and host when soul serves behind nginx reverse proxy. After fetched real IP and host, you can match them with plugins and selectors.  Default Implementation  The embedded implementation in soul is :org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  Implement through a Plugin  Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.","tags":null,"title":"Fetching Correct IP Address And Host","type":"projects","url":"/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","wordcount":118},{"author":null,"categories":null,"content":" Description  This doc demonstrates how to get correct IP address and host when ShenYu serves behind nginx reverse proxy. After fetched real IP and host, you can match them with plugins and selectors.  Default Implementation  The embedded implementation in ShenYu is :org.apache.shenyu.web.forward.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  Implement through a Plugin  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.apache.shenyu.plugin.api.RemoteAddressResolver.  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   Register defined class as a Spring Bean.  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"Fetching correct IP address and host","dir":"projects/shenyu/custom-parsing-ip-and-host/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d1b9f88c32a6bff21f94daec8607b7ffbdc04cb8","permalink":"/projects/shenyu/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/custom-parsing-ip-and-host/","summary":"Description  This doc demonstrates how to get correct IP address and host when ShenYu serves behind nginx reverse proxy. After fetched real IP and host, you can match them with plugins and selectors.  Default Implementation  The embedded implementation in ShenYu is :org.apache.shenyu.web.forward.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  Implement through a Plugin  Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.","tags":null,"title":"Fetching Correct IP Address And Host","type":"projects","url":"/projects/shenyu/custom-parsing-ip-and-host/","wordcount":118},{"author":null,"categories":null,"content":" description  This doc gives a brief description for uploading and downloading files using soul.  File Uploading  The default file size limit is 10M. For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30 Upload your files just as way you did before  File Downloading  Soul supports downloading files in streams. There is no need to change anything.  ","date":-62135596800,"description":"file uploading and downloading","dir":"projects/shenyu-2.3.0/file-and-image/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"a45d66f27cf1bd32100c924115891463daed3f48","permalink":"/projects/shenyu-2.3.0/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/file-and-image/","summary":" description  This doc gives a brief description for uploading and downloading files using soul.  File Uploading  The default file size limit is 10M. For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30 Upload your files just as way you did before  File Downloading  Soul supports downloading files in streams. There is no need to change anything.  ","tags":null,"title":"File Uploading And Downloading","type":"projects","url":"/projects/shenyu-2.3.0/file-and-image/","wordcount":58},{"author":null,"categories":null,"content":" description  This doc gives a brief description for uploading and downloading files using ShenYu.  File Uploading  The default file size limit is 10M. For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30 Upload your files just as way you did before  File Downloading  ShenYu supports downloading files in streams. There is no need to change anything.  ","date":-62135596800,"description":"file uploading and downloading","dir":"projects/shenyu/file-and-image/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d6b436602a9ad56f7e28c0912b3fba438e9eea82","permalink":"/projects/shenyu/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/file-and-image/","summary":" description  This doc gives a brief description for uploading and downloading files using ShenYu.  File Uploading  The default file size limit is 10M. For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30 Upload your files just as way you did before  File Downloading  ShenYu supports downloading files in streams. There is no need to change anything.  ","tags":null,"title":"File Uploading And Downloading","type":"projects","url":"/projects/shenyu/file-and-image/","wordcount":58},{"author":null,"categories":null,"content":" Description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS Support  org.dromara.soul.bootstrap.cors.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   Registering CrossFilter as a Spring Bean and you are ready to go.  Filtering Spring Boot health check  You can control the order by applying @Order to the implementation class .  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  Extending org.dromara.soul.web.filter.AbstractWebFilter  Add a new class and inherit from org.dromara.soul.web.filter.AbstractWebFilter. Implement abstract methods of parent class.  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute …","date":-62135596800,"description":"filter extension","dir":"projects/shenyu-2.3.0/custom-filter/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b65a3b806a31f650fd6e6a4dab727ec884749ade","permalink":"/projects/shenyu-2.3.0/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/custom-filter/","summary":"Description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS Support  org.dromara.soul.bootstrap.cors.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final String ALLOWED_EXPOSE = \u0026quot;*\u0026quot;; private static final String MAX_AGE = \u0026quot;18000\u0026quot;; @Override @SuppressWarnings(\u0026quot;all\u0026quot;) public Mono\u0026lt;Void\u0026gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.","tags":null,"title":"Filter Extension","type":"projects","url":"/projects/shenyu-2.3.0/custom-filter/","wordcount":343},{"author":null,"categories":null,"content":" Description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS Support  org.apache.shenyu.web.filter.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   Registering CrossFilter as a Spring Bean and you are ready to go.  Filtering Spring Boot health check  You can control the order by applying @Order to the implementation class .  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  Extending org.apache.shenyu.web.filter.AbstractWebFilter  Add a new class and inherit from org.apache.shenyu.web.filter.AbstractWebFilter. Implement abstract methods of parent class.  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute …","date":-62135596800,"description":"filter extension","dir":"projects/shenyu/custom-filter/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"87469a832991c92be15e48f2cb568ef2e389db64","permalink":"/projects/shenyu/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/custom-filter/","summary":"Description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS Support  org.apache.shenyu.web.filter.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final String ALLOWED_EXPOSE = \u0026quot;*\u0026quot;; private static final String MAX_AGE = \u0026quot;18000\u0026quot;; @Override @SuppressWarnings(\u0026quot;all\u0026quot;) public Mono\u0026lt;Void\u0026gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.","tags":null,"title":"Filter Extension","type":"projects","url":"/projects/shenyu/custom-filter/","wordcount":343},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Grpc接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin和soul-bootstrap。\n注：soul-bootstrap需要引入grpc依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  运行soul-examples-grpc项目 下载soul-examples-grpc\n在soul-examples-grpc下执行以下命令生成java代码\nmvn protobuf:compile //编译消息对象 mvn protobuf:compile-custom //依赖消息对象,生成接口服务  运行org.dromara.soul.examples.grpc.SoulTestGrpcApplicationmain方法启动项目。\n成功启动会有如下日志：\n2021-02-10 01:57:02.154 INFO 76 --- [ main] o.d.s.e.grpc.SoulTestGrpcApplication : Started SoulTestGrpcApplication in 2.088 seconds (JVM running for 3.232) 2021-02-10 01:57:02.380 INFO 76 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;echo.EchoService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;echo.EchoRequest,io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true}  Grpc 插件设置  在 soul-admin 插件管理中，把grpc 插件设置为开启。  测试 soul-examples-grpc项目成功启动之后会自动把加 @SoulGrpcClient 注解的接口方法注册到网关。\n打开插件管理-\u0026amp;gt;grpc可以看到插件规则配置列表\n下面使用postman模拟http的方式来请求你的grpc服务\n","date":-62135596800,"description":"Grpc快速开始","dir":"projects/shenyu-2.3.0/quick-start-grpc/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"6a8e9ed4e9456bb8226715cbcdb3cf4cafd23d55","permalink":"/zh/projects/shenyu-2.3.0/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-grpc/","summary":"本文档将演示了如何快速使用Grpc接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动soul-adm","tags":null,"title":"Grpc快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-grpc/","wordcount":462},{"author":null,"categories":null,"content":" 说明  本文旨在帮助 http 用户。 ShenYu 网关使用 divide 插件来处理 http 请求。请求在 shenyu-admin 后台开启它。 接入前，请正确的启动 shenyu-admin，以及 搭建环境 OK。  引入网关对http的代理插件  在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   当然是要重新启动网关。  Http请求接入网关（springMvc 体系用户）  首先要确保在 shenyu-admin 后台 divide 插件是否开启。  Shenyu-Client 接入方式。 （此方式针对 SpringMvc, SpringBoot 用户）  SpringBoot 用户\n 在你的真实服务的 pom.xml 新增如下依赖:  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入.\n SpringMvc 用户\n 在你的真实服务的 pom.xml 新增如下依赖：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的 bean 定义的 xml 文件中新增如下：  \u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.apache.shenyu.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.apache.shenyu.register.common.config.ShenyuRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/你的contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;你的名字\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;你的端口\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   在你的 controller 的接口上加上 @ShenyuSpringMvcClient 注解。\n 你可以把注解加到 Controller 类上面，里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理。\n 举例子（1）： 代表 /test/payment，/test/findByUserId 都会被网关代理。\n  @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @ShenyuSpringMvcClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026amp;quot;hello world\u0026amp;quot;); return userDTO; } }   举例子（2）：代表 /order/save，会被网关代理，而 /order/findById 则不会。  @RestController @RequestMapping(\u0026amp;quot;/order\u0026amp;quot;) …","date":-62135596800,"description":"http 用户","dir":"projects/shenyu/http-proxy/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3b8befda4ede12fcd6c0436c4efc87b6f7c1c09b","permalink":"/zh/projects/shenyu/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/http-proxy/","summary":"说明 本文旨在帮助 http 用户。 ShenYu 网关使用 divide 插件来处理 http 请求。请求在 shenyu-admin 后台开启它。 接入前，请正确的启动 shenyu-admin，以及 搭建环境 OK。 引","tags":null,"title":"Http 用户","type":"projects","url":"/zh/projects/shenyu/http-proxy/","wordcount":1077},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Http请求接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin。\n引入网关对http的代理插件\n 在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  启动soul-bootstrap项目。\n运行soul-examples-http项目 下载soul-examples-http\n运行org.dromara.soul.examples.http.SoulTestHttpApplicationmain方法启动项目。\n成功启动会有如下日志：\n2021-02-10 00:57:07.561 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.577 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Save order\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.587 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.596 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.606 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: …","date":-62135596800,"description":"Http快速开始","dir":"projects/shenyu-2.3.0/quick-start-http/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"82ee1b5e85f4856aac4b9f2d783d6f9539fca820","permalink":"/zh/projects/shenyu-2.3.0/quick-start-http/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-http/","summary":"本文档将演示了如何快速使用Http请求接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动soul-a","tags":null,"title":"Http快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-http/","wordcount":515},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Http请求接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动shenyu-admin。\n引入网关对http的代理插件\n 在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  启动shenyu-bootstrap项目。\n运行shenyu-examples-http项目 下载shenyu-examples-http\n运行org.apache.shenyu.examples.http.ShenyuTestHttpApplicationmain方法启动项目。\n成功启动会有如下日志：\n2021-02-10 00:57:07.561 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.577 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Save order\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.587 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.596 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.606 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: …","date":-62135596800,"description":"Http快速开始","dir":"projects/shenyu/quick-start-http/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"27ab4777b2881c2491bec1e2346d9286aaf10590","permalink":"/zh/projects/shenyu/quick-start-http/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/quick-start-http/","summary":"本文档将演示了如何快速使用Http请求接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动shen","tags":null,"title":"Http快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-http/","wordcount":530},{"author":null,"categories":null,"content":" 说明  本文旨在帮助http用户。 soul网关使用 divide 插件来处理http请求。请求在soul-admin后台开启它。 接入前，请正确的启动 soul-admin，以及 搭建环境 OK。  引入网关对http的代理插件  在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   当然是要重新启动网关。  Http请求接入网关（springMvc体系用户）  首先要确保在 soul-admin 后台 divide插件是否开启。  Soul-Client接入方式。 （此方式针对SpringMvc,SpringBoot用户）  SpringBoot用户\n 在你的真实服务的 pom.xml 新增如下依赖:   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入.\n SpringMvc用户\n 在你的真实服务的 pom.xml 新增如下依赖：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的 bean定义的xml文件中新增如下：\n  \u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.register.common.config.SoulRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/你的contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;你的名字\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;你的端口\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   在你的 controller 的接口上加上 @SoulSpringMvcClient 注解。\n 你可以把注解加到 Controller 类上面，里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理。\n 举例子 （1）： 代表 /test/payment，/test/findByUserId 都会被网关代理。\n  @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @SoulSpringMvcClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026amp;quot;hello world\u0026amp;quot;); return userDTO; } }   举例子 （2）：代表 /order/save，会被网关代理，而/order/findById 则不会。   @RestController @RequestMapping(\u0026amp;quot;/order\u0026amp;quot;) @SoulSpringMvcClient(path = \u0026amp;quot;/order\u0026amp;quot;) public class OrderController { …","date":-62135596800,"description":"http用户","dir":"projects/shenyu-2.3.0/http-proxy/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0434eaa36ea4baf882efd38715b6c2cf6d97cb61","permalink":"/zh/projects/shenyu-2.3.0/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/http-proxy/","summary":"说明 本文旨在帮助http用户。 soul网关使用 divide 插件来处理http请求。请求在soul-admin后台开启它。 接入前，请正确的启动 soul-","tags":null,"title":"Http用户","type":"projects","url":"/zh/projects/shenyu-2.3.0/http-proxy/","wordcount":1172},{"author":null,"categories":null,"content":" Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic. Use semaphores to process requests.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; hystrix, set to enable. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway.  \u0026amp;lt;!-- soul hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul hystrix plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector.\n Hystrix processing details:\n Trip minimum request quantity: the minimum request quantity, which must be reached at least before the fuse is triggered Error half-score threshold: the percentage of exceptions in this period of time. Maximum concurrency: the maximum concurrency Trip sleep time (ms): the recovery time after fusing. Grouping Key: generally set as: contextPath Command Key: generally set to specific path interface. CallBackUrl: default url: /fallback/hystrix.   ","date":-62135596800,"description":"hystrix plugin","dir":"projects/shenyu-2.3.0/hystrix-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d882995dc4c66e8467f73c1c2d7df6a310c0c1ae","permalink":"/projects/shenyu-2.3.0/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/hystrix-plugin/","summary":"Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic. Use semaphores to process requests.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; hystrix, set to enable. If the user don\u0026rsquo;t use, please disable the plugin in the background.  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway.  \u0026lt;!-- soul hystrix plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Hystrix Plugin","type":"projects","url":"/projects/shenyu-2.3.0/hystrix-plugin/","wordcount":142},{"author":null,"categories":null,"content":" Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic. Use semaphores to process requests.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; hystrix, set to enable. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway.  \u0026amp;lt;!-- shenyu hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu hystrix plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector.\n Hystrix processing details:\n Trip minimum request quantity: the minimum request quantity, which must be reached at least before the fuse is triggered Error half-score threshold: the percentage of exceptions in this period of time. Maximum concurrency: the maximum concurrency Trip sleep time (ms): the recovery time after fusing. Grouping Key: generally set as: contextPath Command Key: generally set to specific path interface. CallBackUrl: default url: /fallback/hystrix.   ","date":-62135596800,"description":"hystrix plugin","dir":"projects/shenyu/hystrix-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"24558bc419840f0a7371adba616e8023fa9c2cfd","permalink":"/projects/shenyu/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/hystrix-plugin/","summary":"Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic. Use semaphores to process requests.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; hystrix, set to enable. If the user don\u0026rsquo;t use, please disable the plugin in the background.  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway.  \u0026lt;!-- shenyu hystrix plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Hystrix Plugin","type":"projects","url":"/projects/shenyu/hystrix-plugin/","wordcount":142},{"author":null,"categories":null,"content":" 说明  hystrix插件是网关用来对流量进行熔断的核心实现。 使用信号量的方式来处理请求。  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; hystrix，设置为开启。 如果用户不使用，则在 soul-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 hystrix的支持。  \u0026amp;lt;!-- soul hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul hystrix plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Hystrix处理详解：\n 跳闸最小请求数量：最小的请求量，至少要达到这个量才会触发熔断\n 错误百分比阀值： 这段时间内，发生异常的百分比。\n 最大并发量： 最大的并发量\n 跳闸休眠时间(ms)：熔断以后恢复的时间。\n 分组Key： 一般设置为:contextPath\n 命令Key: 一般设置为具体的 路径接口。\n 失败降级URL: 默认为 /fallback/hystrix。\n   ","date":-62135596800,"description":"hystrix插件","dir":"projects/shenyu-2.3.0/hystrix-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9ab721f56465ce99936f92a583a6ed1634632e5b","permalink":"/zh/projects/shenyu-2.3.0/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/hystrix-plugin/","summary":"说明 hystrix插件是网关用来对流量进行熔断的核心实现。 使用信号量的方式来处理请求。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; hystrix，设置为开启。 如","tags":null,"title":"Hystrix插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/hystrix-plugin/","wordcount":315},{"author":null,"categories":null,"content":" 说明  hystrix插件是网关用来对流量进行熔断的核心实现。 使用信号量的方式来处理请求。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; hystrix，设置为开启。 如果用户不使用，则在 shenyu-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 hystrix的支持。  \u0026amp;lt;!-- shenyu hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu hystrix plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Hystrix处理详解：\n 跳闸最小请求数量：最小的请求量，至少要达到这个量才会触发熔断\n 错误百分比阀值： 这段时间内，发生异常的百分比。\n 最大并发量： 最大的并发量\n 跳闸休眠时间(ms)：熔断以后恢复的时间。\n 分组Key： 一般设置为:contextPath\n 命令Key: 一般设置为具体的 路径接口。\n 失败降级URL: 默认为 /fallback/hystrix。\n   ","date":-62135596800,"description":"hystrix插件","dir":"projects/shenyu/hystrix-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7a3c9158c399e47ec8679f909b9ea70a0787035c","permalink":"/zh/projects/shenyu/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/hystrix-plugin/","summary":"说明 hystrix插件是网关用来对流量进行熔断的核心实现。 使用信号量的方式来处理请求。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; hystrix，设置为开启。 如","tags":null,"title":"Hystrix插件","type":"projects","url":"/zh/projects/shenyu/hystrix-plugin/","wordcount":315},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating Http service with ShenYu Gateway. ShenYu Gateway uses divide plugin handling http request, pls enable it in shenyu-admin background. Please start shenyu-admin successfully before integrating and Environment Setup is Ok.  Configure ShenYu Gateway as Http proxy.  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml:  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   pls restart the gateway.  Http request via ShenYu Gateway（springMVC user）  pls make sure divide plugin has enabled in shenyu-admin background.  add Shenyu-Client methods（available for SpringMVC,SpringBoot user）  SpringBoot User\n Add these dependencies in your local maven repository pom.xml:  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Backend server register center config, please look:register center access.\n SpringMVC User\n Add these dependencies in your local maven repository pom.xml:\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Inject these properties into your Spring beans XML file:  \u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.apache.shenyu.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.apache.shenyu.register.common.config.ShenyuRegisterCenterConfig;\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/your contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;your server name\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;your server port\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   Add this annotation @ShenyuSpringMvcClient in your controller interface.\n You can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n Example1: both /test/payment and /test/findByUserId will be handled by …","date":-62135596800,"description":"Integrate Http with shenyu gateway","dir":"projects/shenyu/http-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7460b2dd02ec7de6b1b1404c4940544b6c67498e","permalink":"/projects/shenyu/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/http-proxy/","summary":"Features  This chapter is a guide about integrating Http service with ShenYu Gateway. ShenYu Gateway uses divide plugin handling http request, pls enable it in shenyu-admin background. Please start shenyu-admin successfully before integrating and Environment Setup is Ok.  Configure ShenYu Gateway as Http proxy.  Add these dependencies in gateway\u0026rsquo;s pom.xml:  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Integrate Http with shenyu gateway","type":"projects","url":"/projects/shenyu/http-proxy/","wordcount":525},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating Http service with soul gateway. Soul gateway uses divide plugin handling http request, pls enable it in soul-admin background. Please start soul-admin successfully before integrating and Environment Setup is Ok.  Configure soul gateway as Http proxy.  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml:  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   pls restart the gateway.  Http request via soul gateway（springMVC user）  pls make sure divide plugin has enabled in soul-admin background.  add Soul-Client methods（available for SpringMVC,SpringBoot user）  SpringBoot User\n Add these dependencies in your local maven repository pom.xml:   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Backend server register center config, please look:register center access.\n SpringMVC User\n Add these dependencies in your local maven repository pom.xml:\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Inject these properties into your Spring beans XML file:\n  \u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.register.common.config.SoulRegisterCenterConfig;\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/your contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;your server name\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;your server port\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   Add this annotation @SoulSpringMvcClient in your controller interface.\n You can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n Example1: both /test/payment and /test/findByUserId will be handled by proxy service.\n  @RestController …","date":-62135596800,"description":"Integrate Http with soul gateway","dir":"projects/shenyu-2.3.0/http-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b1da327e45adfe4b0001b9553682e944d068e652","permalink":"/projects/shenyu-2.3.0/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/http-proxy/","summary":"Features  This chapter is a guide about integrating Http service with soul gateway. Soul gateway uses divide plugin handling http request, pls enable it in soul-admin background. Please start soul-admin successfully before integrating and Environment Setup is Ok.  Configure soul gateway as Http proxy.  Add these dependencies in gateway\u0026rsquo;s pom.xml:  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Integrate Http with soul gateway","type":"projects","url":"/projects/shenyu-2.3.0/http-proxy/","wordcount":525},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating dubbo service with ShenYu Gateway. Support Alibaba Dubbo(\u0026amp;lt; 2.7.x) and Apache Dubbo (\u0026amp;gt;=2.7.x). Please start shenyu-admin successfully before integrating, and Environment Setup is Ok.  Configure shenyu gateway as Dubbo proxy  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml. Alibaba dubbo user, configure the dubbo version and registry center with yours.\n\u0026amp;lt;!--shenyu alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Apache dubbo user, configure the dubbo version and registry center with yours.  \u0026amp;lt;!--shenyu apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; …","date":-62135596800,"description":"Integrate dubbo with ShenYu gateway","dir":"projects/shenyu/dubbo-proxy/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3bbe560684f2df9a3a303845a104a2317ec77a4c","permalink":"/projects/shenyu/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu/dubbo-proxy/","summary":"Features  This chapter is a guide about integrating dubbo service with ShenYu Gateway. Support Alibaba Dubbo(\u0026lt; 2.7.x) and Apache Dubbo (\u0026gt;=2.7.x). Please start shenyu-admin successfully before integrating, and Environment Setup is Ok.  Configure shenyu gateway as Dubbo proxy  Add these dependencies in gateway\u0026rsquo;s pom.xml. Alibaba dubbo user, configure the dubbo version and registry center with yours.\n\u0026lt;!--shenyu alibaba dubbo plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-alibaba-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Integrate dubbo with ShenYu Gateway","type":"projects","url":"/projects/shenyu/dubbo-proxy/","wordcount":994},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating dubbo service with soul gateway. Support Alibaba Dubbo(\u0026amp;lt; 2.7.x) and Apache Dubbo (\u0026amp;gt;=2.7.x). Please start soul-admin successfully before integrating, and Environment Setup is Ok.  Configure soul gateway as Dubbo proxy  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml. Alibaba dubbo user, configure the dubbo version and registry center with yours.\n\u0026amp;lt;!--soul alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Apache dubbo user, configure the dubbo version and registry center with yours.   \u0026amp;lt;!--soul apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; …","date":-62135596800,"description":"Integrate dubbo with soul gateway","dir":"projects/shenyu-2.3.0/dubbo-proxy/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"59f129bbee6db3bd4bd6b0366e0f4658245883f3","permalink":"/projects/shenyu-2.3.0/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu-2.3.0/dubbo-proxy/","summary":"Features  This chapter is a guide about integrating dubbo service with soul gateway. Support Alibaba Dubbo(\u0026lt; 2.7.x) and Apache Dubbo (\u0026gt;=2.7.x). Please start soul-admin successfully before integrating, and Environment Setup is Ok.  Configure soul gateway as Dubbo proxy  Add these dependencies in gateway\u0026rsquo;s pom.xml. Alibaba dubbo user, configure the dubbo version and registry center with yours.\n\u0026lt;!--soul alibaba dubbo plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Integrate dubbo with soul gateway","type":"projects","url":"/projects/shenyu-2.3.0/dubbo-proxy/","wordcount":994},{"author":null,"categories":null,"content":" Explanation  The jwt plug-in is for the ** token ** attribute or authorization ** of the http request header to carry the attribute value for authentication judgment and judge auth2.0 **.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; jwt, set to enable.\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.\n Edit configuration properties in the plugin.\n  # secretKey If enabled, required {\u0026amp;quot;secretKey\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;filterPath\u0026amp;quot;:[]}  Plugin Use  Add support for jwt in the pom.xml file of the shenyu.  \u0026amp;lt;!-- shenyu jwt plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-jwt\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu jwt plugin end--\u0026amp;gt;   You need to configure the selector before you can use it.\n secretKey The private key written when using jwt to generate token. Required field.\n filterPath Authentication whitelist list, fill in the API path of the request interface. For example: http://127.0.0.1:8080/cloud/shenyu, add /cloud/shenyu to filterPath.\n  Situation  Requires unified authentication at the gateway.  ","date":-62135596800,"description":"Jwt plugin","dir":"projects/shenyu/jwt-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"33fcacb1136ce310e6594f84b2cf38a996386c7f","permalink":"/projects/shenyu/jwt-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/jwt-plugin/","summary":"Explanation  The jwt plug-in is for the ** token ** attribute or authorization ** of the http request header to carry the attribute value for authentication judgment and judge auth2.0 **.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; jwt, set to enable.\n If the user don\u0026rsquo;t use, please disable the plugin in the background.\n Edit configuration properties in the plugin.\n  # secretKey If enabled, required {\u0026quot;secretKey\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;filterPath\u0026quot;:[]}  Plugin Use  Add support for jwt in the pom.","tags":null,"title":"Jwt plugin","type":"projects","url":"/projects/shenyu/jwt-plugin/","wordcount":145},{"author":null,"categories":null,"content":" 说明  jwt 插件，是针对 http 请求头的 ** token ** 属性或者是 ** authorization ** 属性携带值进行鉴权判断，兼容 auth2.0 。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; jwt 设置为开启。\n 如果用户不想使用此功能，请在admin后台停用此插件。\n 插件编辑里面新增配置模式。\n  # secretKey 如果开启了，必填项 {\u0026amp;quot;secretKey\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;filterPath\u0026amp;quot;:[]}  插件使用  在网关的 pom.xml 文件中添加 jwt 的支持。  \u0026amp;lt;!-- shenyu jwt plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-jwt\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu jwt plugin end--\u0026amp;gt;   需要配置选择器和规则。\n secretKey 使用 jwt 生成 token 的时候，写的私钥。必填项。\n filterPath 鉴权白名单列表，填请求接口的 API 路径。 例如：http://127.0.0.1:8080/cloud/shenyu , filterPath 添加 /cloud/shenyu 即可。\n  场景  需要在网关统一鉴权。  ","date":-62135596800,"description":"Jwt插件","dir":"projects/shenyu/jwt-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5e05ca8d52cd8f56ad2791bf11a6f56a260d1963","permalink":"/zh/projects/shenyu/jwt-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/jwt-plugin/","summary":"说明 jwt 插件，是针对 http 请求头的 ** token ** 属性或者是 ** authorization ** 属性携带值进行鉴权判断，兼容 auth2.0 。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; jwt 设置为开启。 如果用户不想","tags":null,"title":"Jwt插件","type":"projects","url":"/zh/projects/shenyu/jwt-plugin/","wordcount":257},{"author":null,"categories":null,"content":" Explanation  When making invokes to the target service, ShenYu gateway also allows users to print the request information in the log that includes the request path, request method, request parameters, response header, response body \u0026amp;hellip;etc.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; logging, set to enable. Introduce logging support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  \u0026amp;lt;!-- shenyu logging plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-logging\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu logging plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。 Only those matched requests can print the information about this request.  Situation  Users may want to view the information about request(including request headers, request parameters, response headers, response body\u0026amp;hellip;etc) where in the side of gateway when debugging during development or troubleshooting problems online.  ","date":-62135596800,"description":"logging plugin","dir":"projects/shenyu/logging-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"4752eb44eb1f84470f6b0a6f641af4f4b96c975a","permalink":"/projects/shenyu/logging-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/logging-plugin/","summary":"Explanation  When making invokes to the target service, ShenYu gateway also allows users to print the request information in the log that includes the request path, request method, request parameters, response header, response body \u0026hellip;etc.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; logging, set to enable. Introduce logging support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background.","tags":null,"title":"Logging Plugin","type":"projects","url":"/projects/shenyu/logging-plugin/","wordcount":134},{"author":null,"categories":null,"content":" 说明  ShenYu 网关在对目标服务调用的时候，还容许用户使用 logging 插件在日志中打印本次请求信息，包含请求路径、请求方法、请求参数和响应头、响应体等信息。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; logging 设置为开启。 在网关的 pom.xml 文件中添加 logging 的支持。 如果用户不需要，可以把插件禁用。  \u0026amp;lt;!-- shenyu logging plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-logging\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu logging plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。 只有匹配的请求，并且配置规则才会打印本次请求相关信息。  场景  开发时调试或者线上排查问题等情况下，需要在网关侧查看本次请求在转发过程中的相关信息，如请求头、请求参数或响应头、响应体等。  ","date":-62135596800,"description":"logging插件","dir":"projects/shenyu/logging-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"99f9d6c04f3c8d57d07f9ca05bb7585a13ce1a6a","permalink":"/zh/projects/shenyu/logging-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/logging-plugin/","summary":"说明 ShenYu 网关在对目标服务调用的时候，还容许用户使用 logging 插件在日志中打印本次请求信息，包含请求路径、请求方法、请求参数和响应头、响应体等信息。 插件","tags":null,"title":"Logging插件","type":"projects","url":"/zh/projects/shenyu/logging-plugin/","wordcount":241},{"author":null,"categories":null,"content":" Description  This article mainly explains the concept,design of metadata and how to connect in the soul gateway.  Technical Solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;application name\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path,not repeatable\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path description\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc type\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;service name\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;method name\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;multiple parameter types, split by comma\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc extension information,json format\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;create date\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;update date\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;enable status\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026amp;rsquo;s generalization call.\n Pay attention to the field path,we will match specific data according to your field path during requesting gateway,and then carry out the follow-up process.\n Pay attention to the field rpc_ext,if it is a dubbo service interface and service interface has group and version field,this field exists.\n dubbo field structure as below,then we store json format string.\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   MetaData Storage  A dubbo interface corresponds to a meta data. SpringCloud protocol, only store one record, path: /contextPath/**. Http service, no data.  ","date":-62135596800,"description":"MetaData Concept Design","dir":"projects/shenyu-2.3.0/meta-data/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b69f5ef2359bc66581d96fa5cbdbd8d341465dad","permalink":"/projects/shenyu-2.3.0/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/meta-data/","summary":"Description  This article mainly explains the concept,design of metadata and how to connect in the soul gateway.  Technical Solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'id', `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'application name', `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path,not repeatable', `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path description', `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'rpc type', `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'service name', `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'method name', `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'multiple parameter types, split by comma', `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'rpc extension information,json format', `date_created` datetime(0) NOT NULL COMMENT 'create date', `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT 'update date', `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT 'enable status', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026rsquo;s generalization call.","tags":null,"title":"MetaData Concept Design","type":"projects","url":"/projects/shenyu-2.3.0/meta-data/","wordcount":324},{"author":null,"categories":null,"content":" Description  This article mainly explains the concept,design of metadata and how to connect in the ShenYu Gateway.  Technical Solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;application name\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path,not repeatable\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path description\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc type\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;service name\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;method name\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;multiple parameter types, split by comma\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc extension information,json format\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;create date\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;update date\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;enable status\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026amp;rsquo;s generalization call.\n Pay attention to the field path,we will match specific data according to your field path during requesting gateway,and then carry out the follow-up process.\n Pay attention to the field rpc_ext,if it is a dubbo service interface and service interface has group and version field,this field exists.\n dubbo field structure as below,then we store json format string.\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   MetaData Storage  A dubbo interface corresponds to a meta data. SpringCloud protocol, only store one record, path: /contextPath/**. Http service, no data.  ","date":-62135596800,"description":"MetaData Concept Design","dir":"projects/shenyu/meta-data/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"9a464e3a9f47524a8b3e9125ba7326f77c46a673","permalink":"/projects/shenyu/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/meta-data/","summary":"Description  This article mainly explains the concept,design of metadata and how to connect in the ShenYu Gateway.  Technical Solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'id', `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'application name', `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path,not repeatable', `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path description', `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'rpc type', `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'service name', `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'method name', `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'multiple parameter types, split by comma', `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'rpc extension information,json format', `date_created` datetime(0) NOT NULL COMMENT 'create date', `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT 'update date', `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT 'enable status', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026rsquo;s generalization call.","tags":null,"title":"MetaData Concept Design","type":"projects","url":"/projects/shenyu/meta-data/","wordcount":324},{"author":null,"categories":null,"content":" Explanation  Monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in soul gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026amp;rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In soul-admin\u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; monitor, set to enable. Add the following configuration in the monitor plugin.  {\u0026amp;quot;metricsName\u0026amp;quot;:\u0026amp;quot;prometheus\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;localhost\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:\u0026amp;quot;9191\u0026amp;quot;,\u0026amp;quot;async\u0026amp;quot;:\u0026amp;quot;true\u0026amp;quot;} # port : Pulled ports for exposing to prometheus service. # host : If not filled in, it is the host of soul Gateway. # async :\u0026amp;quot;true\u0026amp;quot; is asynchronous event tracking， false is synchronous event tracking.   If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Introduce monitor dependency in the pom.xml file of the gateway.  \u0026amp;lt;!-- soul monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul monitor plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only when the url is matched, the url will request event tracking.  Metrics Detail  All JVM，thread，memory，and other related infomation will be made event tracking，you can add a JVM module in the Granfana\u0026amp;rsquo; panel, and it will be fully displayed, please refer to： https://github.com/prometheus/jmx_exporter\n There are also the following custom metrics\n     Name type target description     request_total Counter none collecting all requests of Soul Gateway   http_request_total Counter path,type collecting all matched requests of monitor    Collect metrics Users need to install Prometheus service to collect\n Choose the corresponding environment download address to install Modify configuration file: prometheus.yml  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;prometheus\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9190\u0026#39;]  Note: The job_name corresponds to the metricsName of the monitor plug-in configuration\n After the configuration is completed, you can directly double-click prometheus.exe in the window to start. The default boot port is 9090, Success can be verified at http://localhost:9090/  Panel Display It is recommended to use Grafana, Users can customize the query to personalize the display panel.\nHere\u0026amp;rsquo;s how to install and deploy Grafana for Windows\n Install Grafana  download Unzip it and enter the bin directory and double-click grafana-server.exe to run it. Go to http://localhost:3000/?orgId=1 admin/admin to verify the success\n Config Prometheus …","date":-62135596800,"description":"monitor plugin","dir":"projects/shenyu-2.3.0/monitor-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"0f98d7c05318c86713ea6137b936704005a24164","permalink":"/projects/shenyu-2.3.0/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/monitor-plugin/","summary":"Explanation  Monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in soul gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In soul-admin\u0026ndash;\u0026gt; plugin management-\u0026gt; monitor, set to enable.","tags":null,"title":"Monitor Plugin","type":"projects","url":"/projects/shenyu-2.3.0/monitor-plugin/","wordcount":420},{"author":null,"categories":null,"content":" Explanation  Monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in ShenYu Gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026amp;rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In shenyu-admin\u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; monitor, set to enable. Add the following configuration in the monitor plugin.  {\u0026amp;quot;metricsName\u0026amp;quot;:\u0026amp;quot;prometheus\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;localhost\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:\u0026amp;quot;9191\u0026amp;quot;,\u0026amp;quot;async\u0026amp;quot;:\u0026amp;quot;true\u0026amp;quot;} # port : Pulled ports for exposing to prometheus service. # host : If not filled in, it is the host of ShenYu Gateway. # async :\u0026amp;quot;true\u0026amp;quot; is asynchronous event tracking， false is synchronous event tracking.   If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Introduce monitor dependency in the pom.xml file of the gateway.  \u0026amp;lt;!-- shenyu monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu monitor plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only when the url is matched, the url will request event tracking.  Metrics Detail  All JVM，thread，memory，and other related infomation will be made event tracking，you can add a JVM module in the Granfana\u0026amp;rsquo; panel, and it will be fully displayed, please refer to： https://github.com/prometheus/jmx_exporter\n There are also the following custom metrics\n     Name type target description     request_total Counter none collecting all requests of ShenYu Gateway   http_request_total Counter path,type collecting all matched requests of monitor    Collect metrics Users need to install Prometheus service to collect\n Choose the corresponding environment download address to install Modify configuration file: prometheus.yml  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;prometheus\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9190\u0026#39;]  Note: The job_name corresponds to the metricsName of the monitor plug-in configuration\n After the configuration is completed, you can directly double-click prometheus.exe in the window to start. The default boot port is 9090, Success can be verified at http://localhost:9090/  Panel Display It is recommended to use Grafana, Users can customize the query to personalize the display panel.\nHere\u0026amp;rsquo;s how to install and deploy Grafana for Windows\n Install Grafana  download Unzip it and enter the bin directory and double-click grafana-server.exe to run it. Go to http://localhost:3000/?orgId=1 admin/admin to verify the success\n Config …","date":-62135596800,"description":"monitor plugin","dir":"projects/shenyu/monitor-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d99834e2c32d8b84ce3889810f33d20dbb7e6d6a","permalink":"/projects/shenyu/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/monitor-plugin/","summary":"Explanation  Monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in ShenYu Gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In shenyu-admin\u0026ndash;\u0026gt; plugin management-\u0026gt; monitor, set to enable.","tags":null,"title":"Monitor Plugin","type":"projects","url":"/projects/shenyu/monitor-plugin/","wordcount":420},{"author":null,"categories":null,"content":" 说明  monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。  技术方案  流程图  异步或者同步的方式，在soul网关里面进行 metrics 埋点。\n prometheus 服务端通过 http 请求 来 拉取 metrics，再使用 Grafana 展示。\n  插件设置  在 soul-admin\u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; monitor ,设置为开启。\n 在 monitor 插件中新增以下配置\n  {\u0026amp;quot;metricsName\u0026amp;quot;:\u0026amp;quot;prometheus\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;localhost\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:\u0026amp;quot;9191\u0026amp;quot;,\u0026amp;quot;async\u0026amp;quot;:\u0026amp;quot;true\u0026amp;quot;} # port : 为暴露给 prometheus服务来拉取的端口 # host : 不填写则为soul网关的host. # async :\u0026amp;quot;true\u0026amp;quot; 为异步埋点， false 为同步埋点   如果用户不使用，则在 soul-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 monitor 的支持。  \u0026amp;lt;!-- soul monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul monitor plugin end--\u0026amp;gt;   选择器和规则，请详细看 : 选择器规则。\n 只有当匹配的url，才会进行url请求埋点。   metrics信息  所有的JVM，线程，内存，等相关信息都会埋点，可以在 Granfana 面板中，新增一个 JVM 模块，则会完全展示 具体请看：https://github.com/prometheus/jmx_exporter\n 另外还有如下自定义的 metrics\n     名称 类型 标签名称 说明     request_total Counter 无 收集Soul网关所有的请求   http_request_total Counter path,type 收集monitor插件匹配的请求    收集 metrics 用户需部署Prometheus 服务来采集\n 选择对应环境的下载地址安装 修改配置文件：prometheus.yml  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;prometheus\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9190\u0026#39;]  注： job_name跟monitor插件配置的metricsName相对应\n 配置完成之后window下可以直接双击prometheus.exe启动即可，默认启动端口为9090，可通过http://localhost:9090/ 验证是否成功  面板展示 推荐使用 Grafana，用户可以自定义查询来个性化显示面板盘。\n下面介绍Grafana部署（windows版）\n 安装Grafana  下载地址 解压进入bin目录然后双击grafana-server.exe运行 访问http://localhost:3000/?orgId=1 admin/admin 验证是否成功\n 配置Prometheus数据源   配置JVM面板  点击Create - Import，输入dashboards的id（推荐8563）\n最终JVM监控面板效果如下：\n 配置自定义metric面板request_total、http_request_total  点击Create - Import，输入dashboards的面板json配置\n最终自定义Http请求监控面板效果如下：\n","date":-62135596800,"description":"monitor插件","dir":"projects/shenyu-2.3.0/monitor-plugin/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bb47e1281bc7a16fcfd9f2807b7d2a098ae661b2","permalink":"/zh/projects/shenyu-2.3.0/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/monitor-plugin/","summary":"说明 monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。 技术方案 流程图 异步或者同","tags":null,"title":"Monitor插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/monitor-plugin/","wordcount":993},{"author":null,"categories":null,"content":" 说明  monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。  技术方案  流程图  异步或者同步的方式，在 ShenYu 网关里面进行 metrics 埋点。\n prometheus 服务端通过 http 请求 来 拉取 metrics，再使用 Grafana 展示。\n  插件设置  在 shenyu-admin\u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; monitor ,设置为开启。\n 在 monitor 插件中新增以下配置\n  {\u0026amp;quot;metricsName\u0026amp;quot;:\u0026amp;quot;prometheus\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;localhost\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:\u0026amp;quot;9191\u0026amp;quot;,\u0026amp;quot;async\u0026amp;quot;:\u0026amp;quot;true\u0026amp;quot;} # port : 为暴露给 prometheus服务来拉取的端口 # host : 不填写则为 ShenYu 网关的host. # async :\u0026amp;quot;true\u0026amp;quot; 为异步埋点， false 为同步埋点   如果用户不使用，则在 shenyu-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 monitor 的支持。  \u0026amp;lt;!-- shenyu monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu monitor plugin end--\u0026amp;gt;   选择器和规则，请详细看 : 选择器规则。\n 只有当匹配的url，才会进行url请求埋点。   metrics信息  所有的JVM，线程，内存，等相关信息都会埋点，可以在 Granfana 面板中，新增一个 JVM 模块，则会完全展示 具体请看：https://github.com/prometheus/jmx_exporter\n 另外还有如下自定义的 metrics\n     名称 类型 标签名称 说明     request_total Counter 无 收集ShenYu网关所有的请求   http_request_total Counter path,type 收集monitor插件匹配的请求    收集 metrics 用户需部署Prometheus 服务来采集\n 选择对应环境的下载地址安装 修改配置文件：prometheus.yml  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;prometheus\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9190\u0026#39;]  注： job_name跟monitor插件配置的metricsName相对应\n 配置完成之后window下可以直接双击prometheus.exe启动即可，默认启动端口为9090，可通过http://localhost:9090/ 验证是否成功  面板展示 推荐使用 Grafana，用户可以自定义查询来个性化显示面板盘。\n下面介绍Grafana部署（windows版）\n 安装Grafana  下载地址 解压进入bin目录然后双击grafana-server.exe运行 访问http://localhost:3000/?orgId=1 admin/admin 验证是否成功\n 配置Prometheus数据源   配置JVM面板  点击Create - Import，输入dashboards的id（推荐8563）\n最终JVM监控面板效果如下：\n 配置自定义metric面板request_total、http_request_total  点击Create - Import，输入dashboards的面板json配置\n最终自定义Http请求监控面板效果如下：\n","date":-62135596800,"description":"monitor插件","dir":"projects/shenyu/monitor-plugin/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bdebe3022a2e53964bfe52c2cbd1e2331362fc87","permalink":"/zh/projects/shenyu/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/monitor-plugin/","summary":"说明 monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。 技术方案 流程图 异步或者同","tags":null,"title":"Monitor插件","type":"projects","url":"/zh/projects/shenyu/monitor-plugin/","wordcount":989},{"author":null,"categories":null,"content":" Explanation  When making invokes to the target service, soul Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; context_path, set to enable. Introduce context_path support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  \u0026amp;lt;!-- soul context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul context_path plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。  Situation  As the name suggests,the context_path plugin redefines the contextPath of URI. When the request is matched, the custom contextPath is set, then the custom contextPath will be intercepted according to the requested Url to obtain the real Url, for example, the request path is /soul/http/order, The configured contextPath is /soul/http, then the requested url is /order.  ","date":-62135596800,"description":"context_path plugin","dir":"projects/shenyu-2.3.0/context-path-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"c78a4aac618afa51282163e9306ce38bd286ec1a","permalink":"/projects/shenyu-2.3.0/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/context-path-plugin/","summary":"Explanation  When making invokes to the target service, soul Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; context_path, set to enable. Introduce context_path support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background.  \u0026lt;!-- soul context_path plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-context-path\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Plugin Context Path Mapping","type":"projects","url":"/projects/shenyu-2.3.0/context-path-plugin/","wordcount":134},{"author":null,"categories":null,"content":" Explanation  When making invokes to the target service, ShenYu Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; context_path, set to enable. Introduce context_path support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  \u0026amp;lt;!-- shenyu context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu context_path plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。  Situation  As the name suggests,the context_path plugin redefines the contextPath of URI. When the request is matched, the custom contextPath is set, then the custom contextPath will be intercepted according to the requested Url to obtain the real Url, for example, the request path is /shenyu/http/order, The configured contextPath is /shenyu/http, then the requested url is /order.  ","date":-62135596800,"description":"context_path plugin","dir":"projects/shenyu/context-path-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"a5283586a6d36cc6ce53c6f6bc33c87a67dd4eaf","permalink":"/projects/shenyu/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/context-path-plugin/","summary":"Explanation  When making invokes to the target service, ShenYu Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; context_path, set to enable. Introduce context_path support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background.  \u0026lt;!-- shenyu context_path plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-context-path\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"Plugin Context Path Mapping","type":"projects","url":"/projects/shenyu/context-path-plugin/","wordcount":134},{"author":null,"categories":null,"content":" Explanation  In our Soul-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plug-in handling template configuration  Table Design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;plugin id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;field\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;label\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;data type 1 number 2 string 3 select box\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;type, 1 means selector, 2 means rule\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;sort\u0026#39;, `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;extra configuration (json format data)\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg. When we developed the springCloud plugin, the rule table needed to store some configuration into the handle field, Configure the corresponding entity class as follows:\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; }   step1. We can go directly to the plug-in management link http://localhost:9095/#/system/plugin Click Edit Plugin for processing step2. Add a string type field path and a numeric type TIMEOUT\nstep3. Finally, you can enter path, TIMEOUT and commit to the handle field when you add a rule in the plugin rule configuration page\n_Note: If data_type is configured to be 3 selection box, the input field drop-down selection on the new rule page is displayed by going to the soul_dict） table to find all the options available_\n The Sentinel plug-in, for example, is shown below:  ","date":-62135596800,"description":"plugin handle explanation","dir":"projects/shenyu-2.3.0/plugin-handle-explanation/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b9bede8cbfa921a3d1bb51bf829d48a640258954","permalink":"/projects/shenyu-2.3.0/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/plugin-handle-explanation/","summary":"Explanation  In our Soul-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plug-in handling template configuration  Table Design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT 'plugin id', `field` varchar(100) NOT NULL COMMENT 'field', `label` varchar(100) DEFAULT NULL COMMENT 'label', `data_type` smallint(6) NOT NULL DEFAULT '1' COMMENT 'data type 1 number 2 string 3 select box', `type` smallint(6) NULL COMMENT 'type, 1 means selector, 2 means rule', `sort` int(4) NULL COMMENT 'sort', `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'extra configuration (json format data)', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg.","tags":null,"title":"Plugin Handle Explanation","type":"projects","url":"/projects/shenyu-2.3.0/plugin-handle-explanation/","wordcount":306},{"author":null,"categories":null,"content":" Explanation  In our Shenyu-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plugin handling template configuration  Table Design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;plugin id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;field\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;label\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;data type 1 number 2 string 3 select box\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;type, 1 means selector, 2 means rule\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;sort\u0026#39;, `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;extra configuration (json format data)\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg. When we developed the springCloud plugin, the rule table needed to store some configuration into the handle field, Configure the corresponding entity class as follows:\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; }   step1. We can go directly to the plug-in management link http://localhost:9095/#/system/plugin Click Edit Plugin for processing step2. Add a string type field path and a numeric type TIMEOUT\nstep3. Finally, you can enter path, TIMEOUT and commit to the handle field when you add a rule in the plugin rule configuration page\nNote: If data_type is configured to be 3 selection box, the input field drop-down selection on the new rule page is displayed by going to the shenyu_dict table to find all the options available.\n The Sentinel plug-in, for example, is shown below:  ","date":-62135596800,"description":"plugin handle explanation","dir":"projects/shenyu/plugin-handle-explanation/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"2603811a9452daff2420f47c345dcda4b28285db","permalink":"/projects/shenyu/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/plugin-handle-explanation/","summary":"Explanation  In our Shenyu-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plugin handling template configuration  Table Design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT 'plugin id', `field` varchar(100) NOT NULL COMMENT 'field', `label` varchar(100) DEFAULT NULL COMMENT 'label', `data_type` smallint(6) NOT NULL DEFAULT '1' COMMENT 'data type 1 number 2 string 3 select box', `type` smallint(6) NULL COMMENT 'type, 1 means selector, 2 means rule', `sort` int(4) NULL COMMENT 'sort', `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'extra configuration (json format data)', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg.","tags":null,"title":"Plugin Handle Explanation","type":"projects","url":"/projects/shenyu/plugin-handle-explanation/","wordcount":306},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using Dubbo. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap, In addition, if you use ZooKeeper for Dubbo, you need to download it in advance.\nRun the soul-examples-dubbo project Downloadsoul-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:\n\u0026amp;lt;dubbo:registry address=\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;/\u0026amp;gt;  Execute the TestApacheDubboApplication main method to start dubbo project.\nThe following log appears when the startup is successful:\n2021-02-06 20:58:01.807 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.entity.DubboTest\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.821 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Get all data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findAll\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.833 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Query by …","date":-62135596800,"description":"Quick start with Dubbo","dir":"projects/shenyu-2.3.0/quick-start-dubbo/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"4ac9ff31d589be6ab97f221b08d3e2dfc31e0441","permalink":"/projects/shenyu-2.3.0/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/quick-start-dubbo/","summary":"This document introduces how to quickly access the Soul Gateway using Dubbo. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap, In addition, if you use ZooKeeper for Dubbo, you need to download it in advance.\nRun the soul-examples-dubbo project Downloadsoul-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:","tags":null,"title":"Quick start with Dubbo","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-dubbo/","wordcount":415},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using Dubbo. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap, In addition, if you use ZooKeeper for Dubbo, you need to download it in advance.\nRun the shenyu-examples-dubbo project Downloadshenyu-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:\n\u0026amp;lt;dubbo:registry address=\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;/\u0026amp;gt;  Execute the TestApacheDubboApplication main method to start dubbo project.\nThe following log appears when the startup is successful:\n2021-02-06 20:58:01.807 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.entity.DubboTest\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.821 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Get all data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.dubbo.api.service.DubboTestService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findAll\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/dubbo/findAll\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;group\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;version\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;,\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;random\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:2,\\\u0026amp;quot;timeout\\\u0026amp;quot;:10000,\\\u0026amp;quot;url\\\u0026amp;quot;:\\\u0026amp;quot;\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-06 20:58:01.833 INFO 3724 --- [pool-2-thread-1] o.d.s.client.common.utils.RegisterUtils : dubbo client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;dubbo\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/dubbo\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/dubbo/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Query by …","date":-62135596800,"description":"Quick start with Dubbo","dir":"projects/shenyu/quick-start-dubbo/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"61aa5d76f767cba5aece837587350dd092d79d61","permalink":"/projects/shenyu/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/quick-start-dubbo/","summary":"This document introduces how to quickly access the ShenYu Gateway using Dubbo. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap, In addition, if you use ZooKeeper for Dubbo, you need to download it in advance.\nRun the shenyu-examples-dubbo project Downloadshenyu-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:","tags":null,"title":"Quick start with Dubbo","type":"projects","url":"/projects/shenyu/quick-start-dubbo/","wordcount":415},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using SpringCloud. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\n Add the following dependencies to the soul-bootstrap\u0026amp;rsquo;s pom.xml file:  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- If using Eureka as a registry needs to be introduced --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin start end--\u0026amp;gt;  Startup the soul-bootstrap project\nRun the soul-examples-springcloud and soul-examples-eureka project In the example project we use eureka as the SpringCloud registry\nDownload soul-examples-eureka and soul-examples-springcloud\n Startup the Eureka service  Execute the org.dromara.soul.examples.eureka.EurekaServerApplication main method to start project.\n Startup the Spring Cloud service  Execute the org.dromara.soul.examples.springcloud.SoulTestSpringCloudApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-02-10 14:03:51.301 INFO 2860 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-02-10 14:03:51.669 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.676 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.682 INFO 2860 --- [pool-1-thread-1] …","date":-62135596800,"description":"Quick start with SpringCloud","dir":"projects/shenyu-2.3.0/quick-start-springcloud/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"97774530237166f618d98b9d673ebbe1cb5591af","permalink":"/projects/shenyu-2.3.0/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu-2.3.0/quick-start-springcloud/","summary":"This document introduces how to quickly access the Soul Gateway using SpringCloud. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\n Add the following dependencies to the soul-bootstrap\u0026rsquo;s pom.xml file:  \u0026lt;!--soul springCloud plugin start--\u0026gt; dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- If using Eureka as a registry needs to be introduced --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Quick start with SpringCloud","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-springcloud/","wordcount":749},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using SpringCloud. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\n Add the following dependencies to the shenyu-bootstrap\u0026amp;rsquo;s pom.xml file:  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- If using Eureka as a registry needs to be introduced --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin start end--\u0026amp;gt;  Startup the shenyu-bootstrap project\nRun the shenyu-examples-springcloud and shenyu-examples-eureka project In the example project we use eureka as the SpringCloud registry\nDownload shenyu-examples-eureka and shenyu-examples-springcloud\n Startup the Eureka service  Execute the org.apache.shenyu.examples.eureka.EurekaServerApplication main method to start project.\n Startup the Spring Cloud service  Execute the org.apache.shenyu.examples.springcloud.ShenyuTestSpringCloudApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-02-10 14:03:51.301 INFO 2860 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-02-10 14:03:51.669 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.676 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.682 INFO 2860 --- …","date":-62135596800,"description":"Quick start with SpringCloud","dir":"projects/shenyu/quick-start-springcloud/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"9a06c427d513f63adb146a5bf6dffb332eae004c","permalink":"/projects/shenyu/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu/quick-start-springcloud/","summary":"This document introduces how to quickly access the ShenYu Gateway using SpringCloud. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\n Add the following dependencies to the shenyu-bootstrap\u0026rsquo;s pom.xml file:  \u0026lt;!--shenyu springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- If using Eureka as a registry needs to be introduced --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Quick start with SpringCloud","type":"projects","url":"/projects/shenyu/quick-start-springcloud/","wordcount":749},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using Tars. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nNote: soul-bootstrap need to import tars dependencies\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.tencent.tars\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;tars-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.7.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Run the soul-examples-tars project Download soul-examples-tars\nModify host in application.yml to be your local IP\nModify config src/main/resources/SoulExampleServer.SoulExampleApp.config.conf:\n It is recommended to make clear the meaning of the main configuration items of config, refer to the development guide bind IP in config should pay attention to providing cost machine local=\u0026amp;hellip;, Indicates the open port that the native machine connects to the tarsnode. If there is no tarsnode, this configuration can be dropped locator: Indicates the address (frame address) of the main control center, which is used to obtain the IP list according to the service name, If Registry is not required to locate the service, this configuration can be dropped node=tars.tarsnode.ServerObj@xxxx, Indicates the address of the connected tarsnode. If there is no tarsnode locally, this configuration can be removed  More config configuration instructions, Please refer toTARS Official Documentation\nExecute the org.dromara.soul.examples.tars.SoulTestTarsApplication main method to start project.\nNote: The configuration file address needs to be specified in the startup command when the service starts -Dconfig=xxx/SoulExampleServer.SoulExampleApp.config.conf\nIf the -Dconfig parameter is not added, the configuration may throw the following exceptions:\ncom.qq.tars.server.config.ConfigurationException: error occurred on load server config at com.qq.tars.server.config.ConfigurationManager.loadServerConfig(ConfigurationManager.java:113) at com.qq.tars.server.config.ConfigurationManager.init(ConfigurationManager.java:57) at com.qq.tars.server.core.Server.loadServerConfig(Server.java:90) at com.qq.tars.server.core.Server.\u0026amp;lt;init\u0026amp;gt;(Server.java:42) at com.qq.tars.server.core.Server.\u0026amp;lt;clinit\u0026amp;gt;(Server.java:38) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:37) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:31) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at …","date":-62135596800,"description":"Quick start with Tars","dir":"projects/shenyu-2.3.0/quick-start-tars/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"9fa2a38a05a45d6fc27c1b4569ef34c9ef6f5e28","permalink":"/projects/shenyu-2.3.0/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/quick-start-tars/","summary":"This document introduces how to quickly access the Soul Gateway using Tars. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nNote: soul-bootstrap need to import tars dependencies\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-tars\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Run the soul-examples-tars project Download soul-examples-tars\nModify host in application.yml to be your local IP","tags":null,"title":"Quick start with Tars","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-tars/","wordcount":480},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using Tars. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nNote: shenyu-bootstrap need to import tars dependencies\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.tencent.tars\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;tars-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.7.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Run the shenyu-examples-tars project Download shenyu-examples-tars\nModify host in application.yml to be your local IP\nModify config src/main/resources/ShenyuExampleServer.ShenyuExampleApp.config.conf:\n It is recommended to make clear the meaning of the main configuration items of config, refer to the development guide bind IP in config should pay attention to providing cost machine local=\u0026amp;hellip;, Indicates the open port that the native machine connects to the tarsnode. If there is no tarsnode, this configuration can be dropped locator: Indicates the address (frame address) of the main control center, which is used to obtain the IP list according to the service name, If Registry is not required to locate the service, this configuration can be dropped node=tars.tarsnode.ServerObj@xxxx, Indicates the address of the connected tarsnode. If there is no tarsnode locally, this configuration can be removed  More config configuration instructions, Please refer toTARS Official Documentation\nExecute the org.apache.shenyu.examples.tars.ShenyuTestTarsApplication main method to start project.\nNote: The configuration file address needs to be specified in the startup command when the service starts -Dconfig=xxx/ShenyuExampleServer.ShenyuExampleApp.config.conf\nIf the -Dconfig parameter is not added, the configuration may throw the following exceptions:\ncom.qq.tars.server.config.ConfigurationException: error occurred on load server config at com.qq.tars.server.config.ConfigurationManager.loadServerConfig(ConfigurationManager.java:113) at com.qq.tars.server.config.ConfigurationManager.init(ConfigurationManager.java:57) at com.qq.tars.server.core.Server.loadServerConfig(Server.java:90) at com.qq.tars.server.core.Server.\u0026amp;lt;init\u0026amp;gt;(Server.java:42) at com.qq.tars.server.core.Server.\u0026amp;lt;clinit\u0026amp;gt;(Server.java:38) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:37) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:31) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at …","date":-62135596800,"description":"Quick start with Tars","dir":"projects/shenyu/quick-start-tars/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3766ff5bf5d1b66c252a893936f1b6eba9de31ea","permalink":"/projects/shenyu/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/quick-start-tars/","summary":"This document introduces how to quickly access the ShenYu Gateway using Tars. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nNote: shenyu-bootstrap need to import tars dependencies\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-tars\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Run the shenyu-examples-tars project Download shenyu-examples-tars\nModify host in application.yml to be your local IP","tags":null,"title":"Quick start with Tars","type":"projects","url":"/projects/shenyu/quick-start-tars/","wordcount":480},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using gRPC. You can get the code example of this document by clicking here.\n1. Prepare For Environment. Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nNote: shenyu-bootstrap need to import gRPC dependencies\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2. Run the shenyu-examples-grpc project. Download shenyu-examples-grpc\nRun the following command under shenyu-examples-grpc to generate Java code\nmvn protobuf:compile mvn protobuf:compile-custom  Execute the org.apache.shenyu.examples.grpc.ShenyuTestGrpcApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-19] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/clientStreamingFun\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;clientStreamingFun\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;stream.StreamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;clientStreamingFun\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/clientStreamingFun\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:5000,\\\u0026amp;quot;methodType\\\u0026amp;quot;:\\\u0026amp;quot;CLIENT_STREAMING\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;172.20.10.6\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8080,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-17] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;echo.EchoService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;echo.EchoRequest,io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:5000,\\\u0026amp;quot;methodType\\\u0026amp;quot;:\\\u0026amp;quot;UNARY\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;172.20.10.6\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8080,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-20] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: …","date":-62135596800,"description":"Quick start with gRPC","dir":"projects/shenyu/quick-start-grpc/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"83596cb6d0134e4b7a3222a9c813be07e6c630b5","permalink":"/projects/shenyu/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/quick-start-grpc/","summary":"This document introduces how to quickly access the ShenYu Gateway using gRPC. You can get the code example of this document by clicking here.\n1. Prepare For Environment. Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nNote: shenyu-bootstrap need to import gRPC dependencies\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-grpc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  2. Run the shenyu-examples-grpc project. Download shenyu-examples-grpc\nRun the following command under shenyu-examples-grpc to generate Java code\nmvn protobuf:compile mvn protobuf:compile-custom  Execute the org.","tags":null,"title":"Quick start with gRPC","type":"projects","url":"/projects/shenyu/quick-start-grpc/","wordcount":411},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using Grpc. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nNote: soul-bootstrap need to import grpc dependencies\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Run the soul-examples-grpc project Download soul-examples-grpc\nRun the following command under soul-examples-grpc to generate Java code\nmvn protobuf:compile mvn protobuf:compile-custom  Execute the org.dromara.soul.examples.grpc.SoulTestGrpcApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-02-10 01:57:02.154 INFO 76 --- [ main] o.d.s.e.grpc.SoulTestGrpcApplication : Started SoulTestGrpcApplication in 2.088 seconds (JVM running for 3.232) 2021-02-10 01:57:02.380 INFO 76 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;echo.EchoService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;echo.EchoRequest,io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true}  Grpc plugin settings  enabled the grpc plugin in the soul-admin plugin management.  Testing The soul-examples-grpc project will automatically register interface methods annotated with @SoulGrpcClient in the soul gateway after successful startup.\nOpen Plugin Management -\u0026amp;gt; grpc to see the list of plugin rule configurations\nUse PostMan to simulate HTTP to request your Grpc service\n","date":-62135596800,"description":"Quick start with grpc","dir":"projects/shenyu-2.3.0/quick-start-grpc/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"0f3283fce336edda1c37e9f2f0bee7703fe34160","permalink":"/projects/shenyu-2.3.0/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/quick-start-grpc/","summary":"This document introduces how to quickly access the Soul Gateway using Grpc. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nNote: soul-bootstrap need to import grpc dependencies\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-grpc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Run the soul-examples-grpc project Download soul-examples-grpc\nRun the following command under soul-examples-grpc to generate Java code\nmvn protobuf:compile mvn protobuf:compile-custom  Execute the org.","tags":null,"title":"Quick start with grpc","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-grpc/","wordcount":171},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using Http. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nIntroducing gateway to HTTP proxy plugin\n Add the following dependencies to the soul-bootstrap\u0026amp;rsquo;s pom.xml file:  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Run the soul-examples-http project Downloadsoul-examples-http\nExecute the org.dromara.soul.examples.http.SoulTestHttpApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-02-10 00:57:07.561 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.577 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Save order\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.587 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.596 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by …","date":-62135596800,"description":"Quick start with http","dir":"projects/shenyu-2.3.0/quick-start-http/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"1fc0253aa97970bd3ad9b87096eeb3a374b49bba","permalink":"/projects/shenyu-2.3.0/quick-start-http/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/quick-start-http/","summary":"This document introduces how to quickly access the Soul Gateway using Http. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap.\nIntroducing gateway to HTTP proxy plugin\n Add the following dependencies to the soul-bootstrap\u0026rsquo;s pom.xml file:  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Quick start with http","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-http/","wordcount":252},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using Http. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nIntroducing gateway to HTTP proxy plugin\n Add the following dependencies to the shenyu-bootstrap\u0026amp;rsquo;s pom.xml file:  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Run the shenyu-examples-http project Downloadshenyu-examples-http\nExecute the org.apache.shenyu.examples.http.ShenyuTestHttpApplication main method to start project.\nThe following log appears when the startup is successful:\n2021-02-10 00:57:07.561 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/test/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.577 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Save order\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.587 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;192.168.50.13\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8188,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/http/order/path/**/name\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-02-10 00:57:07.596 INFO 3700 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : http client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;http\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/http\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/http/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by …","date":-62135596800,"description":"Quick start with http","dir":"projects/shenyu/quick-start-http/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"92ea8f425e60e358018a953de8681eefe4541629","permalink":"/projects/shenyu/quick-start-http/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/quick-start-http/","summary":"This document introduces how to quickly access the ShenYu Gateway using Http. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap.\nIntroducing gateway to HTTP proxy plugin\n Add the following dependencies to the shenyu-bootstrap\u0026rsquo;s pom.xml file:  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Quick start with http","type":"projects","url":"/projects/shenyu/quick-start-http/","wordcount":252},{"author":null,"categories":null,"content":" This document introduces how to quickly access the Soul Gateway using Sofa RPC. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap, In addition, if you use ZooKeeper for Sofa, you need to download it in advance.\nNote: soul-bootstrap need to import sofa dependencies\n\u0026amp;lt;!-- soul sofa plugin starter--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.rpc.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- zookeeper --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sofa plugin end--\u0026amp;gt;  Run the soul-examples-sofa project Download soul-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:\ncom: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181  Execute the org.dromara.soul.examples.sofa.service.TestSofaApplication main method to start sofa service.\nThe following log appears when the startup is successful:\n2021-02-10 02:31:45.599 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.sofa.api.entity.SofaSimpleTypeBean\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.605 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by …","date":-62135596800,"description":"Quick start with sofa","dir":"projects/shenyu-2.3.0/quick-start-sofa/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"27be2417954a9547dc499909a3ef165c2b2ff44f","permalink":"/projects/shenyu-2.3.0/quick-start-sofa/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu-2.3.0/quick-start-sofa/","summary":"This document introduces how to quickly access the Soul Gateway using Sofa RPC. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch soul-admin and soul-bootstrap, In addition, if you use ZooKeeper for Sofa, you need to download it in advance.\nNote: soul-bootstrap need to import sofa dependencies\n\u0026lt;!-- soul sofa plugin starter--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-rpc-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${sofa.rpc.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Quick start with sofa","type":"projects","url":"/projects/shenyu-2.3.0/quick-start-sofa/","wordcount":780},{"author":null,"categories":null,"content":" This document introduces how to quickly access the ShenYu Gateway using Sofa RPC. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap, In addition, if you use ZooKeeper for Sofa, you need to download it in advance.\nNote: shenyu-bootstrap need to import sofa dependencies\n\u0026amp;lt;!-- shenyu sofa plugin starter--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.rpc.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- zookeeper --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sofa plugin end--\u0026amp;gt;  Run the shenyu-examples-sofa project Download shenyu-examples-dubbo, replace the register address in spring-dubbo.xml with your local zk address, such as:\ncom: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181  Execute the org.apache.shenyu.examples.sofa.service.TestSofaApplication main method to start sofa service.\nThe following log appears when the startup is successful:\n2021-02-10 02:31:45.599 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.sofa.api.entity.SofaSimpleTypeBean\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.605 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by …","date":-62135596800,"description":"Quick start with sofa","dir":"projects/shenyu/quick-start-sofa/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f28280210d416522a92b7b5d6538e8968b00c863","permalink":"/projects/shenyu/quick-start-sofa/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu/quick-start-sofa/","summary":"This document introduces how to quickly access the ShenYu Gateway using Sofa RPC. You can get the code example of this document by clicking here.\nEnvironment to prepare Please refer to the setup and launch shenyu-admin and shenyu-bootstrap, In addition, if you use ZooKeeper for Sofa, you need to download it in advance.\nNote: shenyu-bootstrap need to import sofa dependencies\n\u0026lt;!-- shenyu sofa plugin starter--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-rpc-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${sofa.rpc.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Quick start with sofa","type":"projects","url":"/projects/shenyu/quick-start-sofa/","wordcount":780},{"author":null,"categories":null,"content":" Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n The soul gateway provides a variety of current limiting algorithms, including token bucket algorithm, concurrent token bucket algorithm, leaky bucket algorithm and sliding time window algorithm.\n The implementation of current limiting algorithm of soul gateway is based on redis.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.\n  Technical Solution Using redis token bucket algorithm to limit traffic.  The system generates the token at a constant rate, and then puts the token into the token bucket. The token bucket\u0026amp;rsquo;s capacity. When the bucket is full, the token put into it will be discarded. Each time requests come, you need to obtain a token from the token bucket. If there are tokens, the service will be provided; if there are no tokens, the service will be rejected.\n Flow Diagram：   Using redis leaky bucket algorithm to limit traffic.  water (request) go to the leaky bucket first. The leaky bucket goes out at a fixed speed. When the flow speed is too fast, it will overflow directly (reject service)\n Flow Diagram：   Using redis sliding time window algorithm to limit traffic.  The sliding time window maintains the count value of unit time. Whenever a requests pass, the count value will be increased by 1. When the count value exceeds the preset threshold, other requests in unit time will be rejected. If the unit time has ended, clear the counter to zero and start the next round counting.\n Flow Diagram：   Plugin Setting  In soul-admin\u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; rate_limiter set to enable.\n Configure redis in the plugin.\n Currently, supporting redis patterns of single, sentinel, and cluster.\n If it is a sentinel, cluster and other multi-node configuration in URL, please use ; for each instance; Division. For example, 192.168.1.1:6379; 192.168.1.2:6379。\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.\n  Plugin Detail  Introduce rateLimiter dependency in pom.xml file of the gateway.  \u0026amp;lt;!-- soul ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul ratelimiter plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Detailed description of the rules\n  Token bucket algorithm/Concurrent token bucket algorithm   lgorithmName：tocketBucket/concurrent\nreplenishRate：It is how many requests you allow users to execute per second, while not discarding any requests. This is the filling rate of token bucket.\nburstCapacity：it is the maximum number of requests that users are allowed to execute in one second. This is token bucket can save the number of token.\n * Leaky bucket algorithm  algorithmName：leakyBucket\nreplenishRate：The rate at which requests are …","date":-62135596800,"description":"rateLimiter plugin","dir":"projects/shenyu-2.3.0/rate-limiter-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"5a84a6ef5eada3f6ff1ffe9cf5e364df1fcfb006","permalink":"/projects/shenyu-2.3.0/rate-limiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/rate-limiter-plugin/","summary":"Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n The soul gateway provides a variety of current limiting algorithms, including token bucket algorithm, concurrent token bucket algorithm, leaky bucket algorithm and sliding time window algorithm.\n The implementation of current limiting algorithm of soul gateway is based on redis.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.","tags":null,"title":"RateLimiter Plugin","type":"projects","url":"/projects/shenyu-2.3.0/rate-limiter-plugin/","wordcount":497},{"author":null,"categories":null,"content":" Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n The ShenYu gateway provides a variety of current limiting algorithms, including token bucket algorithm, concurrent token bucket algorithm, leaky bucket algorithm and sliding time window algorithm.\n The implementation of current limiting algorithm of ShenYu gateway is based on redis.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.\n  Technical Solution Using redis token bucket algorithm to limit traffic.  The system generates the token at a constant rate, and then puts the token into the token bucket. The token bucket\u0026amp;rsquo;s capacity. When the bucket is full, the token put into it will be discarded. Each time requests come, you need to obtain a token from the token bucket. If there are tokens, the service will be provided; if there are no tokens, the service will be rejected.\n Flow Diagram：   Using redis leaky bucket algorithm to limit traffic.  water (request) go to the leaky bucket first. The leaky bucket goes out at a fixed speed. When the flow speed is too fast, it will overflow directly (reject service)\n Flow Diagram：   Using redis sliding time window algorithm to limit traffic.  The sliding time window maintains the count value of unit time. Whenever a requests pass, the count value will be increased by 1. When the count value exceeds the preset threshold, other requests in unit time will be rejected. If the unit time has ended, clear the counter to zero and start the next round counting.\n Flow Diagram：   Plugin Setting  In shenyu-admin\u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; rate_limiter set to enable.\n Configure redis in the plugin.\n Currently, supporting redis patterns of single, sentinel, and cluster.\n If it is a sentinel, cluster and other multi-node configuration in URL, please use ; for each instance; Division. For example, 192.168.1.1:6379; 192.168.1.2:6379。\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.\n  Plugin Detail  Introduce rateLimiter dependency in pom.xml file of the gateway.  \u0026amp;lt;!-- shenyu ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu ratelimiter plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Detailed description of the rules\n  Token bucket algorithm/Concurrent token bucket algorithm   lgorithmName：tocketBucket/concurrent\nreplenishRate：It is how many requests you allow users to execute per second, while not discarding any requests. This is the filling rate of token bucket.\nburstCapacity：it is the maximum number of requests that users are allowed to execute in one second. This is token bucket can save the number of token.\n * Leaky bucket algorithm  algorithmName：leakyBucket\nreplenishRate：The rate at which …","date":-62135596800,"description":"rateLimiter plugin","dir":"projects/shenyu/rate-limiter-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"bbc1e3a622eae2dc4af618d2d3f99e55774b191d","permalink":"/projects/shenyu/rate-limiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/rate-limiter-plugin/","summary":"Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n The ShenYu gateway provides a variety of current limiting algorithms, including token bucket algorithm, concurrent token bucket algorithm, leaky bucket algorithm and sliding time window algorithm.\n The implementation of current limiting algorithm of ShenYu gateway is based on redis.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.","tags":null,"title":"RateLimiter Plugin","type":"projects","url":"/projects/shenyu/rate-limiter-plugin/","wordcount":497},{"author":null,"categories":null,"content":" Explanation When the soul gateway makes proxy calls to the target service, it also allows users to use the redirect plugin to redirect requests.\nPlugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; redirect ,set to enable。 Introduce redirect support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Selectors and rules, only matching requests will be forwarded and redirected, please see: Selector rules。  Maven Dependency Add the plugin dependency in the pom.xml file of the soul-bootstrap project.\n\u0026amp;lt;!-- soul redirect plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul redirect plugin end--\u0026amp;gt;  Situation  As the name suggests, the redirect plugin is to re-forward and redirect uri.\n Redirect  When we configure a custom path in Rule, it should be a reachable service path. When the request is matched, the Soul Gateway will perform the 308 service jump according to the customized path.  Gateway\u0026amp;rsquo;s own interface forwarding  When the matching rules are met, the service will use the DispatcherHandler internal interface for forwarding. To implement the gateway\u0026amp;rsquo;s own interface forwarding, we need to use / as the prefix in the configuration path. The specific configuration is as shown in the figure below.  ","date":-62135596800,"description":"redirect plugin","dir":"projects/shenyu-2.3.0/redirect-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"52d52a79d85d0f1bf9ff2a1c6f7dc38ef645c5da","permalink":"/projects/shenyu-2.3.0/redirect-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/redirect-plugin/","summary":"Explanation When the soul gateway makes proxy calls to the target service, it also allows users to use the redirect plugin to redirect requests.\nPlugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; redirect ,set to enable。 Introduce redirect support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background. Selectors and rules, only matching requests will be forwarded and redirected, please see: Selector rules。  Maven Dependency Add the plugin dependency in the pom.","tags":null,"title":"Redirect Plugin","type":"projects","url":"/projects/shenyu-2.3.0/redirect-plugin/","wordcount":200},{"author":null,"categories":null,"content":" Explanation When the ShenYu gateway makes proxy calls to the target service, it also allows users to use the redirect plugin to redirect requests.\nPlugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; redirect ,set to enable。 Introduce redirect support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Selectors and rules, only matching requests will be forwarded and redirected, please see: Selector rules。  Maven Dependency Add the plugin dependency in the pom.xml file of the shenyu-bootstrap project.\n\u0026amp;lt;!-- shenyu redirect plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu redirect plugin end--\u0026amp;gt;  Situation  As the name suggests, the redirect plugin is to re-forward and redirect uri.\n Redirect  When we configure a custom path in Rule, it should be a reachable service path. When the request is matched, the ShenYu Gateway will perform the 308 service jump according to the customized path.  Gateway\u0026amp;rsquo;s own interface forwarding  When the matching rules are met, the service will use the DispatcherHandler internal interface for forwarding. To implement the gateway\u0026amp;rsquo;s own interface forwarding, we need to use / as the prefix in the configuration path. The specific configuration is as shown in the figure below.  ","date":-62135596800,"description":"redirect plugin","dir":"projects/shenyu/redirect-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f7cfc28e4eb320393e3362315a6bc4894bd3c3bc","permalink":"/projects/shenyu/redirect-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/redirect-plugin/","summary":"Explanation When the ShenYu gateway makes proxy calls to the target service, it also allows users to use the redirect plugin to redirect requests.\nPlugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; redirect ,set to enable。 Introduce redirect support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background. Selectors and rules, only matching requests will be forwarded and redirected, please see: Selector rules。  Maven Dependency Add the plugin dependency in the pom.","tags":null,"title":"Redirect Plugin","type":"projects","url":"/projects/shenyu/redirect-plugin/","wordcount":200},{"author":null,"categories":null,"content":" Explain Explain register center access config\nHTTP Registry Soul-Admin  Set the config in application.yml  soul: register: registerType: http props: checked: true # is checked zombieCheckTimes: 5 # How many times does it fail to detect the service scheduledTime: 10 # Timed detection interval time  Soul-Client  Set the config in application.yml  soul: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set http # serverList: when register type is http，set Soul-Admin address list，pls note \u0026#39;http://\u0026#39; is necessary. # port: your project port number; apply to springmvc/tars/grpc # contextPath: your project\u0026#39;s route prefix through soul gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`. # isFull: set true means providing proxy for your entire service, or only a few controller. apply to springmvc/springcloud  Zookeeper Registry Soul-Admin  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-server-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  soul: register: registerType: zookeeper serverLists : localhost:2181 props: sessionTimeout: 5000 connectionTimeout: 2000  Soul-Client  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-client-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  soul: client: registerType: zookeeper serverLists: localhost:2181 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set zookeeper # serverList: when register type is zookeeper，set zookeeper address list # port: your project port number; apply to springmvc/tars/grpc # contextPath: your project\u0026#39;s route prefix through soul gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`. # isFull: set true means providing proxy for your entire service, or only a few controller. apply to springmvc/springcloud  Etcd Registry Soul-Admin  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-server-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  soul: register: registerType: etcd serverLists : http://localhost:2379 props: etcdTimeout: 5000 etcdTTL: 5  Soul-Client  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"register center access","dir":"projects/shenyu-2.3.0/register-center-access/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"6109716e3a7d16237b74d47fefce11ad4908b60b","permalink":"/projects/shenyu-2.3.0/register-center-access/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu-2.3.0/register-center-access/","summary":"Explain Explain register center access config\nHTTP Registry Soul-Admin  Set the config in application.yml  soul: register: registerType: http props: checked: true # is checked zombieCheckTimes: 5 # How many times does it fail to detect the service scheduledTime: 10 # Timed detection interval time  Soul-Client  Set the config in application.yml  soul: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set http # serverList: when register type is http，set Soul-Admin address list，pls note 'http://' is necessary.","tags":null,"title":"Register Center Access","type":"projects","url":"/projects/shenyu-2.3.0/register-center-access/","wordcount":945},{"author":null,"categories":null,"content":" Explain Explain register center access config\nHTTP Registry Shenyu-Admin  Set the config in application.yml  shenyu: register: registerType: http props: checked: true # is checked zombieCheckTimes: 5 # How many times does it fail to detect the service scheduledTime: 10 # Timed detection interval time  Shenyu-Client  Set the config in application.yml  shenyu: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set http # serverList: when register type is http，set Shenyu-Admin address list，pls note \u0026#39;http://\u0026#39; is necessary. # port: your project port number; apply to springmvc/tars/grpc # contextPath: your project\u0026#39;s route prefix through shenyu gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`. # isFull: set true means providing proxy for your entire service, or only a few controller. apply to springmvc/springcloud  Zookeeper Registry Shenyu-Admin  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-server-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  shenyu: register: registerType: zookeeper serverLists : localhost:2181 props: sessionTimeout: 5000 connectionTimeout: 2000  Shenyu-Client  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-client-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  shenyu: client: registerType: zookeeper serverLists: localhost:2181 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set zookeeper # serverList: when register type is zookeeper，set zookeeper address list # port: your project port number; apply to springmvc/tars/grpc # contextPath: your project\u0026#39;s route prefix through shenyu gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`. # isFull: set true means providing proxy for your entire service, or only a few controller. apply to springmvc/springcloud  Etcd Registry Shenyu-Admin  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-server-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Set the config in application.yml  shenyu: register: registerType: etcd serverLists : http://localhost:2379 props: etcdTimeout: 5000 etcdTTL: 5  Shenyu-Client  Add dependency in pom.xml (Default has been added):  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"register center access","dir":"projects/shenyu/register-center-access/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"9f47f3df4d6375b1bd1805e07e6fe97e4d0dd374","permalink":"/projects/shenyu/register-center-access/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/shenyu/register-center-access/","summary":"Explain Explain register center access config\nHTTP Registry Shenyu-Admin  Set the config in application.yml  shenyu: register: registerType: http props: checked: true # is checked zombieCheckTimes: 5 # How many times does it fail to detect the service scheduledTime: 10 # Timed detection interval time  Shenyu-Client  Set the config in application.yml  shenyu: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : register type, set http # serverList: when register type is http，set Shenyu-Admin address list，pls note 'http://' is necessary.","tags":null,"title":"Register Center Access","type":"projects","url":"/projects/shenyu/register-center-access/","wordcount":945},{"author":null,"categories":null,"content":" Description  This article mainly explains three ways of register center and their principles.  Client When client server start, the register center client will be loaded by spi.\nPut data to Disruptor when spring bean load.\nSoul register client get data from Disruptor, and it will send request to register server.\nDisruptor can decouple data from operation and facilitate expansion.\nServer When Soul-Admin server start, register center server will be loaded by spi. Meanwile Disruptor will be inited too.\nSoul register server get data from register client, and then put then to Disruptor.\nSoul-Admin Disruptor consumer get data from register server by Disruptor queue, then save them to database and publish data synchronize event.\nDisruptor can decouple data from operation and buffering.\nHttp Registry Principle of http register center is simple\nCall interface of register server when Soul-Client start.\nSoul-Admin accept request, then save to database and publish data synchronize event.\nZookeeper Registry Zookeeper storage struct is:\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Zookeeper register client will save data to zookeeper when soul client is started.\nZookeeper register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be published, when uri data node update.\nEtcd Registry Etcd storage struct is:\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Etcd register client will save data to etcd when soul client is started.\nEtcd register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be published, when uri data node update.\nConsul Registry Consul register client will save URIRegisterDTO to service instance metadata, and URIRegisterDTO will disappear with service unregister.\nAnd Consul register client will save MetaDataRegisterDTO to Key/Value store, storage struct is:\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO  Consul register client will save data to consul when soul client is started.\nConsul register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be published, when uri …","date":-62135596800,"description":"register center design","dir":"projects/shenyu-2.3.0/register-center-design/","fuzzywordcount":700,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"bb8671379f38b0fee3123d2ca87bbcceb6dbde15","permalink":"/projects/shenyu-2.3.0/register-center-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/register-center-design/","summary":"Description  This article mainly explains three ways of register center and their principles.  Client When client server start, the register center client will be loaded by spi.\nPut data to Disruptor when spring bean load.\nSoul register client get data from Disruptor, and it will send request to register server.\nDisruptor can decouple data from operation and facilitate expansion.\nServer When Soul-Admin server start, register center server will be loaded by spi.","tags":null,"title":"Register Center Design","type":"projects","url":"/projects/shenyu-2.3.0/register-center-design/","wordcount":628},{"author":null,"categories":null,"content":" Description  This article mainly explains three ways of register center and their principles.  Client When client server start, the register center client will be loaded by spi.\nPut data to Disruptor when spring bean load.\nShenYu register client get data from Disruptor, and it will send request to register server.\nDisruptor can decouple data from operation and facilitate expansion.\nServer When Shenyu-Admin server start, register center server will be loaded by spi. Meanwile Disruptor will be inited too.\nShenYu register server get data from register client, and then put then to Disruptor.\nShenyu-Admin Disruptor consumer get data from register server by Disruptor queue, then save them to database and publish data synchronize event.\nDisruptor can decouple data from operation and buffering.\nHttp Registry Principle of http register center is simple\nCall interface of register server when Shenyu-Client start.\nShenyu-Admin accept request, then save to database and publish data synchronize event.\nZookeeper Registry Zookeeper storage struct is:\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Zookeeper register client will save data to zookeeper when shenyu client is started.\nZookeeper register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be published, when uri data node update.\nEtcd Registry Etcd storage struct is:\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Etcd register client will save data to etcd when shenyu client is started.\nEtcd register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be published, when uri data node update.\nConsul Registry Consul register client will save URIRegisterDTO to service instance metadata, and URIRegisterDTO will disappear with service unregister.\nAnd Consul register client will save MetaDataRegisterDTO to Key/Value store, storage struct is:\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO  Consul register client will save data to consul when shenyu client is started.\nConsul register server will keep watching the change of data node.\nTrigger selector and rule data update and event will be published, when metadata data node update.\nTrigger selector and upstream update and event will be …","date":-62135596800,"description":"register center design","dir":"projects/shenyu/register-center-design/","fuzzywordcount":700,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f8c7550141030adebe9726bcda8d44bc84aa3ff5","permalink":"/projects/shenyu/register-center-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/register-center-design/","summary":"Description  This article mainly explains three ways of register center and their principles.  Client When client server start, the register center client will be loaded by spi.\nPut data to Disruptor when spring bean load.\nShenYu register client get data from Disruptor, and it will send request to register server.\nDisruptor can decouple data from operation and facilitate expansion.\nServer When Shenyu-Admin server start, register center server will be loaded by spi.","tags":null,"title":"Register Center Design","type":"projects","url":"/projects/shenyu/register-center-design/","wordcount":628},{"author":null,"categories":null,"content":" Explanation  Resilience4j is one of the options that supports flow control and circuit breaking. Resilience4j supports flow control and circuit breaking functions for gateway.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; resilience4j set to enable. If you don\u0026amp;rsquo;t want to use it, please close the plugin in soul-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.  \u0026amp;lt;!-- soul resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul resilience4j plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector\n Resilience4j Processing Details\n timeoutDurationRate ：Configures wait time(ms) a thread waits for a permission,default value:5000。\n limitRefreshPeriod ：Configures the period of a limit refresh. After each period the rate limiter sets its permissions count back to the limitForPeriod value,default value:500。\n limitForPeriod ：Configures the number of permissions available during one limit refresh period,default value:50。\n circuitEnable ：Configures circuitBreaker enable,0:OFF,1:ON ,default value:0。\n timeoutDuration ：Configures request CircuitBreaker timeout(ms),default value:30000。\n fallbackUri ：Configures the fall back uri。\n slidingWindowSize ：Configures the size of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed,default value:100。\n slidingWindowType ：Configures the type of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed, Sliding window can either be 0:count-based or 1:time-based.,default value:0。\n minimumNumberOfCalls ：Configures the minimum number of calls which are required (per sliding window period) before the CircuitBreaker can calculate the error rate or slow call rate,default value:100。\n waitIntervalFunctionInOpenState ：Configures the circuitBreaker time(ms) of duration,default value:10。\n permittedNumberOfCallsInHalfOpenState ：Configures the number of permitted calls when the CircuitBreaker is half open,default value:10。\n failureRateThreshold ：Configures the failure rate threshold in percentage,When the failure rate is equal or greater than the threshold the CircuitBreaker transitions to open and starts short-circuiting calls,default value:50。\n automaticTransitionFromOpenToHalfOpenEnabled ：Configures automatically transition from open state to half open state,true:ON,false:OFF,default value:false。\n   ","date":-62135596800,"description":"resilience4j plugin","dir":"projects/shenyu-2.3.0/resilience4j-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"5bd49cb2dd83d0ac313fd86ee0f51405fd22d394","permalink":"/projects/shenyu-2.3.0/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/resilience4j-plugin/","summary":"Explanation  Resilience4j is one of the options that supports flow control and circuit breaking. Resilience4j supports flow control and circuit breaking functions for gateway.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; resilience4j set to enable. If you don\u0026rsquo;t want to use it, please close the plugin in soul-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.  \u0026lt;!-- soul resilience4j plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Resilience4j Plugin","type":"projects","url":"/projects/shenyu-2.3.0/resilience4j-plugin/","wordcount":296},{"author":null,"categories":null,"content":" Explanation  Resilience4j is one of the options that supports flow control and circuit breaking. Resilience4j supports flow control and circuit breaking functions for gateway.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; resilience4j set to enable. If you don\u0026amp;rsquo;t want to use it, please close the plugin in shenyu-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of shenyu project.  \u0026amp;lt;!-- shenyu resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu resilience4j plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector\n Resilience4j Processing Details\n timeoutDurationRate ：Configures wait time(ms) a thread waits for a permission,default value:5000。\n limitRefreshPeriod ：Configures the period of a limit refresh. After each period the rate limiter sets its permissions count back to the limitForPeriod value,default value:500。\n limitForPeriod ：Configures the number of permissions available during one limit refresh period,default value:50。\n circuitEnable ：Configures circuitBreaker enable,0:OFF,1:ON ,default value:0。\n timeoutDuration ：Configures request CircuitBreaker timeout(ms),default value:30000。\n fallbackUri ：Configures the fall back uri。\n slidingWindowSize ：Configures the size of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed,default value:100。\n slidingWindowType ：Configures the type of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed, Sliding window can either be 0:count-based or 1:time-based.,default value:0。\n minimumNumberOfCalls ：Configures the minimum number of calls which are required (per sliding window period) before the CircuitBreaker can calculate the error rate or slow call rate,default value:100。\n waitIntervalFunctionInOpenState ：Configures the circuitBreaker time(ms) of duration,default value:10。\n permittedNumberOfCallsInHalfOpenState ：Configures the number of permitted calls when the CircuitBreaker is half open,default value:10。\n failureRateThreshold ：Configures the failure rate threshold in percentage,When the failure rate is equal or greater than the threshold the CircuitBreaker transitions to open and starts short-circuiting calls,default value:50。\n automaticTransitionFromOpenToHalfOpenEnabled ：Configures automatically transition from open state to half open state,true:ON,false:OFF,default value:false。\n   ","date":-62135596800,"description":"resilience4j plugin","dir":"projects/shenyu/resilience4j-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"277ad5ac8f95cc74f62c2e2ec035566b56c10469","permalink":"/projects/shenyu/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/resilience4j-plugin/","summary":"Explanation  Resilience4j is one of the options that supports flow control and circuit breaking. Resilience4j supports flow control and circuit breaking functions for gateway.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; resilience4j set to enable. If you don\u0026rsquo;t want to use it, please close the plugin in shenyu-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of shenyu project.  \u0026lt;!-- shenyu resilience4j plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Resilience4j Plugin","type":"projects","url":"/projects/shenyu/resilience4j-plugin/","wordcount":296},{"author":null,"categories":null,"content":" 说明  resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。 resilience4j为网关熔断限流提供能力。  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; resilience4j，设置为开启。 如果用户不使用，则在 soul-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 resilience4j的支持。  \u0026amp;lt;!-- soul resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul resilience4j plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Resilience4j处理详解：\n timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。\n limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。\n limitForPeriod：每次刷新令牌的数量，默认值：50。\n circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。\n timeoutDuration：熔断超时时间，单位ms，默认值：30000。\n fallbackUri：降级处理的uri。\n slidingWindowSize：滑动窗口大小，默认值：100。\n slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。\n minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。\n waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。\n permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。\n failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。\n automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。\n   ","date":-62135596800,"description":"resilience4j插件","dir":"projects/shenyu-2.3.0/resilience4j-plugin/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9d05388d4ed343fb4a75d4de5e156f6418a8b97b","permalink":"/zh/projects/shenyu-2.3.0/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/resilience4j-plugin/","summary":"说明 resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。 resilience4j为网关熔断限流提供能力。 插件设置 在 soul-admin \u0026ndash;\u0026gt;","tags":null,"title":"Resilience4j插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/resilience4j-plugin/","wordcount":816},{"author":null,"categories":null,"content":" 说明  resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。 resilience4j为网关熔断限流提供能力。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; resilience4j，设置为开启。 如果用户不使用，则在 shenyu-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 resilience4j的支持。  \u0026amp;lt;!-- shenyu resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu resilience4j plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Resilience4j处理详解：\n timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。\n limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。\n limitForPeriod：每次刷新令牌的数量，默认值：50。\n circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。\n timeoutDuration：熔断超时时间，单位ms，默认值：30000。\n fallbackUri：降级处理的uri。\n slidingWindowSize：滑动窗口大小，默认值：100。\n slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。\n minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。\n waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。\n permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。\n failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。\n automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。\n   ","date":-62135596800,"description":"resilience4j插件","dir":"projects/shenyu/resilience4j-plugin/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"00ad33a7595ea68391ed047e123d88da7a346849","permalink":"/zh/projects/shenyu/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/resilience4j-plugin/","summary":"说明 resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。 resilience4j为网关熔断限流提供能力。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt;","tags":null,"title":"Resilience4j插件","type":"projects","url":"/zh/projects/shenyu/resilience4j-plugin/","wordcount":816},{"author":null,"categories":null,"content":" Explanation  When making proxy invokes to the target service, soul Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; rewrite ,set to enable. Introduce rewrite support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  \u0026amp;lt;!-- soul rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul rewrite plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only those matched request will be rewritten.  Situation  As the name suggests, rewrite is a redefinition of URI.\n When the request is matched, set the user-defined path, and the user-defined path will overwrite the previous real path.\n When invoking, the user-defined path will be used.\n  ","date":-62135596800,"description":"rewrite plugin","dir":"projects/shenyu-2.3.0/rewrite-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"40b667d396497042ea90d6f3fc9bfa9e2a2b91d8","permalink":"/projects/shenyu-2.3.0/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/rewrite-plugin/","summary":"Explanation  When making proxy invokes to the target service, soul Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; rewrite ,set to enable. Introduce rewrite support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background.  \u0026lt;!-- soul rewrite plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-rewrite\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Rewrite Plugin","type":"projects","url":"/projects/shenyu-2.3.0/rewrite-plugin/","wordcount":124},{"author":null,"categories":null,"content":" Explanation  When making proxy invokes to the target service, ShenYu Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; rewrite ,set to enable. Introduce rewrite support in the pox.xml file of the gateway. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.  \u0026amp;lt;!-- shenyu rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu rewrite plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only those matched request will be rewritten.  Situation  As the name suggests, rewrite is a redefinition of URI.\n When the request is matched, set the user-defined path, and the user-defined path will overwrite the previous real path.\n When invoking, the user-defined path will be used.\n  ","date":-62135596800,"description":"rewrite plugin","dir":"projects/shenyu/rewrite-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"bb8923e7ba9c04d4f8955f60d08d5f2d25cd3133","permalink":"/projects/shenyu/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/rewrite-plugin/","summary":"Explanation  When making proxy invokes to the target service, ShenYu Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; rewrite ,set to enable. Introduce rewrite support in the pox.xml file of the gateway. If the user don\u0026rsquo;t use, please disable the plugin in the background.  \u0026lt;!-- shenyu rewrite plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-rewrite\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"Rewrite Plugin","type":"projects","url":"/projects/shenyu/rewrite-plugin/","wordcount":124},{"author":null,"categories":null,"content":" 说明  soul网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; rewrite，设置为开启。\n 在网关的 pom.xml 文件中添加 rewrite 的支持。\n 如果用户不需要，可以把插件禁用。\n  \u0026amp;lt;!-- soul rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul rewrite plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行重写。   场景  顾名思义，重写插件就是对uri的重新定义。 当匹配到请求后，设置自定义的路径，那么自定义的路径就会覆盖之前的真实路径。 在调用的时候，就会使用用户自定义的路径。  ","date":-62135596800,"description":"rewrite插件","dir":"projects/shenyu-2.3.0/rewrite-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e64b0b10064b6d30b4b042ce1764a486ae4250f8","permalink":"/zh/projects/shenyu-2.3.0/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/rewrite-plugin/","summary":"说明 soul网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; rewrite，设置为开启。 在网关","tags":null,"title":"Rewrite插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/rewrite-plugin/","wordcount":226},{"author":null,"categories":null,"content":" 说明  ShenYu 网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; rewrite，设置为开启。\n 在网关的 pom.xml 文件中添加 rewrite 的支持。\n 如果用户不需要，可以把插件禁用。\n  \u0026amp;lt;!-- shenyu rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu rewrite plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行重写。   场景  顾名思义，重写插件就是对uri的重新定义。 当匹配到请求后，设置自定义的路径，那么自定义的路径就会覆盖之前的真实路径。 在调用的时候，就会使用用户自定义的路径。  ","date":-62135596800,"description":"rewrite插件","dir":"projects/shenyu/rewrite-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9c9d8b383055e294d31d23e7f9354d7bd69f204a","permalink":"/zh/projects/shenyu/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/rewrite-plugin/","summary":"说明 ShenYu 网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; rewrite，设置为开启。 在网关的 pom.xml 文","tags":null,"title":"Rewrite插件","type":"projects","url":"/zh/projects/shenyu/rewrite-plugin/","wordcount":223},{"author":null,"categories":null,"content":" Features  Selector and rule are the key point of soul gateway, you can manage any request with it.\n This chapter is mainly focus on the concepts of selector and rule and how to use it.\n  Overview  One plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter. Please consider this, it would be perfect when the plugin executes the request until it reached the config value. Selector and rule are designed to execute only when the request meet the specific condition. Please refer to the previous data structure database design.  Selector  selector detailed explanation：\n name：create your selector with a distinguish name. type：custom flow is customized request, full flow is full request. customized request will be handled by the conditions as below, while full request won\u0026amp;rsquo;t. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**). = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute among multi-selectors.   the above picture means: when the prefix of the request uri is /test and the value of module inheader istest, it will redirect to this service 1.1.1.1:8080.\n selector advice : combine uri conditon and match prefix（/contextPath）as the first request filter.\n  Rule  when the request was passed by the seletor, then it will be processed by the rule, the final filter.\n rule is the final confirmation about how to execute request logically.\n rule detailed explanation：\n name：create your rule with a distinguish name. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**） = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute …","date":-62135596800,"description":"detailed explanation of selector and rule","dir":"projects/shenyu-2.3.0/selector-and-rule/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"0740fe76d59119c31db584a17287329f3a8d5ada","permalink":"/projects/shenyu-2.3.0/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu-2.3.0/selector-and-rule/","summary":"Features  Selector and rule are the key point of soul gateway, you can manage any request with it.\n This chapter is mainly focus on the concepts of selector and rule and how to use it.\n  Overview  One plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter. Please consider this, it would be perfect when the plugin executes the request until it reached the config value.","tags":null,"title":"Selector Detailed Explanation","type":"projects","url":"/projects/shenyu-2.3.0/selector-and-rule/","wordcount":746},{"author":null,"categories":null,"content":" Features  Selector and rule are the key point of ShenYu Gateway, you can manage any request with it.\n This chapter is mainly focus on the concepts of selector and rule and how to use it.\n  Overview  One plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter. Please consider this, it would be perfect when the plugin executes the request until it reached the config value. Selector and rule are designed to execute only when the request meet the specific condition. Please refer to the previous data structure database design.  Selector  selector detailed explanation：\n name：create your selector with a distinguish name. type：custom flow is customized request, full flow is full request. customized request will be handled by the conditions as below, while full request won\u0026amp;rsquo;t. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**). = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute among multi-selectors.  the above picture means: when the prefix of the request uri is /test and the value of module inheader istest, it will redirect to this service 1.1.1.1:8080.\n selector advice : combine uri conditon and match prefix（/contextPath）as the first request filter.\n  Rule  when the request was passed by the seletor, then it will be processed by the rule, the final filter.\n rule is the final confirmation about how to execute request logically.\n rule detailed explanation：\n name：create your rule with a distinguish name. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**） = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute …","date":-62135596800,"description":"detailed explanation of selector and rule","dir":"projects/shenyu/selector-and-rule/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"feea45c8eda01509b674299c6e7ddfae10d59c1c","permalink":"/projects/shenyu/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/shenyu/selector-and-rule/","summary":"Features  Selector and rule are the key point of ShenYu Gateway, you can manage any request with it.\n This chapter is mainly focus on the concepts of selector and rule and how to use it.\n  Overview  One plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter. Please consider this, it would be perfect when the plugin executes the request until it reached the config value.","tags":null,"title":"Selector Detailed Explanation","type":"projects","url":"/projects/shenyu/selector-and-rule/","wordcount":746},{"author":null,"categories":null,"content":" Explanation  Sentinel is one of the options that supports flow control and circuit breaking. Sentinel supports flow control and circuit breaking functions for gateway.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sentinel set to enable. If you don\u0026amp;rsquo;t want to use it, please close the plugin in soul-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.  \u0026amp;lt;!-- soul sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sentinel plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector Sentinel Processing Details\n flowRuleEnable (1 or 0): whether enable sentinel flow control function.\n flowRuleControlBehavior: effect(reject directly/ queue/ slow start up), it do not support flow control by invocation relation.\n flowRuleGrade: type of current limit threshold(QPS or Thread Count)。\n degradeRuleEnable (1 or 0): whether enable circuit breaking function of sentinel.\n degradeRuleGrade: circuit breaker strategy, support RT of seconds level/ Error Ratio of seconds level/ Error Count of minutes level strategy.\n degradeRuleCount: threshold.\n degradeRuleTimeWindow: time of degrading(unit: second).\n fallbackUri: degraded uri after circuit breaking.\n   ","date":-62135596800,"description":"sentinel plugin","dir":"projects/shenyu-2.3.0/sentinel-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"436f8f7f23f101db112c1c791a5629b66ef348c4","permalink":"/projects/shenyu-2.3.0/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/sentinel-plugin/","summary":"Explanation  Sentinel is one of the options that supports flow control and circuit breaking. Sentinel supports flow control and circuit breaking functions for gateway.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; sentinel set to enable. If you don\u0026rsquo;t want to use it, please close the plugin in soul-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.  \u0026lt;!-- soul sentinel plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Sentinel Plugin","type":"projects","url":"/projects/shenyu-2.3.0/sentinel-plugin/","wordcount":166},{"author":null,"categories":null,"content":" Explanation  Sentinel is one of the options that supports flow control and circuit breaking. Sentinel supports flow control and circuit breaking functions for gateway.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sentinel set to enable. If you don\u0026amp;rsquo;t want to use it, please close the plugin in shenyu-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of shenyu project.  \u0026amp;lt;!-- shenyu sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sentinel plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector Sentinel Processing Details\n flowRuleEnable (1 or 0): whether enable sentinel flow control function.\n flowRuleControlBehavior: effect(reject directly/ queue/ slow start up), it do not support flow control by invocation relation.\n flowRuleGrade: type of current limit threshold(QPS or Thread Count)。\n degradeRuleEnable (1 or 0): whether enable circuit breaking function of sentinel.\n degradeRuleGrade: circuit breaker strategy, support RT of seconds level/ Error Ratio of seconds level/ Error Count of minutes level strategy.\n degradeRuleCount: threshold.\n degradeRuleTimeWindow: time of degrading(unit: second).\n fallbackUri: degraded uri after circuit breaking.\n   ","date":-62135596800,"description":"sentinel plugin","dir":"projects/shenyu/sentinel-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"da2d44f4d03a4799786eb756ddbf81df305269f6","permalink":"/projects/shenyu/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/sentinel-plugin/","summary":"Explanation  Sentinel is one of the options that supports flow control and circuit breaking. Sentinel supports flow control and circuit breaking functions for gateway.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; sentinel set to enable. If you don\u0026rsquo;t want to use it, please close the plugin in shenyu-admin.  Plugin Usage  Introducing the follow supports to the pom.xml file of shenyu project.  \u0026lt;!-- shenyu sentinel plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Sentinel Plugin","type":"projects","url":"/projects/shenyu/sentinel-plugin/","wordcount":166},{"author":null,"categories":null,"content":" 说明  sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。 sentinel为网关熔断限流提供能力。  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; sentinel，设置为开启。 如果用户不使用，则在 soul-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 sentinel的支持。  \u0026amp;lt;!-- soul sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sentinel plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Sentinel处理详解：\n 是否开启流控(1或0) ：是否开启sentinel的流控。\n 流控效果 ： 流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流。\n 限流阈值类型 ： 限流阈值类型，QPS 或线程数模式。\n 是否开启熔断(1或0) ：是否开启sentinel熔断。\n 熔断类型： 熔断策略，支持秒级 RT/秒级异常比例/分钟级异常数。\n 熔断阈值: 阈值。\n 熔断窗口大小: 降级的时间，单位为 s。\n 熔断URI: 熔断后的降级uri。\n   ","date":-62135596800,"description":"sentinel插件","dir":"projects/shenyu-2.3.0/sentinel-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"32f8e873a6f7bbf7263921f786b85b7e677b37f9","permalink":"/zh/projects/shenyu-2.3.0/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/sentinel-plugin/","summary":"说明 sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。 sentinel为网关熔断限流提供能力。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; sen","tags":null,"title":"Sentinel插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/sentinel-plugin/","wordcount":363},{"author":null,"categories":null,"content":" 说明  sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。 sentinel为网关熔断限流提供能力。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; sentinel，设置为开启。 如果用户不使用，则在 shenyu-admin 后台把此插件停用。  插件使用  在网关的 pom.xml 文件中添加 sentinel的支持。  \u0026amp;lt;!-- shenyu sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sentinel plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n Sentinel处理详解：\n 是否开启流控(1或0) ：是否开启sentinel的流控。\n 流控效果 ： 流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流。\n 限流阈值类型 ： 限流阈值类型，QPS 或线程数模式。\n 是否开启熔断(1或0) ：是否开启sentinel熔断。\n 熔断类型： 熔断策略，支持秒级 RT/秒级异常比例/分钟级异常数。\n 熔断阈值: 阈值。\n 熔断窗口大小: 降级的时间，单位为 s。\n 熔断URI: 熔断后的降级uri。\n   ","date":-62135596800,"description":"sentinel插件","dir":"projects/shenyu/sentinel-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"4f7f16f1f4223d24b55e713d77fdbc0d56e70dd8","permalink":"/zh/projects/shenyu/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/sentinel-plugin/","summary":"说明 sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。 sentinel为网关熔断限流提供能力。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; sen","tags":null,"title":"Sentinel插件","type":"projects","url":"/zh/projects/shenyu/sentinel-plugin/","wordcount":363},{"author":null,"categories":null,"content":" Description  This doc shows how to do performance optimization for shenyu.  Time Consumption  ShenYu is JVM driven and processing time for a single request is nearly between 1-3 ms.  Netty Optimization  spring-webflux is one of dependencies of ShenYu, and it uses Netty in lower layer. The demo down below demonstrates tuning ShenYu by customizing params in Netty.  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;shenyu-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   The shenyu-bootstrap module offers this class, you may modify it when benchmarking your app if necessary. You can get references of business thread model from thread model  ","date":-62135596800,"description":"performance optimization for shenyu","dir":"projects/shenyu/shenyu-optimize/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"065d233e3bc8f40ec632c6f43a2ab88c68210592","permalink":"/projects/shenyu/shenyu-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/shenyu-optimize/","summary":"Description  This doc shows how to do performance optimization for shenyu.  Time Consumption  ShenYu is JVM driven and processing time for a single request is nearly between 1-3 ms.  Netty Optimization  spring-webflux is one of dependencies of ShenYu, and it uses Netty in lower layer. The demo down below demonstrates tuning ShenYu by customizing params in Netty.  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.","tags":null,"title":"ShenYu Optimize","type":"projects","url":"/projects/shenyu/shenyu-optimize/","wordcount":133},{"author":null,"categories":null,"content":" 说明  本文主要介绍如何对 ShenYu 进行优化  本身消耗  ShenYu 本身所有的操作，都是基于 jvm 内存来匹配，本身消耗时间大概在 1-3ms 左右。  底层netty调优  ShenYu内置依赖 spring-webflux 而其底层是使用的 netty\n 我们可以自定义 netty 的相关参数来对 ShenYu 进行优化,以下是示例：\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;shenyu-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   这个类在 shenyu-bootstrap 中已经内置，在压测的时候，可以根据自己的需求来进行优化设置。\n 业务线程模型可以看线程模型\n  ","date":-62135596800,"description":"ShenYu 性能优化","dir":"projects/shenyu/shenyu-optimize/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"058e314047e70085fa43277c30f9a58c525d8f2d","permalink":"/zh/projects/shenyu/shenyu-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/shenyu-optimize/","summary":"说明 本文主要介绍如何对 ShenYu 进行优化 本身消耗 ShenYu 本身所有的操作，都是基于 jvm 内存来匹配，本身消耗时间大概在 1-3ms 左右。 底层netty调优 ShenYu内置","tags":null,"title":"ShenYu 性能优化","type":"projects","url":"/zh/projects/shenyu/shenyu-optimize/","wordcount":206},{"author":null,"categories":null,"content":" Explanation  Sign is a native plugin of soul Gateway and is used to process signature authentication of requests.  Plugin Setting  In soul-admin -\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026amp;lt;!-- soul sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sign plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only those matched requests can be authenticated by signature.\n  Add AK/SK  In soul-admin \u0026amp;ndash;\u0026amp;gt; In authentication management, click Add to add a new AK/SK。  Implementation of Gateway Technology  Adopt Ak/SK authentication technical scheme. Adopt authentication plug-in and Chain of Responsibility Pattern to realize. Take effect when the authentication plugin is enabled and all interfaces are configured for authentication.  ## Authentication Guide\n Step 1: AK/SK is assigned by the gateway. For example, the AK assigned to you is: 1test123456781 SK is: ` 506eeb535cf740d7a755cb49f4a1536\u0026amp;rsquo;\n Step 2: Decide the gateway path you want to access, such as ` /api/service/abc\u0026amp;rsquo;\n Step 3: Construct parameters (the following are general parameters)\n     Field Value Description     timestamp current timestamp(String) The number of milliseconds of the current time（gateway will filter requests the before 5 minutes）   path /api/service/abc The path that you want to request(Modify by yourself according to your configuration of gateway)   version 1.0.0 1.0.0 is a fixed string value    Sort the above two field natually according to the key, then splice fields and fields, finally splice SK. The following is a code example.\nStep 1: First, construct a Map.\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp is string format of millisecond. String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); // Value should be string format of milliseconds map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  Step 2: Sort the Keys naturally, then splice the key and values, and finally splice the SK assigned to you.\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   The returned sign value should be:path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  Step 3: Md5 encryption and then capitalization.\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   The final returned …","date":-62135596800,"description":"sign plugin","dir":"projects/shenyu-2.3.0/sign-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"96ae94718b9fbeeacfdb6524596caadf1db42d9b","permalink":"/projects/shenyu-2.3.0/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu-2.3.0/sign-plugin/","summary":"Explanation  Sign is a native plugin of soul Gateway and is used to process signature authentication of requests.  Plugin Setting  In soul-admin -\u0026gt; plugin management \u0026ndash;\u0026gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026lt;!-- soul sign plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-sign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul sign plugin end--\u0026gt;   Selectors and rules, please refer to: selector.","tags":null,"title":"Sign Plugin","type":"projects","url":"/projects/shenyu-2.3.0/sign-plugin/","wordcount":410},{"author":null,"categories":null,"content":" Explanation  Sign is a native plugin of ShenYu Gateway and is used to process signature authentication of requests.  Plugin Setting  In shenyu-admin -\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026amp;lt;!-- shenyu sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sign plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector. Only those matched requests can be authenticated by signature.  Add AK/SK  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; In authentication management, click Add to add a new AK/SK。  Implementation of Gateway Technology  Adopt Ak/SK authentication technical scheme. Adopt authentication plug-in and Chain of Responsibility Pattern to realize. Take effect when the authentication plugin is enabled and all interfaces are configured for authentication.  ## Authentication Guide\n Step 1: AK/SK is assigned by the gateway. For example, the AK assigned to you is: 1test123456781 SK is: ` 506eeb535cf740d7a755cb49f4a1536\u0026amp;rsquo;\n Step 2: Decide the gateway path you want to access, such as ` /api/service/abc\u0026amp;rsquo;\n Step 3: Construct parameters (the following are general parameters)\n     Field Value Description     timestamp current timestamp(String) The number of milliseconds of the current time（gateway will filter requests the before 5 minutes）   path /api/service/abc The path that you want to request(Modify by yourself according to your configuration of gateway)   version 1.0.0 1.0.0 is a fixed string value    Sort the above two field natually according to the key, then splice fields and fields, finally splice SK. The following is a code example.\nStep 1: First, construct a Map.\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp is string format of millisecond. String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); // Value should be string format of milliseconds map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  Step 2: Sort the Keys naturally, then splice the key and values, and finally splice the SK assigned to you.\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   The returned sign value should be:path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  Step 3: Md5 encryption and then capitalization.\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   The …","date":-62135596800,"description":"sign plugin","dir":"projects/shenyu/sign-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"60a197c04c348b8d41de5788d30d891b6e2c4971","permalink":"/projects/shenyu/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/shenyu/sign-plugin/","summary":"Explanation  Sign is a native plugin of ShenYu Gateway and is used to process signature authentication of requests.  Plugin Setting  In shenyu-admin -\u0026gt; plugin management \u0026ndash;\u0026gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026lt;!-- shenyu sign plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-sign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- shenyu sign plugin end--\u0026gt;   Selectors and rules, please refer to: selector.","tags":null,"title":"Sign Plugin","type":"projects","url":"/projects/shenyu/sign-plugin/","wordcount":410},{"author":null,"categories":null,"content":" 说明  sign插件是 soul网关自带的，用来对请求进行签名认证的插件。  插件设置  在 soul-admin -\u0026amp;gt; 插件管理中 \u0026amp;ndash;\u0026amp;gt; sign插件设置为开启。  插件使用  在网关的 pom.xml 文件中添加 sign 的支持。  \u0026amp;lt;!-- soul sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sign plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行签名认证。   新增 AK/SK  在soul-admin \u0026amp;ndash;\u0026amp;gt; 认证管理中，点击新增，新增一条 AK/SK。  网关技术实现  采用Ak/SK鉴权技术方案。 采用鉴权插件，责任链的模式来完成。 当鉴权插件开启，并配置所有接口鉴权时候生效。  鉴权使用指南  第一步：AK/SK由网关来进行分配，比如分配给你的AK为: 1TEST123456781 SK为：506EEB535CF740D7A755CB4B9F4A1536\n 第二步：确定好你要访问的网关路径 比如 /api/service/abc\n 第三步：构造参数（以下是通用参数）\n     字段 值 描述     timestamp 当前时间戳(String类型) 当前时间的毫秒数（网关会过滤掉5分钟之前的请求）   path /api/service/abc 就是你需要访问的接口路径(根据你访问网关接口自己变更)   version 1.0.0 目前定位1.0.0 写死，String类型    对上述2个字段进行key的自然排序，然后进行字段与字段值拼接最后再拼接上SK，代码示例。\n第一步：首先构造一个Map。\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); //值应该为毫秒数的字符串形式 map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  第二步：进行Key的自然排序，然后Key，Value值拼接最后再拼接分配给你的Sk。\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   你得到的sign值应该为：path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  第三步：进行Md5加密后转成大写。\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   最后得到的值为：A021BF82BE342668B78CD9ADE593D683  请求网关  假如你访问的路径为：/api/service/abc。\n 访问地址 ：http：网关的域名/api/service/abc。\n 设置header头，header头参数为：\n     字段 值 描述     timestamp 1571711067186 上述你进行签名的时候使用的时间值   appKey 1TEST123456781 分配给你的Ak值   sign A90E66763793BDBC817CF3B52AAAC041 上述得到的签名值   version 1.0.0 写死，就为这个值     签名插件会默认过滤5分钟之后的请求  如果认证不通过会返回 code 为401 message可能会有变动。 \u0026amp;quot;code\u0026amp;quot;:401,\u0026amp;quot;message\u0026amp;quot;:\u0026amp;quot;sign is not pass,Please check you sign algorithm!\u0026amp;quot;,\u0026amp;quot;data\u0026amp;quot;:null}  签名认证算法扩展  请参考开发者文档中的 扩展签名算法。  ","date":-62135596800,"description":"sign插件","dir":"projects/shenyu-2.3.0/sign-plugin/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"225ddbd731a21872ff093bc438083b9fa952e620","permalink":"/zh/projects/shenyu-2.3.0/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/sign-plugin/","summary":"说明 sign插件是 soul网关自带的，用来对请求进行签名认证的插件。 插件设置 在 soul-admin -\u0026gt; 插件管理中 \u0026ndash;\u0026gt; sign插件设置为开启。 插件使用 在网关的 pom.xml 文件","tags":null,"title":"Sign插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/sign-plugin/","wordcount":967},{"author":null,"categories":null,"content":" 说明  sign插件是 ShenYu 网关自带的，用来对请求进行签名认证的插件。  插件设置  在 shenyu-admin -\u0026amp;gt; 插件管理中 \u0026amp;ndash;\u0026amp;gt; sign插件设置为开启。  插件使用  在网关的 pom.xml 文件中添加 sign 的支持。  \u0026amp;lt;!-- shenyu sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sign plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行签名认证。   新增 AK/SK  在shenyu-admin \u0026amp;ndash;\u0026amp;gt; 认证管理中，点击新增，新增一条 AK/SK。  网关技术实现  采用Ak/SK鉴权技术方案。 采用鉴权插件，责任链的模式来完成。 当鉴权插件开启，并配置所有接口鉴权时候生效。  鉴权使用指南  第一步：AK/SK由网关来进行分配，比如分配给你的AK为: 1TEST123456781 SK为：506EEB535CF740D7A755CB4B9F4A1536\n 第二步：确定好你要访问的网关路径 比如 /api/service/abc\n 第三步：构造参数（以下是通用参数）\n     字段 值 描述     timestamp 当前时间戳(String类型) 当前时间的毫秒数（网关会过滤掉5分钟之前的请求）   path /api/service/abc 就是你需要访问的接口路径(根据你访问网关接口自己变更)   version 1.0.0 目前定位1.0.0 写死，String类型    对上述2个字段进行key的自然排序，然后进行字段与字段值拼接最后再拼接上SK，代码示例。\n第一步：首先构造一个Map。\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); //值应该为毫秒数的字符串形式 map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  第二步：进行Key的自然排序，然后Key，Value值拼接最后再拼接分配给你的Sk。\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   你得到的sign值应该为：path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  第三步：进行Md5加密后转成大写。\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   最后得到的值为：A021BF82BE342668B78CD9ADE593D683  请求网关  假如你访问的路径为：/api/service/abc。\n 访问地址 ：http：网关的域名/api/service/abc。\n 设置header头，header头参数为：\n     字段 值 描述     timestamp 1571711067186 上述你进行签名的时候使用的时间值   appKey 1TEST123456781 分配给你的Ak值   sign A90E66763793BDBC817CF3B52AAAC041 上述得到的签名值   version 1.0.0 写死，就为这个值     签名插件会默认过滤5分钟之后的请求  如果认证不通过会返回 code 为401 message可能会有变动。 \u0026amp;quot;code\u0026amp;quot;:401,\u0026amp;quot;message\u0026amp;quot;:\u0026amp;quot;sign is not pass,Please check you sign algorithm!\u0026amp;quot;,\u0026amp;quot;data\u0026amp;quot;:null}  签名认证算法扩展  请参考开发者文档中的 扩展签名算法。  ","date":-62135596800,"description":"sign插件","dir":"projects/shenyu/sign-plugin/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"18352e2e6ec4bcdbe40b2e75cf472447c95dbcfb","permalink":"/zh/projects/shenyu/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/sign-plugin/","summary":"说明 sign插件是 ShenYu 网关自带的，用来对请求进行签名认证的插件。 插件设置 在 shenyu-admin -\u0026gt; 插件管理中 \u0026ndash;\u0026gt; sign插件设置为开启。 插件使用 在网关的 pom.xml 文件中添加","tags":null,"title":"Sign插件","type":"projects","url":"/zh/projects/shenyu/sign-plugin/","wordcount":966},{"author":null,"categories":null,"content":" Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call. sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Settings  First, go to soul-admin \u0026amp;ndash;\u0026amp;gt; plug-in management-\u0026amp;gt; setting sofa is open. Then, in the configuration of sofa plug-in, config sofa\u0026amp;rsquo;s register center like this:\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   The plug-in needs to be used with a dependent starter. For details, please see: user-sofa.\n Selector\u0026amp;rsquo;s rules，see : selector。\n  Plugin Metadata  Each sofa interface method corresponds to a piece of metadata, which can be viewed in the soul-admin \u0026amp;gt; metadata management. url: It\u0026amp;rsquo;s your http urls. RPC extension parameter, corresponding to some configuration of sofa interface.If you wanna be modify it, please modify it here. Support JSON format. The following fields:  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa access soul gateway","dir":"projects/shenyu-2.3.0/sofa-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b1cd4ebaf3124254d559b68ae77de680f6f98940","permalink":"/projects/shenyu-2.3.0/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/sofa-plugin/","summary":"Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call. sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-sofa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Settings  First, go to soul-admin \u0026ndash;\u0026gt; plug-in management-\u0026gt; setting sofa is open.","tags":null,"title":"Sofa Plugin","type":"projects","url":"/projects/shenyu-2.3.0/sofa-plugin/","wordcount":153},{"author":null,"categories":null,"content":" Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call. sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Settings  First, go to shenyu-admin \u0026amp;ndash;\u0026amp;gt; plug-in management-\u0026amp;gt; setting sofa is open. Then, in the configuration of sofa plug-in, config sofa\u0026amp;rsquo;s register center like this:\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   The plug-in needs to be used with a dependent starter. For details, please see: user-sofa.\n Selector\u0026amp;rsquo;s rules，see : selector。\n  Plugin Metadata  Each sofa interface method corresponds to a piece of metadata, which can be viewed in the shenyu-admin \u0026amp;gt; metadata management. url: It\u0026amp;rsquo;s your http urls. RPC extension parameter, corresponding to some configuration of sofa interface.If you wanna be modify it, please modify it here. Support JSON format. The following fields:  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa access shenyu gateway","dir":"projects/shenyu/sofa-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"a04bde11bbb2caaa5aa9a8de07894758151079e0","permalink":"/projects/shenyu/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/sofa-plugin/","summary":"Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call. sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-sofa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Settings  First, go to shenyu-admin \u0026ndash;\u0026gt; plug-in management-\u0026gt; setting sofa is open.","tags":null,"title":"Sofa Plugin","type":"projects","url":"/projects/shenyu/sofa-plugin/","wordcount":153},{"author":null,"categories":null,"content":" Description  This article is about sofa users using sofa plug-in support,and the tutorial of connecting your own sofa service to the soul gateway. Before connecting, please start soul-admin correctly and Setup Environment Ok。  Introduce the plug-in that the gateway supports for sofa  Add the following dependencies in the gateway\u0026amp;rsquo;s pom.xml file： Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Restart the gateway service.  sofa service access gateway, you can refer to：soul-examples-sofa  Springboot\n Introduce the following dependencies :\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   backend server register center config, please look:register center access.\n Spring\n Introduce the following dependencies:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the following in the xml file of your bean definition:\n   \u0026amp;lt;bean id =\u0026amp;quot;sofaServiceBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.sofa.SofaServiceBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.register.common.config.SoulRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/your contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;your name\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  Plugin Settings  First in the soul-admin plugin management, set the …","date":-62135596800,"description":"sofa access soul gateway","dir":"projects/shenyu-2.3.0/sofa-rpc-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"dbf18467ab77e2e23b08c8970b24b98256ba0e95","permalink":"/projects/shenyu-2.3.0/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/sofa-rpc-proxy/","summary":"Description  This article is about sofa users using sofa plug-in support,and the tutorial of connecting your own sofa service to the soul gateway. Before connecting, please start soul-admin correctly and Setup Environment Ok。  Introduce the plug-in that the gateway supports for sofa  Add the following dependencies in the gateway\u0026rsquo;s pom.xml file： Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.","tags":null,"title":"Sofa RPC Proxy","type":"projects","url":"/projects/shenyu-2.3.0/sofa-rpc-proxy/","wordcount":524},{"author":null,"categories":null,"content":" Description  This article is about sofa users using sofa plugin support,and the tutorial of connecting your own sofa service to the shenyu gateway. Before connecting, please start shenyu-admin correctly and Setup Environment Ok。  Introduce the plugin that the gateway supports for sofa  Add the following dependencies in the gateway\u0026amp;rsquo;s pom.xml file： Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Restart the gateway service.  sofa service access gateway, you can refer to：shenyu-examples-sofa  Springboot\n Introduce the following dependencies :\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${shenyu.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   backend server register center config, please look:register center access.\n Spring\n Introduce the following dependencies:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the following in the xml file of your bean definition:\n   \u0026amp;lt;bean id =\u0026amp;quot;sofaServiceBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.apache.shenyu.client.sofa.SofaServiceBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.apache.shenyu.register.common.config.ShenyuRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/your contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;your name\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;isFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  Plugin Settings  First in the …","date":-62135596800,"description":"sofa access shenyu gateway","dir":"projects/shenyu/sofa-rpc-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"b69161ebf301c25d015d3a767c279f045d4124ce","permalink":"/projects/shenyu/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/sofa-rpc-proxy/","summary":"Description  This article is about sofa users using sofa plugin support,and the tutorial of connecting your own sofa service to the shenyu gateway. Before connecting, please start shenyu-admin correctly and Setup Environment Ok。  Introduce the plugin that the gateway supports for sofa  Add the following dependencies in the gateway\u0026rsquo;s pom.xml file： Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.","tags":null,"title":"Sofa RPC Proxy","type":"projects","url":"/projects/shenyu/sofa-rpc-proxy/","wordcount":524},{"author":null,"categories":null,"content":" 说明  此篇文章是 sofa 用户使用 sofa 插件支持，以及自己的 sofa 服务接入 shenyu 网关的教程。 接入前，请正确的启动 shenyu-admin 以及搭建环境 Ok。  引入网关对sofa支持的插件  在网关的 pom.xml 文件中增加如下依赖： sofa版本换成你的，注册中心的jar包换成你的，以下是参考。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   重启网关服务。  sofa服务接入网关，可以参考：shenyu-examples-sofa  springboot\n 引入以下依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${shenyu.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入\n spring\n 引入以下依赖 ：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在你的 bean定义的xml文件中新增如下 ：\n\u0026amp;lt;bean id =\u0026amp;quot;sofaServiceBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.apache.shenyu.client.sofa.SofaServiceBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;shenyuRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.apache.shenyu.register.common.config.ShenyuRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/你的contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;你的名字\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;ifFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  sofa 插件设置  首先在 shenyu-admin 插件管理中，把sofa 插件设置为开启。\n 其次在 sofa 插件中配置你的注册地址或者其他注册中心的地址.\n  {\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}    接口注册到网关  你sofa服务实现类的，方法上加上 @ShenyuSofaClient 注解，表示该接口方法注册到网关。\n 启动你的提供者，输出日志 sofa client register success 大功告成，你的sofa接口已经发布到 shenyu 网关.如果还有不懂的，可以参考 shenyu-test-sofa项目。\n  sofa用户请求以及参数说明  说白了，就是通过http的方式来请求你的sofa服务\n shenyu网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath\n  # 比如你有一个 order服务 它有一个接口，它的注册路径 /order/test/save # 现在就是通过 post方式请求网关：http://localhost:9195/order/test/save # …","date":-62135596800,"description":"sofa 接入 shenyu 网关","dir":"projects/shenyu/sofa-rpc-proxy/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"98a4314e687f51deeb23a90bd4737d27f5d9d6e3","permalink":"/zh/projects/shenyu/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/sofa-rpc-proxy/","summary":"说明 此篇文章是 sofa 用户使用 sofa 插件支持，以及自己的 sofa 服务接入 shenyu 网关的教程。 接入前，请正确的启动 shenyu-admin 以及搭建环境 Ok。 引入网关对sofa支持的插件 在","tags":null,"title":"Sofa 接入网关","type":"projects","url":"/zh/projects/shenyu/sofa-rpc-proxy/","wordcount":1069},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Sofa接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin和soul-bootstrap，另外使用zookeeper需提前下载启动。\n注：启动soul-bootstrap之前需要引入sofa依赖\n\u0026amp;lt;!-- soul sofa plugin starter--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.rpc.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- zookeeper --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sofa plugin end--\u0026amp;gt;  运行soul-examples-sofa项目 下载soul-examples-dubbo，调整application.yml 的zk注册地址为你本地，如：\ncom: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181  运行org.dromara.soul.examples.sofa.service.TestSofaApplicationmain方法启动sofa服务。\n成功启动会有如下日志：\n2021-02-10 02:31:45.599 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.sofa.api.entity.SofaSimpleTypeBean\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.605 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by Id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.soul.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findById\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;java.lang.String\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.611 INFO 2156 --- [pool-1-thread-1] …","date":-62135596800,"description":"Sofa快速开始","dir":"projects/shenyu-2.3.0/quick-start-sofa/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"12c01c559aa8008f5bcec6ef615b0871dce025ba","permalink":"/zh/projects/shenyu-2.3.0/quick-start-sofa/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-sofa/","summary":"本文档将演示了如何快速使用Sofa接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动soul-adm","tags":null,"title":"Sofa快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-sofa/","wordcount":1176},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用Sofa接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动shenyu-admin和shenyu-bootstrap，另外使用zookeeper需提前下载启动。\n注：启动shenyu-bootstrap之前需要引入sofa依赖\n\u0026amp;lt;!-- shenyu sofa plugin starter--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${sofa.rpc.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- zookeeper --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu sofa plugin end--\u0026amp;gt;  运行shenyu-examples-sofa项目 下载shenyu-examples-dubbo，调整application.yml 的zk注册地址为你本地，如：\ncom: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181  运行org.apache.shenyu.examples.sofa.service.TestSofaApplicationmain方法启动sofa服务。\n成功启动会有如下日志：\n2021-02-10 02:31:45.599 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Insert a row of data\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;insert\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/insert\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.sofa.api.entity.SofaSimpleTypeBean\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.605 INFO 2156 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : sofa client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/sofa\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;Find by Id\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;sofa\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;org.dromara.shenyu.examples.sofa.api.service.SofaSingleParamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;findById\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/sofa/findById\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;java.lang.String\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;loadbalance\\\u0026amp;quot;:\\\u0026amp;quot;hash\\\u0026amp;quot;,\\\u0026amp;quot;retries\\\u0026amp;quot;:3,\\\u0026amp;quot;timeout\\\u0026amp;quot;:-1}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 02:31:45.611 INFO 2156 --- …","date":-62135596800,"description":"Sofa快速开始","dir":"projects/shenyu/quick-start-sofa/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"b9974b8f2872407dc459a26f81449d7425dd72f6","permalink":"/zh/projects/shenyu/quick-start-sofa/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/quick-start-sofa/","summary":"本文档将演示了如何快速使用Sofa接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动shenyu","tags":null,"title":"Sofa快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-sofa/","wordcount":1192},{"author":null,"categories":null,"content":" 说明  此篇文章是sofa用户使用sofa插件支持，以及自己的sofa服务接入soul网关的教程。 接入前，请正确的启动 soul-admin以及搭建环境 Ok。  引入网关对sofa支持的插件  在网关的 pom.xml 文件中增加如下依赖： sofa版本换成你的，注册中心的jar包换成你的，以下是参考。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   重启网关服务。  sofa服务接入网关，可以参考：soul-examples-sofa  springboot\n 引入以下依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入\n spring\n 引入以下依赖 ：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在你的 bean定义的xml文件中新增如下 ：\n\u0026amp;lt;bean id =\u0026amp;quot;sofaServiceBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.sofa.SofaServiceBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulRegisterCenterConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.register.common.config.SoulRegisterCenterConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;registerType\u0026amp;quot; value=\u0026amp;quot;http\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serverList\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;props\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;map\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/你的contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;你的名字\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;entry key=\u0026amp;quot;ifFull\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/map\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  sofa 插件设置  首先在 soul-admin 插件管理中，把sofa 插件设置为开启。\n 其次在 sofa 插件中配置你的注册地址或者其他注册中心的地址.\n  {\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}    接口注册到网关  你sofa服务实现类的，方法上加上 @SoulSofaClient 注解，表示该接口方法注册到网关。\n 启动你的提供者，输出日志 sofa client register success 大功告成，你的sofa接口已经发布到 soul网关.如果还有不懂的，可以参考 soul-test-sofa项目。\n  sofa用户请求以及参数说明  说白了，就是通过http的方式来请求你的sofa服务\n soul网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath\n  # 比如你有一个 order服务 它有一个接口，它的注册路径 /order/test/save # 现在就是通过 post方式请求网关：http://localhost:9195/order/test/save # 其中 localhost:9195 为网关的ip端口，默认端口是9195 ，/order 是你sofa …","date":-62135596800,"description":"sofa接入soul网关","dir":"projects/shenyu-2.3.0/sofa-rpc-proxy/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"fe2444f2778f2b566d24ee8409f59bbf08438ba0","permalink":"/zh/projects/shenyu-2.3.0/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/sofa-rpc-proxy/","summary":"说明 此篇文章是sofa用户使用sofa插件支持，以及自己的sofa服务接入soul网关的教程。 接入前，请正确的启动 soul-admin以及搭","tags":null,"title":"Sofa接入网关","type":"projects","url":"/zh/projects/shenyu-2.3.0/sofa-rpc-proxy/","wordcount":1084},{"author":null,"categories":null,"content":" 说明  sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。 sofa插件需要配合元数据才能实现dubbo的调用，具体请看：元数据。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; sofa 设置为开启。\n 在sofa插件的配置中，配置如下：配置sofa的注册中心。\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   插件需要配合依赖 starter 进行使用，具体请看：sofa用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个sofa接口方法，都会对应一条元数据，可以在 soul-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为sofa接口的一些配置，调整的话，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa插件","dir":"projects/shenyu-2.3.0/sofa-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"faf54a1d4f9ef10024b6d1f354ad78041faa1b0c","permalink":"/zh/projects/shenyu-2.3.0/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/sofa-plugin/","summary":"说明 sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。 sofa插件需要配合元数据才能实现dubbo的","tags":null,"title":"Sofa插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/sofa-plugin/","wordcount":301},{"author":null,"categories":null,"content":" 说明  sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。 sofa插件需要配合元数据才能实现dubbo的调用，具体请看：元数据。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; sofa 设置为开启。\n 在sofa插件的配置中，配置如下：配置sofa的注册中心。\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   插件需要配合依赖 starter 进行使用，具体请看：sofa用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个sofa接口方法，都会对应一条元数据，可以在 shenyu-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为sofa接口的一些配置，调整的话，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa插件","dir":"projects/shenyu/sofa-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3a750e83f4a49538517ff97cf884711567d01bf7","permalink":"/zh/projects/shenyu/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/sofa-plugin/","summary":"说明 sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。 sofa插件需要配合元数据才能实现dubbo的","tags":null,"title":"Sofa插件","type":"projects","url":"/zh/projects/shenyu/sofa-plugin/","wordcount":301},{"author":null,"categories":null,"content":" What is the Soul? This is an asynchronous, high-performance, cross-language, responsive API gateway.\nFeatures  Support various languages (http protocol), support dubbo, spring-cloud, Grpc, Motan, Sofa, Tars protocol. Plugin design idea, plugin hot swap, easy to expand. Flexible flow filtering to meet various flow control. Built-in rich plugin support, authentication, limiting, fuse, firewall, etc. Dynamic flow configuration, high performance. Support cluster deployment, A/B Test, blue-green release.  Architecture Diagram ","date":-62135596800,"description":"This is an asynchronous, high-performance, cross-language, responsive API gateway.","dir":"projects/shenyu-2.3.0/overview/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"6f3555a4420e79ff42ce896c7d9ca27426f264a4","permalink":"/projects/shenyu-2.3.0/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/overview/","summary":" What is the Soul? This is an asynchronous, high-performance, cross-language, responsive API gateway.\nFeatures  Support various languages (http protocol), support dubbo, spring-cloud, Grpc, Motan, Sofa, Tars protocol. Plugin design idea, plugin hot swap, easy to expand. Flexible flow filtering to meet various flow control. Built-in rich plugin support, authentication, limiting, fuse, firewall, etc. Dynamic flow configuration, high performance. Support cluster deployment, A/B Test, blue-green release.  Architecture Diagram ","tags":null,"title":"Soul Introduction","type":"projects","url":"/projects/shenyu-2.3.0/overview/","wordcount":67},{"author":null,"categories":null,"content":" Description  This doc shows how to do performance optimization for soul.  Time Consumption  Soul is JVM driven and processing time for a single request is nearly between 1-3 ms.  Netty Optimization  spring-webflux is one of dependencies of soul, and it uses Netty in lower layer. The demo down below demonstrates tuning soul by customizing params in Netty.  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;soul-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   Soul-bootstrap offers this class, you may modify it when benchmarking your app if necessary. You can get references of business thread model from thread model  ","date":-62135596800,"description":"performance optimization for soul","dir":"projects/shenyu-2.3.0/soul-optimize/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"0b7c646ef689586cd939a7796db891d992f380ca","permalink":"/projects/shenyu-2.3.0/soul-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/soul-optimize/","summary":"Description  This doc shows how to do performance optimization for soul.  Time Consumption  Soul is JVM driven and processing time for a single request is nearly between 1-3 ms.  Netty Optimization  spring-webflux is one of dependencies of soul, and it uses Netty in lower layer. The demo down below demonstrates tuning soul by customizing params in Netty.  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.","tags":null,"title":"Soul Optimize","type":"projects","url":"/projects/shenyu-2.3.0/soul-optimize/","wordcount":131},{"author":null,"categories":null,"content":" 什么是Soul 这是一个异步的，高性能的，跨语言的，响应式的API网关。\n功能  支持各种语言(http协议)，支持Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars等协议。 插件化设计思想，插件热插拔，易扩展。 灵活的流量筛选，能满足各种流量控制。 内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。 流量配置动态化，性能极高。 支持集群部署，支持 A/B Test，蓝绿发布。  架构图 ","date":-62135596800,"description":"Soul是一个异步的，高性能的，跨语言的，响应式的API网关。","dir":"projects/shenyu-2.3.0/overview/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"a703a8638724328c36213a0c8dad2d7322149578","permalink":"/zh/projects/shenyu-2.3.0/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/overview/","summary":"什么是Soul 这是一个异步的，高性能的，跨语言的，响应式的API网关。 功能 支持各种语言(http协议)，支持Dubbo, Spring-Cloud, Grpc, Motan, Sofa, Tars等协","tags":null,"title":"Soul介绍","type":"projects","url":"/zh/projects/shenyu-2.3.0/overview/","wordcount":169},{"author":null,"categories":null,"content":" 说明  本文主要介绍如何对soul进行优化  本身消耗  soul本身所有的操作，都是基于jvm内存来匹配，本身消耗时间大概在 1-3 ms左右。  底层netty调优  soul内置依赖 spring-webflux 而其底层是使用的netty\n 我们可以自定义netty的相关参数来对soul 进行优化,以下是示例：\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;soul-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   这个类在 soul-bootstrap中已经内置，在压测的时候，可以根据自己的需求来进行优化设置。\n 业务线程模型可以看线程模型\n  ","date":-62135596800,"description":"soul性能优化","dir":"projects/shenyu-2.3.0/soul-optimize/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7268e05df907b8f52302fae44f739a706e63fb60","permalink":"/zh/projects/shenyu-2.3.0/soul-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/soul-optimize/","summary":"说明 本文主要介绍如何对soul进行优化 本身消耗 soul本身所有的操作，都是基于jvm内存来匹配，本身消耗时间大概在 1-3 ms左右。 底层netty","tags":null,"title":"Soul性能优化","type":"projects","url":"/zh/projects/shenyu-2.3.0/soul-optimize/","wordcount":238},{"author":null,"categories":null,"content":" Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; springCloud, set to enable. This plugin needs to cooperate with starter dependency, please refer to:user-spring. Selectors and rules, please refer to: selector.  Detail  Application name: it is your specific application name that needs to be invoked after the conditions are matched. Soul will obtain the real IP of the corresponding service and initiate http proxy calls from registration center of springCloud.   ","date":-62135596800,"description":"SpringCloud Plugin","dir":"projects/shenyu-2.3.0/spring-cloud-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"1ae39f2a18d21c6656d0dc5a6b0b221bf114fc39","permalink":"/projects/shenyu-2.3.0/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/spring-cloud-plugin/","summary":"Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026lt;!--soul springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; springCloud, set to enable.","tags":null,"title":"SpringCloud Plugin","type":"projects","url":"/projects/shenyu-2.3.0/spring-cloud-plugin/","wordcount":125},{"author":null,"categories":null,"content":" Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; springCloud, set to enable. This plugin needs to cooperate with starter dependency, please refer to:user-spring. Selectors and rules, please refer to: selector.  Detail  Application name: it is your specific application name that needs to be invoked after the conditions are matched. ShenYu will obtain the real IP of the corresponding service and initiate http proxy calls from registration center of springCloud.   ","date":-62135596800,"description":"SpringCloud Plugin","dir":"projects/shenyu/spring-cloud-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"365bc200cbed45bf20efe72522b65f76887716ca","permalink":"/projects/shenyu/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/spring-cloud-plugin/","summary":"Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026lt;!--shenyu springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--shenyu springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; springCloud, set to enable.","tags":null,"title":"SpringCloud Plugin","type":"projects","url":"/projects/shenyu/spring-cloud-plugin/","wordcount":125},{"author":null,"categories":null,"content":" Features  This article is a guide about how to integrate Spring Cloud with soul gateway quickly. Please enable springCloud plug-in in soul-admin background. Please start soul-admin successfully before integrating and Environment Setup is Ok.  Configure soul gateway as Spring Cloud proxy  add these dependencies in gateway\u0026amp;rsquo;s pom.xml:  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   If you use eureka as SpringCloud registry center.\n add these dependencies:    \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:   eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #your eureka address instance: prefer-ip-address: true   if you use nacos as Spring Cloud registry center.\n add these dependencies:    \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:   spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # your nacos address   restart your gateway service.  SpringCloud integration with gateway  add these dependencies in your project：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   backend server register center config, please look:register center access.\n add the annotation @SoulSpringCloudClient in your controller interface.\n you can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n example （1）：both /test/payment and /test/findByUserId will be handled by gateway.\n   @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @SoulSpringCloudClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO …","date":-62135596800,"description":"springCloud with soul gateway","dir":"projects/shenyu-2.3.0/spring-cloud-proxy/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"f834d18728296a7f7571a06406e36c6ed7fc7d4d","permalink":"/projects/shenyu-2.3.0/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/spring-cloud-proxy/","summary":"Features  This article is a guide about how to integrate Spring Cloud with soul gateway quickly. Please enable springCloud plug-in in soul-admin background. Please start soul-admin successfully before integrating and Environment Setup is Ok.  Configure soul gateway as Spring Cloud proxy  add these dependencies in gateway\u0026rsquo;s pom.xml:  \u0026lt;!--soul springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"SpringCloud Proxy","type":"projects","url":"/projects/shenyu-2.3.0/spring-cloud-proxy/","wordcount":475},{"author":null,"categories":null,"content":" Features  This article is a guide about how to integrate Spring Cloud with shenyu gateway quickly. Please enable springCloud plugin in shenyu-admin background. Please start shenyu-admin successfully before integrating and Environment Setup is Ok.  Configure shenyu gateway as Spring Cloud proxy  add these dependencies in gateway\u0026amp;rsquo;s pom.xml:  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   If you use eureka as SpringCloud registry center.\n add these dependencies:   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:  eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #your eureka address instance: prefer-ip-address: true   if you use nacos as Spring Cloud registry center.\n add these dependencies:   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:  spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # your nacos address   restart your gateway service.  SpringCloud integration with gateway  add these dependencies in your project：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   backend server register center config, please look:register center access.\n add the annotation @ShenyuSpringCloudClient in your controller interface.\n you can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n example （1）：both /test/payment and /test/findByUserId will be handled by gateway.\n   @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @ShenyuSpringCloudClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } …","date":-62135596800,"description":"springCloud with shenyu gateway","dir":"projects/shenyu/spring-cloud-proxy/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"d7881fcdde34df50b5d44afb00775d8b6cc3727c","permalink":"/projects/shenyu/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/spring-cloud-proxy/","summary":"Features  This article is a guide about how to integrate Spring Cloud with shenyu gateway quickly. Please enable springCloud plugin in shenyu-admin background. Please start shenyu-admin successfully before integrating and Environment Setup is Ok.  Configure shenyu gateway as Spring Cloud proxy  add these dependencies in gateway\u0026rsquo;s pom.xml:  \u0026lt;!--shenyu springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--shenyu springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"SpringCloud Proxy","type":"projects","url":"/projects/shenyu/spring-cloud-proxy/","wordcount":475},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用SpringCloud方式接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin。\n 在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- 如果使用eureka作为注册中心需要引入 --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin start end--\u0026amp;gt;  启动soul-bootstrap项目。\n运行soul-examples-springcloud、soul-examples-eureka项目 示例项目中我们使用 eureka 作为 springCloud的注册中心\n下载soul-examples-eureka、soul-examples-springcloud\n1、先启动eureka服务\n运行org.dromara.soul.examples.eureka.EurekaServerApplicationmain方法启动项目。\n2、先启动spring cloud服务\n运行org.dromara.soul.examples.springcloud.SoulTestSpringCloudApplicationmain方法启动项目。\n成功启动会有如下日志：\n2021-02-10 14:03:51.301 INFO 2860 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-02-10 14:03:51.669 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.676 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.682 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/findById\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.688 INFO 2860 --- [pool-1-thread-1] …","date":-62135596800,"description":"SpringCloud快速开始","dir":"projects/shenyu-2.3.0/quick-start-springcloud/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"777420522dca9705db34eb663052fa71cb0c52ce","permalink":"/zh/projects/shenyu-2.3.0/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-springcloud/","summary":"本文档将演示了如何快速使用SpringCloud方式接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启","tags":null,"title":"SpringCloud快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-springcloud/","wordcount":1206},{"author":null,"categories":null,"content":" 本文档将演示了如何快速使用SpringCloud方式接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动shenyu-admin。\n 在网关的 pom.xml 文件中增加如下依赖：  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- 如果使用eureka作为注册中心需要引入 --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin start end--\u0026amp;gt;  启动shenyu-bootstrap项目。\n运行shenyu-examples-springcloud、shenyu-examples-eureka项目 示例项目中我们使用 eureka 作为 springCloud的注册中心\n下载shenyu-examples-eureka、shenyu-examples-springcloud\n1、先启动eureka服务\n运行org.apache.shenyu.examples.eureka.EurekaServerApplicationmain方法启动项目。\n2、先启动spring cloud服务\n运行org.apache.shenyu.examples.springcloud.ShenyuTestSpringCloudApplicationmain方法启动项目。\n成功启动会有如下日志：\n2021-02-10 14:03:51.301 INFO 2860 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-02-10 14:03:51.669 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/save\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.676 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/path/**\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.682 INFO 2860 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils : springCloud client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;springCloud-test\u0026amp;quot;,\u0026amp;quot;context\u0026amp;quot;:\u0026amp;quot;/springcloud\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/springcloud/order/findById\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;springCloud\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/springcloud/order/findById\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true} 2021-02-10 14:03:51.688 INFO 2860 --- …","date":-62135596800,"description":"SpringCloud快速开始","dir":"projects/shenyu/quick-start-springcloud/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7faaaa6036a09350856aa26e91262252e937ef87","permalink":"/zh/projects/shenyu/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/quick-start-springcloud/","summary":"本文档将演示了如何快速使用SpringCloud方式接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境","tags":null,"title":"SpringCloud快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-springcloud/","wordcount":1226},{"author":null,"categories":null,"content":" 说明  此篇文章是教你如何将springCloud接口，快速接入到 ShenYu 网关。\n 请在 shenyu-admin 后台将 springCloud 插件设置为开启。\n 接入前，请正确的启动 shenyu-admin以及搭建环境 Ok。\n  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   如果你使用 eureka 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ # 你的eureka地址 instance: prefer-ip-address: true   如果你使用 nacos 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # 你的nacos地址   重启你的网关服务。  SpringCloud服务接入网关  在你提供服务的项目中，引入如下依赖：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入\n 在你的 controller的接口上加上 @ShenyuSpringCloudClient 注解\n 你可以把注解加到 Controller 类上面, 里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理\n 举列子 （1）： 代表 /test/payment, /test/findByUserId 都会被网关代理。\n   @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @ShenyuSpringCloudClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026amp;quot;hello world\u0026amp;quot;); return userDTO; } }   举列子 （2）： 代表 /order/save,会被网关代理,而/order/findById 则不会。  @RestController @RequestMapping(\u0026amp;quot;/order\u0026amp;quot;) @ShenyuSpringCloudClient(path = \u0026amp;quot;/order\u0026amp;quot;) …","date":-62135596800,"description":"SpringCloud接入ShenYu网关","dir":"projects/shenyu/spring-cloud-proxy/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"f7664b34dd3763b4a071b8de254dafa57dc6c0e3","permalink":"/zh/projects/shenyu/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/spring-cloud-proxy/","summary":"说明 此篇文章是教你如何将springCloud接口，快速接入到 ShenYu 网关。 请在 shenyu-admin 后台将 springCloud 插件设置为开启。 接入前，请正确的启动 shenyu-adm","tags":null,"title":"SpringCloud接入ShenYu网关","type":"projects","url":"/zh/projects/shenyu/spring-cloud-proxy/","wordcount":1354},{"author":null,"categories":null,"content":" 说明  此篇文章是教你如何将springCloud接口，快速接入到soul网关。\n 请在 soul-admin 后台将 springCloud 插件设置为开启。\n 接入前，请正确的启动 soul-admin以及搭建环境 Ok。\n  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   如果你使用 eureka 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ # 你的eureka地址 instance: prefer-ip-address: true   如果你使用 nacos 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # 你的nacos地址   重启你的网关服务。  SpringCloud服务接入网关  在你提供服务的项目中，引入如下依赖：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   注册中心详细接入配置请参考：注册中心接入\n 在你的 controller的接口上加上 @SoulSpringCloudClient 注解\n 你可以把注解加到 Controller 类上面, 里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理\n 举列子 （1）： 代表 /test/payment, /test/findByUserId 都会被网关代理。\n   @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @SoulSpringCloudClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026amp;quot;hello world\u0026amp;quot;); return userDTO; } }   举列子 （2）： 代表 /order/save,会被网关代理,而/order/findById 则不会。  @RestController @RequestMapping(\u0026amp;quot;/order\u0026amp;quot;) @SoulSpringCloudClient(path = \u0026amp;quot;/order\u0026amp;quot;) public class OrderController { …","date":-62135596800,"description":"SpringCloud接入Soul网关","dir":"projects/shenyu-2.3.0/spring-cloud-proxy/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"ee07c804d7b1576cc528907b101a9136e7ca764d","permalink":"/zh/projects/shenyu-2.3.0/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/spring-cloud-proxy/","summary":"说明 此篇文章是教你如何将springCloud接口，快速接入到soul网关。 请在 soul-admin 后台将 springCloud 插件设置为开启。 接入前，请正确的启动 soul-ad","tags":null,"title":"SpringCloud接入Soul网关","type":"projects","url":"/zh/projects/shenyu-2.3.0/spring-cloud-proxy/","wordcount":1357},{"author":null,"categories":null,"content":" 说明  该插件是用来将http协议 转成springCloud协议 的核心。  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; springCloud，设置为开启。 插件需要配合依赖 starter 进行使用，具体请看：springCloud用户。 选择器和规则，请详细看：选择器规则。  详解  应用名称：就是你根据条件匹配以后，需要调用的你的具体的应用名称。 soul会从springCloud的注册中心上面，根据应用名称获取对应的服务真实ip地址，发起http代理调用。  ","date":-62135596800,"description":"SpringCloud插件","dir":"projects/shenyu-2.3.0/spring-cloud-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5bd0c4e777829e0eb7e66eae286a379759852a75","permalink":"/zh/projects/shenyu-2.3.0/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/spring-cloud-plugin/","summary":"说明 该插件是用来将http协议 转成springCloud协议 的核心。 引入网关 springCloud的插件支持 在网关的 pom.xml 文件中引入如下依赖。 \u0026lt;!--soul","tags":null,"title":"SpringCloud插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/spring-cloud-plugin/","wordcount":272},{"author":null,"categories":null,"content":" 说明  该插件是用来将http协议 转成springCloud协议 的核心。  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--shenyu springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; springCloud，设置为开启。 插件需要配合依赖 starter 进行使用，具体请看：springCloud用户。 选择器和规则，请详细看：选择器规则。  详解  应用名称：就是你根据条件匹配以后，需要调用的你的具体的应用名称。 ShenYu 会从 springCloud 的注册中心上面，根据应用名称获取对应的服务真实ip地址，发起http代理调用。  ","date":-62135596800,"description":"SpringCloud插件","dir":"projects/shenyu/spring-cloud-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9e90bc8fd5927d99e507344df7ffc6b70067814e","permalink":"/zh/projects/shenyu/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/spring-cloud-plugin/","summary":"说明 该插件是用来将http协议 转成springCloud协议 的核心。 引入网关 springCloud的插件支持 在网关的 pom.xml 文件中引入如下依赖。 \u0026lt;!--shenyu","tags":null,"title":"SpringCloud插件","type":"projects","url":"/zh/projects/shenyu/spring-cloud-plugin/","wordcount":259},{"author":null,"categories":null,"content":" 本文档将演示如何快速使用Tars接入Soul网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动soul-admin和soul-bootstrap。\n注：soul-bootstrap需要引入tars依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.tencent.tars\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;tars-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.7.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  运行soul-examples-tars项目 下载soul-examples-tars\n修改application.yml中的host为你本地ip\n修改配置src/main/resources/SoulExampleServer.SoulExampleApp.config.conf：\n 建议弄清楚 config 的主要配置项含义, 参考开发指南 config 中的 ip 要注意提供成本机的 local=\u0026amp;hellip;, 表示开放的本机给 tarsnode 连接的端口, 如果没有 tarsnode, 可以掉这项配置 locator: registry服务的地址，必须是有ip port的，如果不需要registry来定位服务，则不需要配置； node=tars.tarsnode.ServerObj@xxxx，表示连接的 tarsnode 的地址，如果本地没有 tarsnode， 这项配置可以去掉  更多config配置说明请参考Tars官方文档\n运行org.dromara.soul.examples.tars.SoulTestTarsApplicationmain方法启动项目。\n注： 服务启动时需要在启动命令中指定配置文件地址 -Dconfig=xxx/SoulExampleServer.SoulExampleApp.config.conf\n如果不加-Dconfig参数配置会可能会如下抛异常：\ncom.qq.tars.server.config.ConfigurationException: error occurred on load server config at com.qq.tars.server.config.ConfigurationManager.loadServerConfig(ConfigurationManager.java:113) at com.qq.tars.server.config.ConfigurationManager.init(ConfigurationManager.java:57) at com.qq.tars.server.core.Server.loadServerConfig(Server.java:90) at com.qq.tars.server.core.Server.\u0026amp;lt;init\u0026amp;gt;(Server.java:42) at com.qq.tars.server.core.Server.\u0026amp;lt;clinit\u0026amp;gt;(Server.java:38) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:37) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:31) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:76) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) at org.dromara.soul.examples.tars.SoulTestTarsApplication.main(SoulTestTarsApplication.java:38) Caused by: java.lang.NullPointerException at …","date":-62135596800,"description":"Tars快速开始","dir":"projects/shenyu-2.3.0/quick-start-tars/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0bd98cb7add3418a4536c56202fb339f7fc61f3e","permalink":"/zh/projects/shenyu-2.3.0/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/quick-start-tars/","summary":"本文档将演示如何快速使用Tars接入Soul网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动soul-admi","tags":null,"title":"Tars快速开始","type":"projects","url":"/zh/projects/shenyu-2.3.0/quick-start-tars/","wordcount":911},{"author":null,"categories":null,"content":" 本文档将演示如何快速使用Tars接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。\n环境准备 请参考配置网关环境并启动shenyu-admin和shenyu-bootstrap。\n注：shenyu-bootstrap需要引入tars依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.tencent.tars\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;tars-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.7.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  运行shenyu-examples-tars项目 下载shenyu-examples-tars\n修改application.yml中的host为你本地ip\n修改配置src/main/resources/ShenyuExampleServer.ShenyuExampleApp.config.conf：\n 建议弄清楚 config 的主要配置项含义, 参考开发指南 config 中的 ip 要注意提供成本机的 local=\u0026amp;hellip;, 表示开放的本机给 tarsnode 连接的端口, 如果没有 tarsnode, 可以掉这项配置 locator: registry服务的地址，必须是有ip port的，如果不需要registry来定位服务，则不需要配置； node=tars.tarsnode.ServerObj@xxxx，表示连接的 tarsnode 的地址，如果本地没有 tarsnode， 这项配置可以去掉  更多config配置说明请参考Tars官方文档\n运行org.apache.shenyu.examples.tars.ShenyuTestTarsApplicationmain方法启动项目。\n注： 服务启动时需要在启动命令中指定配置文件地址 -Dconfig=xxx/ShenyuExampleServer.ShenyuExampleApp.config.conf\n如果不加-Dconfig参数配置会可能会如下抛异常：\ncom.qq.tars.server.config.ConfigurationException: error occurred on load server config at com.qq.tars.server.config.ConfigurationManager.loadServerConfig(ConfigurationManager.java:113) at com.qq.tars.server.config.ConfigurationManager.init(ConfigurationManager.java:57) at com.qq.tars.server.core.Server.loadServerConfig(Server.java:90) at com.qq.tars.server.core.Server.\u0026amp;lt;init\u0026amp;gt;(Server.java:42) at com.qq.tars.server.core.Server.\u0026amp;lt;clinit\u0026amp;gt;(Server.java:38) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:37) at com.qq.tars.spring.bean.PropertiesListener.onApplicationEvent(PropertiesListener.java:31) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:76) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) at org.apache.shenyu.examples.tars.ShenyuTestTarsApplication.main(ShenyuTestTarsApplication.java:38) Caused by: …","date":-62135596800,"description":"Tars快速开始","dir":"projects/shenyu/quick-start-tars/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"00c139fdec7e7dc273535bd6742c8c99cf7a1517","permalink":"/zh/projects/shenyu/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/quick-start-tars/","summary":"本文档将演示如何快速使用Tars接入ShenYu网关。您可以直接在工程下找到本文档的示例代码。 环境准备 请参考配置网关环境并启动shenyu-","tags":null,"title":"Tars快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-tars/","wordcount":932},{"author":null,"categories":null,"content":" Team Member（In no particular order）    Name Github Role Company     Xiao Yu yu199195 VP jd.com   Zhang Yonglun tuohai666 PMC jd.com   Deng Liming dengliming PMC a start-up company   Tang Yudong tydhot PMC perfma   Zhang lei SaberSola PMC helloglobal   Huang Xiaofeng huangxfchn committer shein   Ding jianming nuo-promise committer a start-up company   Feng Zhenbing fengzhenbing committer a start-up company   yangze HoldDie committer IBM    ","date":-62135596800,"description":"Team Introduction","dir":"projects/shenyu-2.3.0/team/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"20101fad31c02bc8b31661375ffcadb11481a03c","permalink":"/projects/shenyu-2.3.0/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/team/","summary":" Team Member（In no particular order）    Name Github Role Company     Xiao Yu yu199195 VP jd.com   Zhang Yonglun tuohai666 PMC jd.com   Deng Liming dengliming PMC a start-up company   Tang Yudong tydhot PMC perfma   Zhang lei SaberSola PMC helloglobal   Huang Xiaofeng huangxfchn committer shein   Ding jianming nuo-promise committer a start-up company   Feng Zhenbing fengzhenbing committer a start-up company   yangze HoldDie committer IBM    ","tags":null,"title":"Team Introduction","type":"projects","url":"/projects/shenyu-2.3.0/team/","wordcount":59},{"author":null,"categories":null,"content":" Description  This article gives an introduction to thread models in soul and usage in various scenarios.  IO And Work Thread  spring-webflux is one of dependencies of soul, and it uses Netty thread model in lower layer.  Business Thread  Use scheduling thread to execute by default. A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.  Type Switching  reactor.core.scheduler.Schedulers. -Dsoul.scheduler.type=fixed is a default config. If set to other value, a flexible thread pool will take place it.Schedulers.elastic(). -Dsoul.work.threads = xx is for configuring number of threads, the default value calculates in following formula cpu * 2 + 1 with a minimum of 16 threads.  ","date":-62135596800,"description":"thread model","dir":"projects/shenyu-2.3.0/thread/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"1943e1891b0ff49d82dd464b3f62ee52d51ffb85","permalink":"/projects/shenyu-2.3.0/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/thread/","summary":"Description  This article gives an introduction to thread models in soul and usage in various scenarios.  IO And Work Thread  spring-webflux is one of dependencies of soul, and it uses Netty thread model in lower layer.  Business Thread  Use scheduling thread to execute by default. A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.","tags":null,"title":"Thread Model","type":"projects","url":"/projects/shenyu-2.3.0/thread/","wordcount":114},{"author":null,"categories":null,"content":" Description  This article gives an introduction to thread models in ShenYu and usage in various scenarios.  IO And Work Thread  spring-webflux is one of dependencies of ShenYu, and it uses Netty thread model in lower layer.  Business Thread  Use scheduling thread to execute by default. A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.  Type Switching  reactor.core.scheduler.Schedulers. -Dshenyu.scheduler.type=fixed is a default config. If set to other value, a flexible thread pool will take place it.Schedulers.elastic(). -Dshenyu.work.threads = xx is for configuring number of threads, the default value calculates in following formula cpu * 2 + 1 with a minimum of 16 threads.  ","date":-62135596800,"description":"thread model","dir":"projects/shenyu/thread/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"762783aaa66e050bf70f72666cd737b819053604","permalink":"/projects/shenyu/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/thread/","summary":"Description  This article gives an introduction to thread models in ShenYu and usage in various scenarios.  IO And Work Thread  spring-webflux is one of dependencies of ShenYu, and it uses Netty thread model in lower layer.  Business Thread  Use scheduling thread to execute by default. A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.","tags":null,"title":"Thread Model","type":"projects","url":"/projects/shenyu/thread/","wordcount":114},{"author":null,"categories":null,"content":" Features  Data synchronization is the key of gateway high performance, which is to sync \u0026amp;lsquo;soul-admin\u0026amp;rsquo; config data into the JVM memory of soul cluster. Implementation principles, pls refer to：dataSync。 In the article, the gateway is the environment you setup. please refer to：Environment Setup.  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：   \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in springboot yaml file:   soul : sync: websocket : urls: ws://localhost:9095/websocket #urls: address of soul-admin，multi-address will be splitted with (,).   soul-admin config, enable this parameter --soul.sync.websocket=\u0026#39;\u0026#39; in soul admin, then restart service.  soul: sync: websocket:   When the connection is established, getting the full data once,then adding and upating data subsequently, which is a good performance. Support disconnection and reconnection (default 30 sec).  Zookeeper Sync  gateway setting（note: restart）\n Add these dependencies in pom.xml:\n  \u0026amp;lt;!--soul data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add these dependencies in springboot yaml file:   soul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: config with your zk address, used by the cluster environment, splitted with (,).   soul-admin config: configure the soul-admin\u0026amp;rsquo;s starting parameter with --soul.sync.zookeeper.url=\u0026#39;your address\u0026#39;,then restart the service.   soul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000   It is good to use ZooKeeper synchronization mechanism with high timeliness, but we also have to deal with the unstable environment of ZK, cluster brain splitting and other problems.   Http long-polling sync  gateway setting（note:restart）\n Add these dependencies in pom.xml：  \u0026amp;lt;!--soul data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in your springboot yaml file:   soul : sync: http: url: http://localhost:9095 #url: config with your soul-admin\u0026#39;s ip and port url, pls use (,) to split multi-admin cluster environment.   soul-admin config, configure the soul-admin\u0026amp;rsquo;s starting parameter with --soul.sync.http=\u0026#39;\u0026#39;, then restart service.  soul: sync: http:   HTTP long-polling makes the gateway lightweight, but less time-sensitive.\n It pulls according to the group key, if the data is too …","date":-62135596800,"description":"use different data-sync strategy","dir":"projects/shenyu-2.3.0/use-data-sync/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"db78d17917d61d59ef6ef600d3becdd4b2027780","permalink":"/projects/shenyu-2.3.0/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu-2.3.0/use-data-sync/","summary":"Features  Data synchronization is the key of gateway high performance, which is to sync \u0026lsquo;soul-admin\u0026rsquo; config data into the JVM memory of soul cluster. Implementation principles, pls refer to：dataSync。 In the article, the gateway is the environment you setup. please refer to：Environment Setup.  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：   \u0026lt;!--soul data sync start use websocket--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   add these config values in springboot yaml file:   soul : sync: websocket : urls: ws://localhost:9095/websocket #urls: address of soul-admin，multi-address will be splitted with (,).","tags":null,"title":"Use Different Data-Sync Strategy","type":"projects","url":"/projects/shenyu-2.3.0/use-data-sync/","wordcount":446},{"author":null,"categories":null,"content":" Features  Data synchronization is the key of gateway high performance, which is to sync \u0026amp;lsquo;shenyu-admin\u0026amp;rsquo; config data into the JVM memory of ShenYu cluster. Implementation principles, pls refer to：dataSync。 In the article, the gateway is the environment you setup. please refer to：Environment Setup.  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：  \u0026amp;lt;!--shenyu data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in springboot yaml file:  shenyu: sync: websocket : urls: ws://localhost:9095/websocket #urls: address of shenyu-admin，multi-address will be splitted with (,).   shenyu-admin config, enable this parameter --shenyu.sync.websocket=\u0026#39;\u0026#39; in shenyu admin, then restart service.  shenyu: sync: websocket:   When the connection is established, getting the full data once,then adding and upating data subsequently, which is a good performance. Support disconnection and reconnection (default 30 sec).  Zookeeper Sync  gateway setting（note: restart）\n Add these dependencies in pom.xml:\n  \u0026amp;lt;!--shenyu data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add these dependencies in springboot yaml file:  shenyu : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: config with your zk address, used by the cluster environment, splitted with (,).   shenyu-admin config: configure the shenyu-admin\u0026amp;rsquo;s starting parameter with --shenyu.sync.zookeeper.url=\u0026#39;your address\u0026#39;,then restart the service.  shenyu: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000   It is good to use ZooKeeper synchronization mechanism with high timeliness, but we also have to deal with the unstable environment of ZK, cluster brain splitting and other problems.   Http long-polling sync  gateway setting（note:restart）\n Add these dependencies in pom.xml：  \u0026amp;lt;!--shenyu data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in your springboot yaml file:  shenyu : sync: http: url: http://localhost:9095 #url: config with your shenyu-admin\u0026#39;s ip and port url, pls use (,) to split multi-admin cluster environment.   shenyu-admin config, configure the shenyu-admin\u0026amp;rsquo;s starting parameter with --shenyu.sync.http=\u0026#39;\u0026#39;, then restart service.  shenyu: sync: http:   HTTP long-polling makes the gateway lightweight, but less …","date":-62135596800,"description":"use different data-sync strategy","dir":"projects/shenyu/use-data-sync/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"863293f2c0b5790715cce947566148922dfdd4d7","permalink":"/projects/shenyu/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/shenyu/use-data-sync/","summary":"Features  Data synchronization is the key of gateway high performance, which is to sync \u0026lsquo;shenyu-admin\u0026rsquo; config data into the JVM memory of ShenYu cluster. Implementation principles, pls refer to：dataSync。 In the article, the gateway is the environment you setup. please refer to：Environment Setup.  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：  \u0026lt;!--shenyu data sync start use websocket--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-sync-data-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   add these config values in springboot yaml file:  shenyu: sync: websocket : urls: ws://localhost:9095/websocket #urls: address of shenyu-admin，multi-address will be splitted with (,).","tags":null,"title":"Use Different Data-Sync Strategy","type":"projects","url":"/projects/shenyu/use-data-sync/","wordcount":445},{"author":null,"categories":null,"content":" Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; waf set to enable. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Add configuration mode in plugin editing.  {\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.  Plugin Setting  Introducing waf dependency in the pom.xml of the gateway.  \u0026amp;lt;!-- soul waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul waf plugin end--\u0026amp;gt;   Selectors and rules, please refer to : selector When model is set to black mode, only the matched traffic will execute the rejection policy, and the unmatched traffic will be skipped directly. When model is set to mixed mode, all traffic will pass through waf plugin. For different matching traffic, users can set whether to reject or pass.  Situation  Waf is also the pre-plugin of soul, which is mainly used to intercept illegal requests or exception requests and give relevant rejection policies. When faced with replay attacks, you can intercept illegal ip and host, and set reject strategy according to matched ip or host. How to determine ip and host, please refer to: parsing-ip-and-host  ","date":-62135596800,"description":"waf plugin","dir":"projects/shenyu-2.3.0/waf-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"fb2fb1455c4907f0e07a44a87790551a55746e4f","permalink":"/projects/shenyu-2.3.0/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/waf-plugin/","summary":"Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; waf set to enable. If the user don\u0026rsquo;t use, please disable the plugin in the background. Add configuration mode in plugin editing.  {\u0026quot;model\u0026quot;:\u0026quot;black\u0026quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.","tags":null,"title":"Waf Plugin","type":"projects","url":"/projects/shenyu-2.3.0/waf-plugin/","wordcount":207},{"author":null,"categories":null,"content":" Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; waf set to enable. If the user don\u0026amp;rsquo;t use, please disable the plugin in the background. Add configuration mode in plugin editing.  {\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.  Plugin Setting  Introducing waf dependency in the pom.xml of the gateway.  \u0026amp;lt;!-- shenyu waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu waf plugin end--\u0026amp;gt;   Selectors and rules, please refer to : selector When model is set to black mode, only the matched traffic will execute the rejection policy, and the unmatched traffic will be skipped directly. When model is set to mixed mode, all traffic will pass through waf plugin. For different matching traffic, users can set whether to reject or pass.  Situation  Waf is also the pre-plugin of ShenYu, which is mainly used to intercept illegal requests or exception requests and give relevant rejection policies. When faced with replay attacks, you can intercept illegal ip and host, and set reject strategy according to matched ip or host. How to determine ip and host, please refer to: parsing-ip-and-host  ","date":-62135596800,"description":"waf plugin","dir":"projects/shenyu/waf-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"626d4ea4427cbb4d1a0172dd86a4e79ecd27df14","permalink":"/projects/shenyu/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/waf-plugin/","summary":"Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; waf set to enable. If the user don\u0026rsquo;t use, please disable the plugin in the background. Add configuration mode in plugin editing.  {\u0026quot;model\u0026quot;:\u0026quot;black\u0026quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.","tags":null,"title":"Waf Plugin","type":"projects","url":"/projects/shenyu/waf-plugin/","wordcount":207},{"author":null,"categories":null,"content":" 说明  waf插件，是网关的用来对流量实现防火墙功能的核心实现。  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; waf 设置为开启。\n 如果用户不想使用此功能，请在admin后台停用此插件。\n 插件编辑里面新增配置模式。\n  {\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # 默认为黑名单模式，设置值为 mixed 则为混合模式，下面会专门进行讲解  插件使用  在网关的 pom.xml 文件中添加 waf 的支持。  \u0026amp;lt;!-- soul waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul waf plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n 当 model 设置为 black 模式的时候，只有匹配的流量才会执行拒绝策略，不匹配的，直接会跳过。\n 当 model 设置为 mixed 模式的时候，所有的流量都会通过 waf插件，针对不同的匹配流量，用户可以设置是拒绝，还是通过。\n   场景  waf插件也是soul的前置插件，主要用来拦截非法请求，或者异常请求，并且给与相关的拒绝策略。\n 当面对重放攻击时，你可以根据ip或者host来进行匹配，拦截掉非法的ip与host，设置reject策略。\n 关于如何确定 ip 与 host 值，请看 parsing-ip-and-host\n  ","date":-62135596800,"description":"waf插件","dir":"projects/shenyu-2.3.0/waf-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0d8fdfd52f1105412a2ab155531955b8e512d0b7","permalink":"/zh/projects/shenyu-2.3.0/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/waf-plugin/","summary":"说明 waf插件，是网关的用来对流量实现防火墙功能的核心实现。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; waf 设置为开启。 如果用户不想使用此功能，请在adm","tags":null,"title":"Waf插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/waf-plugin/","wordcount":383},{"author":null,"categories":null,"content":" 说明  waf插件，是网关的用来对流量实现防火墙功能的核心实现。  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; waf 设置为开启。\n 如果用户不想使用此功能，请在admin后台停用此插件。\n 插件编辑里面新增配置模式。\n  {\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # 默认为黑名单模式，设置值为 mixed 则为混合模式，下面会专门进行讲解  插件使用  在网关的 pom.xml 文件中添加 waf 的支持。  \u0026amp;lt;!-- shenyu waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu waf plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n 当 model 设置为 black 模式的时候，只有匹配的流量才会执行拒绝策略，不匹配的，直接会跳过。\n 当 model 设置为 mixed 模式的时候，所有的流量都会通过 waf插件，针对不同的匹配流量，用户可以设置是拒绝，还是通过。\n   场景  waf插件也是 ShenYu 的前置插件，主要用来拦截非法请求，或者异常请求，并且给与相关的拒绝策略。\n 当面对重放攻击时，你可以根据ip或者host来进行匹配，拦截掉非法的 ip 与 host，设置 reject 策略。\n 关于如何确定 ip 与 host 值，请看 parsing-ip-and-host\n  ","date":-62135596800,"description":"waf插件","dir":"projects/shenyu/waf-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"f3de26ccf4036602c7f9b44e86e99f12598250f4","permalink":"/zh/projects/shenyu/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/waf-plugin/","summary":"说明 waf插件，是网关的用来对流量实现防火墙功能的核心实现。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; waf 设置为开启。 如果用户不想使用此功能，请在adm","tags":null,"title":"Waf插件","type":"projects","url":"/zh/projects/shenyu/waf-plugin/","wordcount":374},{"author":null,"categories":null,"content":" Explanation  Soul gateway also support proxy of websocket. In websocket support, divide plugin is used in it.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; divide, set to enable. Introducing dependencies in the pom.xml file of the gateway  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Request Path  When using soul proxy websocket, its request path is (example):ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket.  Detail: 1.localhost:8080 Is the IP and port started by soul. 2.module（Required）:Value is the key that matching selector. 3.method （Parameter）: Your websocket path is also used as a matching rule. 4.rpcType ：websocket must be filled in，and must be websocket   Add a new configuration to the selector in the divide plugin, as follows   Add a new rule in this selector:   In summary, pay attention to your path at this time ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket.   It will be matched by your new selector rule, and then the real websocket address of the proxy is:127.0.0.1:8080/websocket,so that soul can proxy websocket.\nYou can communicate with websocket service, it is actually very simple.\n I would like to add just one last word that you can decide the name and value of module and method by yourself as long as the selector and the rule can match, this is just an example,  ","date":-62135596800,"description":"websocket plugin","dir":"projects/shenyu-2.3.0/websocket-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"7a174b5d88be41533b1d63043b3f569975b9ab5c","permalink":"/projects/shenyu-2.3.0/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu-2.3.0/websocket-plugin/","summary":"Explanation  Soul gateway also support proxy of websocket. In websocket support, divide plugin is used in it.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; divide, set to enable. Introducing dependencies in the pom.xml file of the gateway  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Request Path  When using soul proxy websocket, its request path is (example):ws://localhost:9195/?","tags":null,"title":"Websocket Plugin","type":"projects","url":"/projects/shenyu-2.3.0/websocket-plugin/","wordcount":209},{"author":null,"categories":null,"content":" Explanation  ShenYu gateway also support proxy of websocket. In websocket support, divide plugin is used in it.  Plugin Setting  In shenyu-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; divide, set to enable. Introducing dependencies in the pom.xml file of the gateway  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Request Path  When using shenyu proxy websocket, its request path is (example):ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket.  Detail: 1.localhost:8080 is the IP and port started by ShenYu. 2.module(Required): Value is the key that matching selector. 3.method(Parameter): Your websocket path is also used as a matching rule. 4.rpcType ：websocket must be filled in，and must be websocket   Add a new configuration to the selector in the divide plugin, as follows   Add a new rule in this selector:   In summary, pay attention to your path at this time ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket.  It will be matched by your new selector rule, and then the real websocket address of the proxy is:127.0.0.1:8080/websocket,so that ShenYu can proxy websocket.\nYou can communicate with websocket service, it is actually very simple.\n I would like to add just one last word that you can decide the name and value of module and method by yourself as long as the selector and the rule can match, this is just an example,  ","date":-62135596800,"description":"websocket plugin","dir":"projects/shenyu/websocket-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1624774609,"objectID":"3ec3510ea9c0ed2fdf08b29513d988a1c4d84de5","permalink":"/projects/shenyu/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/shenyu/websocket-plugin/","summary":"Explanation  ShenYu gateway also support proxy of websocket. In websocket support, divide plugin is used in it.  Plugin Setting  In shenyu-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; divide, set to enable. Introducing dependencies in the pom.xml file of the gateway  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shenyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shenyu-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Request Path  When using shenyu proxy websocket, its request path is (example):ws://localhost:9195/?","tags":null,"title":"Websocket Plugin","type":"projects","url":"/projects/shenyu/websocket-plugin/","wordcount":209},{"author":null,"categories":null,"content":" 说明  soul网关是支持 websocket的代理。\n websocket支持中，使用了divide插件。\n  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; divide，设置为开启。\n 在网关的 pom.xml 文件中新增依赖\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  请求路径  使用soul代理websocket的时候，其请求路径为（例子）：ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket。  参数详解: 1.localhost:8080 是soul启动的ip和端口。 2.module（必填）：值是你用来匹配selector的关键 3.method （参数）: 你的 websocket路径，同时也用做匹配rule 4.rpcType ：websocket 必填，且必须为websocket   在 divide插件中选择器新增一条配置，如下   在这一条选择器下新增一条 规则：   总结，这个时候注意看你的路径 ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket。  它就会被你新增的选择器规则匹配，然后代理的的真实websocket地址为：127.0.0.1:8080/websocket，这样soul就进行的websocket的代理。\n你就可以进行和websocket服务进行通信了，就是这么简单。\n 最后再说一句，module，method 命名和值，你完全可以自己来决定，我的只是列子，只要选择器 和规则能够匹配就行。\n  ","date":-62135596800,"description":"websocket支持","dir":"projects/shenyu-2.3.0/websocket-plugin/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"6b1565bc2b9c68e372a75344974e491a9a2078e7","permalink":"/zh/projects/shenyu-2.3.0/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/websocket-plugin/","summary":"说明 soul网关是支持 websocket的代理。 websocket支持中，使用了divide插件。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; divide，设置","tags":null,"title":"Websocket支持","type":"projects","url":"/zh/projects/shenyu-2.3.0/websocket-plugin/","wordcount":623},{"author":null,"categories":null,"content":" 说明  ShenYu 网关是支持 websocket的代理。\n websocket支持中，使用了divide插件。\n  插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; divide，设置为开启。\n 在网关的 pom.xml 文件中新增依赖\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  请求路径  使用 ShenYu 代理websocket的时候，其请求路径为（例子）：ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket。  参数详解: 1.localhost:8080 是 ShenYu 启动的ip和端口。 2.module（必填）：值是你用来匹配selector的关键 3.method （参数）: 你的 websocket路径，同时也用做匹配rule 4.rpcType ：websocket 必填，且必须为websocket   在 divide插件中选择器新增一条配置，如下   在这一条选择器下新增一条 规则：   总结，这个时候注意看你的路径 ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket。  它就会被你新增的选择器规则匹配，然后代理的的真实websocket地址为：127.0.0.1:8080/websocket，这样 ShenYu 就进行的websocket的代理。\n你就可以进行和 websocket 服务进行通信了，就是这么简单。\n 最后再说一句，module，method 命名和值，你完全可以自己来决定，我的只是列子，只要选择器 和规则能够匹配就行。  ","date":-62135596800,"description":"websocket支持","dir":"projects/shenyu/websocket-plugin/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9028fd96a698ab08bff746f36498b25f87a4a1ba","permalink":"/zh/projects/shenyu/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/websocket-plugin/","summary":"说明 ShenYu 网关是支持 websocket的代理。 websocket支持中，使用了divide插件。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; divide，设置为开启","tags":null,"title":"Websocket支持","type":"projects","url":"/zh/projects/shenyu/websocket-plugin/","wordcount":603},{"author":null,"categories":null,"content":" 本文档将演示如何快速使用 gRPC 接入 ShenYu 网关。您可以直接在工程下找到本文档的 示例代码。\n1. 环境准备 请参考 配置网关环境 并启动 shenyu-admin 和 shenyu-bootstrap 。\n注：shenyu-bootstrap 需要引入 gRPC 依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2. 运行 shenyu-examples-grpc 项目 下载 shenyu-examples-grpc\n在 shenyu-examples-grpc 下执行以下命令生成 java 代码。\nmvn protobuf:compile //编译消息对象 mvn protobuf:compile-custom //依赖消息对象,生成接口服务  或者，如果你是通过 IntelliJ IDEA 打开 shenyu 工程，你可以在 Maven 工具栏中选中 protobuf:compile 和 protobuf:compile-custom，然后右键 Run Maven Build 一键生成 proto 文件对应的 java代码。\n运行 org.apache.shenyu.examples.grpc.ShenyuTestGrpcApplication 中的 main 方法启动项目。\n成功启动会有如下日志，表示将 gRPC 服务成功注册到 shenyu-admin 中。\n2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-19] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/clientStreamingFun\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;clientStreamingFun\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;stream.StreamService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;clientStreamingFun\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/clientStreamingFun\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:5000,\\\u0026amp;quot;methodType\\\u0026amp;quot;:\\\u0026amp;quot;CLIENT_STREAMING\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;172.20.10.6\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8080,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-17] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: {\u0026amp;quot;appName\u0026amp;quot;:\u0026amp;quot;127.0.0.1:8080\u0026amp;quot;,\u0026amp;quot;contextPath\u0026amp;quot;:\u0026amp;quot;/grpc\u0026amp;quot;,\u0026amp;quot;path\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;pathDesc\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;rpcType\u0026amp;quot;:\u0026amp;quot;grpc\u0026amp;quot;,\u0026amp;quot;serviceName\u0026amp;quot;:\u0026amp;quot;echo.EchoService\u0026amp;quot;,\u0026amp;quot;methodName\u0026amp;quot;:\u0026amp;quot;echo\u0026amp;quot;,\u0026amp;quot;ruleName\u0026amp;quot;:\u0026amp;quot;/grpc/echo\u0026amp;quot;,\u0026amp;quot;parameterTypes\u0026amp;quot;:\u0026amp;quot;echo.EchoRequest,io.grpc.stub.StreamObserver\u0026amp;quot;,\u0026amp;quot;rpcExt\u0026amp;quot;:\u0026amp;quot;{\\\u0026amp;quot;timeout\\\u0026amp;quot;:5000,\\\u0026amp;quot;methodType\\\u0026amp;quot;:\\\u0026amp;quot;UNARY\\\u0026amp;quot;}\u0026amp;quot;,\u0026amp;quot;enabled\u0026amp;quot;:true,\u0026amp;quot;host\u0026amp;quot;:\u0026amp;quot;172.20.10.6\u0026amp;quot;,\u0026amp;quot;port\u0026amp;quot;:8080,\u0026amp;quot;registerMetaData\u0026amp;quot;:false} 2021-06-18 19:33:32.866 INFO 11004 --- [or_consumer_-20] o.a.s.r.client.http.utils.RegisterUtils : grpc client register success: …","date":-62135596800,"description":"gRPC 快速开始","dir":"projects/shenyu/quick-start-grpc/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"cffd8006330e3fd0a9c5cc79aa02a43d2bd05612","permalink":"/zh/projects/shenyu/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/quick-start-grpc/","summary":"本文档将演示如何快速使用 gRPC 接入 ShenYu 网关。您可以直接在工程下找到本文档的 示例代码。 1. 环境准备 请参考 配置网关环境 并启动 shenyu-admin 和 shenyu-bootstrap 。 注：shenyu-b","tags":null,"title":"gRPC 快速开始","type":"projects","url":"/zh/projects/shenyu/quick-start-grpc/","wordcount":794},{"author":null,"categories":null,"content":" 说明  数据同步是指将 soul-admin 配置的数据，同步到 soul 集群中的JVM内存里面，是网关高性能的关键。\n 实现原理，请看：数据同步。\n 文中所说的网关，是指你搭建的网关环境，请看：搭建环境。\n  websocket同步（默认方式，推荐）  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：   \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:   soul : sync: websocket : urls: ws://localhost:9095/websocket #urls:是指 soul-admin的地址，如果有多个，请使用（,）分割.   soul-admin 配置，或在 soul-admin 启动参数中设置 --soul.sync.websocket=\u0026#39;\u0026#39;，然后重启服务。   soul: sync: websocket:   当建立连接以后会全量获取一次数据，以后的数据都是增量的更新与新增，性能好。\n 支持断线重连 （默认30秒）。\n  zookeeper同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n  \u0026amp;lt;!--soul data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:   soul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: 配置成你的zk地址，集群环境请使用（,）分隔   soul-admin 配置, 或在 soul-admin 启动参数中设置 --soul.sync.zookeeper.url=\u0026#39;你的地址\u0026#39;,然后重启服务。  soul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  使用zookeeper同步机制也是非常好的,时效性也高，我们生产环境使用的就是这个，但是也要处理zk环境不稳定，集群脑裂等问题.\n  http长轮询同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：  \u0026amp;lt;!--soul data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:   soul : sync: http: url: http://localhost:9095 #url: 配置成你的 soul-admin的 ip与端口地址，多个admin集群环境请使用（,）分隔。   soul-admin 配置, 或在 soul-admin 启动参数中设置 --soul.sync.http=\u0026#39;\u0026#39;,然后重启服务。  soul: sync: http:   http长轮询使得网关很轻量，时效性略低。\n 其根据分组key来拉取，如果数据量过大，过多，会有一定的影响。 什么意思呢？就是一个组下面的一个小地方更改，会拉取整个的组数据。\n 在soul-admin 集群时候，可能会有bug。\n  nacos同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n  \u0026amp;lt;!--soul data sync start use nacos--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:   soul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey: #url: 配置成你的nacos地址，集群环境请使用（,）分隔。 # 其他参数配置，请参考naocs官网。   soul-admin 配置, 或在 soul-admin 启动参数中使用 -- 的方式一个一个传值  soul: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey:   ","date":-62135596800,"description":"使用不同的数据同步策略","dir":"projects/shenyu-2.3.0/use-data-sync/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"e72907861ca3c6eab0e44268282a6a860ab001d1","permalink":"/zh/projects/shenyu-2.3.0/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/use-data-sync/","summary":"说明 数据同步是指将 soul-admin 配置的数据，同步到 soul 集群中的JVM内存里面，是网关高性能的关键。 实现原理，请看：数据同步。 文中所说的网关，是指你搭建的网","tags":null,"title":"使用不同的数据同步策略","type":"projects","url":"/zh/projects/shenyu-2.3.0/use-data-sync/","wordcount":969},{"author":null,"categories":null,"content":" 说明  数据同步是指将 shenyu-admin 配置的数据，同步到 ShenYu 集群中的JVM内存里面，是网关高性能的关键。\n 实现原理，请看：数据同步。\n 文中所说的网关，是指你搭建的网关环境，请看：搭建环境。\n  websocket同步（默认方式，推荐）  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：  \u0026amp;lt;!--shenyu data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:  shenyu: sync: websocket : urls: ws://localhost:9095/websocket #urls:是指 shenyu-admin的地址，如果有多个，请使用（,）分割.   shenyu-admin 配置，或在 shenyu-admin 启动参数中设置 --shenyu.sync.websocket=\u0026#39;\u0026#39;，然后重启服务。  shenyu: sync: websocket:   当建立连接以后会全量获取一次数据，以后的数据都是增量的更新与新增，性能好。\n 支持断线重连 （默认30秒）。\n  zookeeper同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n  \u0026amp;lt;!--shenyu data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:  shenyu: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: 配置成你的zk地址，集群环境请使用（,）分隔   shenyu-admin 配置, 或在 shenyu-admin 启动参数中设置 --shenyu.sync.zookeeper.url=\u0026#39;你的地址\u0026#39;,然后重启服务。  shenyu: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  使用zookeeper同步机制也是非常好的,时效性也高，我们生产环境使用的就是这个，但是也要处理zk环境不稳定，集群脑裂等问题.\n  http长轮询同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：  \u0026amp;lt;!--shenyu data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:  shenyu: sync: http: url: http://localhost:9095 #url: 配置成你的 shenyu-admin 的 ip 与端口地址，多个admin集群环境请使用（,）分隔。   shenyu-admin 配置, 或在 shenyu-admin 启动参数中设置 --shenyu.sync.http=\u0026#39;\u0026#39;,然后重启服务。  shenyu: sync: http:   http长轮询使得网关很轻量，时效性略低。\n 其根据分组key来拉取，如果数据量过大，过多，会有一定的影响。 什么意思呢？就是一个组下面的一个小地方更改，会拉取整个的组数据。\n 在shenyu-admin 集群时候，可能会有bug。\n  nacos同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n  \u0026amp;lt;!--shenyu data sync start use nacos--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-sync-data-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:  shenyu: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey: #url: 配置成你的nacos地址，集群环境请使用（,）分隔。 # 其他参数配置，请参考naocs官网。   shenyu-admin 配置, 或在 shenyu-admin 启动参数中使用 -- 的方式一个一个传值  shenyu: sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey:   ","date":-62135596800,"description":"使用不同的数据同步策略","dir":"projects/shenyu/use-data-sync/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"2e4b756a349fc99158ac68ef795f70c5a94515db","permalink":"/zh/projects/shenyu/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/use-data-sync/","summary":"说明 数据同步是指将 shenyu-admin 配置的数据，同步到 ShenYu 集群中的JVM内存里面，是网关高性能的关键。 实现原理，请看：数据同步。 文中所说的网关，是指你搭建的网","tags":null,"title":"使用不同的数据同步策略","type":"projects","url":"/zh/projects/shenyu/use-data-sync/","wordcount":965},{"author":null,"categories":null,"content":" 说明  本篇主要讲解在soul网关中元数据的概念，设计，以及如何对接。  技术方案  在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据同步到网关JVM内存。\n 表结构如下：\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;应用名称\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径,不能重复\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径描述\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc类型\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;服务名称\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;方法名称\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;参数类型 多个参数类型 逗号隔开\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc的扩展信息，json格式\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;更新时间\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;启用状态\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   元数据设计，目前最主要的是对dubbo的泛化调用上进行使用。\n 我重点讲一下 path 字段，在请求网关的时候，会根据你的path字段来匹配到一条数据，然后进行后续的流程.\n 重点讲一下 rpc_ext字段，如果是dubbo类型的服务接口，如果服务接口设置了group和version字段的时候，会存在这个字段。\n dubbo 类型 字段结构是 如下，那么存储的就是json格式的字符串。\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   元数据存储  每个dubbo接口方法，对应一条元数据。\n springcloud协议，只会存储一条数据， path为 /contextPath/**。\n http服务，则不会有任何数据。\n  ","date":-62135596800,"description":"元数据概念设计","dir":"projects/shenyu-2.3.0/meta-data/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"caebbc2279ca6bbe6a27edbb80f25a6fe089893a","permalink":"/zh/projects/shenyu-2.3.0/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/meta-data/","summary":"说明 本篇主要讲解在soul网关中元数据的概念，设计，以及如何对接。 技术方案 在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据","tags":null,"title":"元数据概念设计","type":"projects","url":"/zh/projects/shenyu-2.3.0/meta-data/","wordcount":611},{"author":null,"categories":null,"content":" 说明  本篇主要讲解在 ShenYu 网关中元数据的概念，设计，以及如何对接。  技术方案  在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据同步到网关JVM内存。\n 表结构如下：\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;应用名称\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径,不能重复\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径描述\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc类型\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;服务名称\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;方法名称\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;参数类型 多个参数类型 逗号隔开\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc的扩展信息，json格式\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;更新时间\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;启用状态\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   元数据设计，目前最主要的是对 dubbo 的泛化调用上进行使用。\n 我重点讲一下 path 字段，在请求网关的时候，会根据你的 path 字段来匹配到一条数据，然后进行后续的流程。\n 重点讲一下 rpc_ext字段，如果是 dubbo 类型的服务接口，如果服务接口设置了 group 和 version 字段的时候，会存在这个字段。\n dubbo 类型 字段结构是 如下，那么存储的就是 json 格式的字符串。\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   元数据存储  每个 dubbo 接口方法，对应一条元数据。\n springcloud 协议，只会存储一条数据， path为 /contextPath/**。\n http 服务，则不会有任何数据。\n  ","date":-62135596800,"description":"元数据概念设计","dir":"projects/shenyu/meta-data/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"74d0b5b9028e012f1496bd96037f2420c664e823","permalink":"/zh/projects/shenyu/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/meta-data/","summary":"说明 本篇主要讲解在 ShenYu 网关中元数据的概念，设计，以及如何对接。 技术方案 在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据同步到","tags":null,"title":"元数据概念设计","type":"projects","url":"/zh/projects/shenyu/meta-data/","wordcount":567},{"author":null,"categories":null,"content":" 团队成员（排名不分先后）    名字 github 角色 所在公司     肖宇 yu199195 VP 京东   张永伦 tuohai666 PMC 京东   邓力铭 dengliming PMC 某创业公司   汤煜冬 tydhot PMC perfma   张磊 SaberSola PMC 哈罗   黄晓峰 huangxfchn committer shein   丁剑明 nuo-promise committer 某创业公司   冯振兵 fengzhenbing committer 某创业公司   杨泽 HoldDie committer IBM    ","date":-62135596800,"description":"团队介绍","dir":"projects/shenyu-2.3.0/team/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"de486369813422e312f4d2f3f5fa51219ef319e6","permalink":"/zh/projects/shenyu-2.3.0/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/team/","summary":"团队成员（排名不分先后） 名字 github 角色 所在公司 肖宇 yu199195 VP 京东 张永伦 tuohai666 PMC 京东 邓力铭 dengliming PMC 某创业公司 汤煜冬 tydhot PMC perfma 张磊 SaberSola PMC 哈罗 黄晓峰 huangxfchn committer shein 丁剑明 nuo-promise committer 某创业","tags":null,"title":"团队介绍","type":"projects","url":"/zh/projects/shenyu-2.3.0/team/","wordcount":87},{"author":null,"categories":null,"content":" 说明  本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 soul-http-client。  自定义开发  请求方式：POST 请求路径：http://soul-admin/soul-client/springmvc-register soul-admin，表示为 admin的 ip + port 请求参数：soul网关默认的需要参数，通过body里面传，json类型。 json { \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //应用名称 必填 \u0026amp;quot;contextPath\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //请求前缀 必填 \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径需要唯一 必填 \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径描述 \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //rpc类型 必填 \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //服务host 必填 \u0026amp;quot;port\u0026amp;quot;: xxx, //服务端口 必填 \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //可以同path一样 必填 \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //是否开启 \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //是否需要注册元数据 }   ","date":-62135596800,"description":"多语言http客户端","dir":"projects/shenyu-2.3.0/developer-soul-client/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0a1ac2523e1d5df7f8c4fbbfa0698efdde621ba5","permalink":"/zh/projects/shenyu-2.3.0/developer-soul-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/developer-soul-client/","summary":"说明 本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 soul-http-client。 自定义开发 请求方式：POST 请求路径：h","tags":null,"title":"多语言http客户端","type":"projects","url":"/zh/projects/shenyu-2.3.0/developer-soul-client/","wordcount":288},{"author":null,"categories":null,"content":" 说明  本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 shenyu-http-client。  自定义开发  请求方式：POST 请求路径：http://shenyu-admin/shenyu-client/springmvc-register shenyu-admin，表示为 admin的 ip + port 请求参数：shenyu网关默认的需要参数，通过body里面传，json类型。 json { \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //应用名称 必填 \u0026amp;quot;context\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //请求前缀 必填 \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径需要唯一 必填 \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径描述 \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //rpc类型 必填 \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //服务host 必填 \u0026amp;quot;port\u0026amp;quot;: xxx, //服务端口 必填 \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //可以同path一样 必填 \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //是否开启 \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //是否需要注册元数据 }   ","date":-62135596800,"description":"多语言http客户端","dir":"projects/shenyu/developer-shenyu-client/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5efb423f67243f95c5eb988d0bdaf0b37e18b0c4","permalink":"/zh/projects/shenyu/developer-shenyu-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/developer-shenyu-client/","summary":"说明 本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 shenyu-http-client。 自定义开发 请求方式：POST 请求路径","tags":null,"title":"多语言http客户端","type":"projects","url":"/zh/projects/shenyu/developer-shenyu-client/","wordcount":298},{"author":null,"categories":null,"content":" 说明  字典管理主要用来维护和管理公用数据字典  表设计  sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;主键id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;类型\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典编码\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典名称\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典值\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典描述或备注\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;排序\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;是否开启\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;  * 目前使用场景是插件处理配置data_type=3下拉框时使用 假如sentinel插件处理字段中的degradeRuleGrade 那么新增规则时，编辑degradeRuleGrade字段时会自动从字典表查出type=degradeRuleGrade的所有字典作为下拉选项。  ","date":-62135596800,"description":"字典管理详解","dir":"projects/shenyu-2.3.0/dictionary-management/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9ebfe82e4693251d248e32b68fa8901d88fe69b2","permalink":"/zh/projects/shenyu-2.3.0/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/dictionary-management/","summary":"说明 字典管理主要用来维护和管理公用数据字典 表设计 sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '主键id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '类型', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '字典编","tags":null,"title":"字典管理","type":"projects","url":"/zh/projects/shenyu-2.3.0/dictionary-management/","wordcount":314},{"author":null,"categories":null,"content":" 说明  字典管理主要用来维护和管理公用数据字典  表设计  sql  CREATE TABLE IF NOT EXISTS `shenyu_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;主键id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;类型\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典编码\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典名称\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典值\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典描述或备注\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;排序\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;是否开启\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;   目前使用场景是插件处理配置 data_type=3 下拉框时使用  例如 Sentinel 插件处理字段中的 degradeRuleGrade。当新增规则时，编辑 degradeRuleGrade 字段时，会自动从 shenyu_dict 查出 type=\u0026#39;degradeRuleGrade\u0026#39; 的所有字典作为下拉选项。\n","date":-62135596800,"description":"字典管理详解","dir":"projects/shenyu/dictionary-management/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"60714ac453a26d3cd81f211a9fdef27364458284","permalink":"/zh/projects/shenyu/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/dictionary-management/","summary":"说明 字典管理主要用来维护和管理公用数据字典 表设计 sql CREATE TABLE IF NOT EXISTS `shenyu_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '主键id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '类型', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '字典编码","tags":null,"title":"字典管理","type":"projects","url":"/zh/projects/shenyu/dictionary-management/","wordcount":259},{"author":null,"categories":null,"content":" 说明  在soul-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的自定义处理字段。 该功能主要是用来支持插件处理模板化配置的  表设计  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;插件id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;字段\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;标签\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;数据类型 1 数字 2 字符串 3 下拉框\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;类型,1 表示选择器，2 表示规则\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;排序\u0026#39;, `ext_obj` varchar(1024) DEFAULT NULL COMMENT \u0026#39;额外配置（json格式数据）\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB;  使用教程 比如开发springCloud插件时规则表需要存一些配置到handle字段，配置对应的实体类如下：\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; }   第一步、我们可以直接在插件管理界面 http://localhost:9095/#/system/plugin 点击编辑插件处理 第二步、新增一个字符串类型字段path和一个数字类型的timeout\n第三步、在插件规则配置页面新增规则时就可以直接输入path、timeout然后提交保存到handle字段了\n_注意：如果配置了data_type为3 选择框，则规则新增页面里输入框下拉选择是通过field字段去字典表（soul_dict）查出所有可选项出来展示选择_。\n 比如sentinel插件包含多种数据类型的字段，如下图：  ","date":-62135596800,"description":"插件处理详解","dir":"projects/shenyu-2.3.0/plugin-handle-explanation/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"c72bd65adcf3c5a2cce8829c00bbfb2707087ea0","permalink":"/zh/projects/shenyu-2.3.0/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/plugin-handle-explanation/","summary":"说明 在soul-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的自定","tags":null,"title":"插件处理详解","type":"projects","url":"/zh/projects/shenyu-2.3.0/plugin-handle-explanation/","wordcount":562},{"author":null,"categories":null,"content":" 说明  在shenyu-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的自定义处理字段。 该功能主要是用来支持插件处理模板化配置的  表设计  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;插件id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;字段\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;标签\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;数据类型 1 数字 2 字符串 3 下拉框\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;类型,1 表示选择器，2 表示规则\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;排序\u0026#39;, `ext_obj` varchar(1024) DEFAULT NULL COMMENT \u0026#39;额外配置（json格式数据）\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB;  使用教程 比如开发springCloud插件时规则表需要存一些配置到handle字段，配置对应的实体类如下：\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; }   第一步、我们可以直接在插件管理界面 http://localhost:9095/#/system/plugin 点击编辑插件处理\n第二步、新增一个字符串类型字段path和一个数字类型的timeout\n第三步、在插件规则配置页面新增规则时就可以直接输入path、timeout然后提交保存到handle字段了\n注意：如果配置了data_type为3 选择框，则规则新增页面里输入框下拉选择是通过field字段去字典表（shenyu_dict）查出所有可选项出来展示选择。\n 比如sentinel插件包含多种数据类型的字段，如下图：  ","date":-62135596800,"description":"插件处理详解","dir":"projects/shenyu/plugin-handle-explanation/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"54f489917c9c3f70f184027b7628027a782b4017","permalink":"/zh/projects/shenyu/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/plugin-handle-explanation/","summary":"说明 在shenyu-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的","tags":null,"title":"插件处理详解","type":"projects","url":"/zh/projects/shenyu/plugin-handle-explanation/","wordcount":564},{"author":null,"categories":null,"content":" 说明  插件是 soul 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。 在soul 网关里面，插件其实分为2 类。  一类是单一职责的调用链，不能对流量进行自定义的筛选。 另一类，能对匹配的流量，执行自己的职责调用链。  用户可以参考 soul-plugin 模块，新增自己的插件处理，如果有好的公用插件，请把代码提交上来。  单一职责插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  用户新增一个类 A，直接实现 org.dromara.soul.plugin.api.SoulPlugin\n  public interface SoulPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link SoulPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, SoulPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must Provide the right name. * if you impl AbstractSoulPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }   接口方法详细说明\n execute() 方法为核心的执行方法，用户可以在里面自由的实现自己想要的功能。\n getOrder() 指定插件的排序。\n named() 指定插件的名称。\n skip() 在特定的条件下，该插件是否被跳过。\n  注册成Spring的bean，参考如下，或者直接在实现类上加 @Component 注解。\n  @Bean public SoulPlugin a() { return new A(); }  匹配流量处理插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   新增一个类A，继承 org.dromara.soul.plugin.base.AbstractSoulPlugin\n 以下是参考：\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractSoulPlugin so you must user soul-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractSoulPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int */ @Override public int getOrder() { return 0; } /** * acquire plugin name. * return you custom plugin name. * It must be the same name as the plug-in you added in the admin background. * * @return plugin name. */ @Override public String named() { return \u0026amp;quot;soul\u0026amp;quot;; } /** * plugin is execute. * Do I need to skip. * if you need skip return true. * * @param exchange the current server exchange * @return default false. */ @Override public Boolean skip(final ServerWebExchange exchange) { return false; } @Override protected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(ServerWebExchange exchange, SoulPluginChain chain, SelectorZkDTO selector, RuleZkDTO rule) { …","date":-62135596800,"description":"插件扩展","dir":"projects/shenyu-2.3.0/custom-plugin/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"dd48fd2f7b62d8e828c936d8f1da2a38dde9a94a","permalink":"/zh/projects/shenyu-2.3.0/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/custom-plugin/","summary":"说明 插件是 soul 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。 在soul 网关里面，插件其实分为2 类。 一类是单一职责","tags":null,"title":"插件扩展","type":"projects","url":"/zh/projects/shenyu-2.3.0/custom-plugin/","wordcount":1283},{"author":null,"categories":null,"content":" 说明  插件是 ShenYu 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。 在 ShenYu 网关里面，插件其实分为2 类。  一类是单一职责的调用链，不能对流量进行自定义的筛选。 另一类，能对匹配的流量，执行自己的职责调用链。  用户可以参考 shenyu-plugin 模块，新增自己的插件处理，如果有好的公用插件，请把代码提交上来。  单一职责插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  用户新增一个类 A，直接实现 org.apache.shenyu.plugin.api.ShenyuPlugin\n  public interface ShenyuPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link ShenyuPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, ShenyuPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must Provide the right name. * if you impl AbstractShenyuPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }   接口方法详细说明\n execute() 方法为核心的执行方法，用户可以在里面自由的实现自己想要的功能。\n getOrder() 指定插件的排序。\n named() 指定插件的名称。\n skip() 在特定的条件下，该插件是否被跳过。\n  注册成Spring的bean，参考如下，或者直接在实现类上加 @Component 注解。\n  @Bean public ShenyuPlugin a() { return new A(); }  匹配流量处理插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   新增一个类A，继承 org.apache.shenyu.plugin.base.AbstractShenyuPlugin\n 以下是参考：\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractShenyuPlugin so you must user shenyu-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractShenyuPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int */ @Override public int getOrder() { return 0; } /** * acquire plugin name. * return you custom plugin name. * It must be the same name as the plug-in you added in the admin background. * * @return plugin name. */ @Override public String named() { return \u0026amp;quot;shenyu\u0026amp;quot;; } /** * plugin is execute. * Do I need to skip. * if you need skip return true. * * @param exchange the current server exchange * @return default false. */ @Override public Boolean skip(final ServerWebExchange exchange) { return false; } @Override protected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(ServerWebExchange exchange, ShenyuPluginChain chain, SelectorZkDTO …","date":-62135596800,"description":"插件扩展","dir":"projects/shenyu/custom-plugin/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5e3d2b6d7e012900c17fba7670651956d536d7e2","permalink":"/zh/projects/shenyu/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/custom-plugin/","summary":"说明 插件是 ShenYu 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。 在 ShenYu 网关里面，插件其实分为2 类。 一类是单一职责的调用","tags":null,"title":"插件扩展","type":"projects","url":"/zh/projects/shenyu/custom-plugin/","wordcount":1171},{"author":null,"categories":null,"content":" 说明 本篇主要讲解数据库同步的三种方式，以及原理。\n前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，Soul 网关又是如何支持动态配置的呢？\n使用过 Soul 的同学都知道，Soul 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 Soul 网关过程中，用户也反馈了不少问题\n 依赖 zookeeper，这让使用 etcd、consul、nacos 注册中心的用户很是困扰 依赖 redis、influxdb，我还没有使用限流插件、监控插件，为什么需要这些  因此，我们对 Soul 进行了局部重构，历时两个月的版本迭代，我们发布了 2.0 版本\n 数据同步方式移除了对 zookeeper 的强依赖，新增 http 长轮询 以及 websocket 限流插件与监控插件实现真正的动态配置，由之前的 yml 配置，改为 admin 后台用户动态配置  配置同步为什么不使用配置中心呢？\n首先，引入配置中心，会增加很多额外的成本，不光是运维，而且会让 Soul 变得很重；另外，使用配置中心，数据格式不可控，不便于 soul-admin 进行配置管理。\n动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？\nsoul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。\n原理分析 先来张高清无码图，下图展示了 Soul 数据同步的流程，Soul 网关在启动时，会从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 Soul 网关，具体是 push 模式，还是 pull 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。 在 1.x 版本中，配置服务依赖 zookeeper 实现，管理后台将变更信息 push 给网关。而 2.x 版本支持 websocket、http、zookeeper，通过 soul.sync.strategy 指定对应的同步策略，默认使用 websocket 同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，soul-web 和 soul-admin 必须使用相同的同步机制。\n如下图所示，soul-admin 在用户发生配置变更之后，会通过 EventPublisher 发出配置变更通知，由 EventDispatcher 处理该变更通知，然后根据配置的同步策略(http、websocket、zookeeper)，将配置发送给对应的事件处理器\n 如果是 websocket 同步策略，则将变更后的数据主动推送给 soul-web，并且在网关层，会有对应的 WebsocketCacheHandler 处理器来处理 admin 的数据推送 如果是 zookeeper 同步策略，将变更数据更新到 zookeeper，而 ZookeeperSyncCache 会监听到 zookeeper 的数据变更，并予以处理 如果是 http 同步策略，soul-web 主动发起长轮询请求，默认有 90s 超时时间，如果 soul-admin 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求   Zookeeper同步 基于 zookeeper 的同步原理很简单，主要是依赖 zookeeper 的 watch 机制，soul-web 会监听配置的节点，soul-admin 在启动的时候，会将数据全量写入 zookeeper，后续数据发生变更时，会增量更新 zookeeper 的节点，与此同时，soul-web 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。\nsoul 将配置信息写到zookeeper节点，是通过精细设计的。\nWebsocket同步 websocket 和 zookeeper 机制有点类似，将网关与 admin 建立好 websocket 连接时，admin 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 websocket 主动推送给 soul-web\n使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。soul使用java-websocket 这个第三方库来进行websocket连接。\npublic class WebsocketSyncCache extends WebsocketCacheHandler { /** * The Client. */ private WebSocketClient client; public WebsocketSyncCache(final SoulConfig.WebsocketConfig websocketConfig) { ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, SoulThreadFactory.create(\u0026amp;quot;websocket-connect\u0026amp;quot;, true)); client = new WebSocketClient(new URI(websocketConfig.getUrl())) { @Override public void onOpen(final ServerHandshake serverHandshake) { //.... } @Override public void onMessage(final String result) { //.... } }; //进行连接 client.connectBlocking(); //使用调度线程池进行断线重连，30秒进行一次 executor.scheduleAtFixedRate(() -\u0026amp;gt; { if (client != null \u0026amp;amp;\u0026amp;amp; client.isClosed()) { client.reconnectBlocking(); } }, 10, 30, TimeUnit.SECONDS); }  Http长轮询 zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 Apollo、Nacos 的设计思想，取其精华，自己实现了 http 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！\nhttp 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多会等待 90s，这样便于 admin 配置服务及时响 …","date":-62135596800,"description":"数据同步设计","dir":"projects/shenyu-2.3.0/data-sync/","fuzzywordcount":2900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"c57ce09e6b9924b9429d1fceb57620fc5d09af86","permalink":"/zh/projects/shenyu-2.3.0/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu-2.3.0/data-sync/","summary":"说明 本篇主要讲解数据库同步的三种方式，以及原理。 前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在","tags":null,"title":"数据同步设计","type":"projects","url":"/zh/projects/shenyu-2.3.0/data-sync/","wordcount":2813},{"author":null,"categories":null,"content":" 说明 本篇主要讲解数据库同步的三种方式，以及原理。\n前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，ShenYu 网关又是如何支持动态配置的呢？\n使用过 ShenYu 的同学都知道，ShenYu 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 ShenYu 网关过程中，用户也反馈了不少问题\n 依赖 zookeeper，这让使用 etcd、consul、nacos 注册中心的用户很是困扰 依赖 redis、influxdb，我还没有使用限流插件、监控插件，为什么需要这些  因此，我们对 ShenYu 进行了局部重构，历时两个月的版本迭代，我们发布了 2.0 版本\n 数据同步方式移除了对 zookeeper 的强依赖，新增 http 长轮询 以及 websocket 限流插件与监控插件实现真正的动态配置，由之前的 yml 配置，改为 shenyu-admin 后台用户动态配置  配置同步为什么不使用配置中心呢？\n首先，引入配置中心，会增加很多额外的成本，不光是运维，而且会让 ShenYu 变得很重；另外，使用配置中心，数据格式不可控，不便于 shenyu-admin 进行配置管理。\n动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？\nShenYu 作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。\n原理分析 先来张高清无码图，下图展示了 ShenYu 数据同步的流程，ShenYu 网关在启动时，会从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 ShenYu 网关，具体是 push 模式，还是 pull 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。 在 1.x 版本中，配置服务依赖 zookeeper 实现，管理后台将变更信息 push 给网关。而 2.x 版本支持 webosocket、http、zookeeper，通过 shenyu.sync.strategy 指定对应的同步策略，默认使用 webosocket 同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，shenyu-web 和 shenyu-admin 必须使用相同的同步机制。\n如下图所示，shenyu-admin 在用户发生配置变更之后，会通过 EventPublisher 发出配置变更通知，由 EventDispatcher 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器\n 如果是 websocket 同步策略，则将变更后的数据主动推送给 shenyu-web，并且在网关层，会有对应的 WebsocketCacheHandler 处理器来处理 shenyu-admin 的数据推送 如果是 zookeeper 同步策略，将变更数据更新到 zookeeper，而 ZookeeperSyncCache 会监听到 zookeeper 的数据变更，并予以处理 如果是 http 同步策略，shenyu-web 主动发起长轮询请求，默认有 90s 超时时间，如果 shenyu-admin 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求   Zookeeper 同步 基于 zookeeper 的同步原理很简单，主要是依赖 zookeeper 的 watch 机制，shenyu-web 会监听配置的节点，shenyu-admin 在启动的时候，会将数据全量写入 zookeeper，后续数据发生变更时，会增量更新 zookeeper 的节点，与此同时，shenyu-web 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。\nShenYu 将配置信息写到zookeeper节点，是通过精细设计的。\nWebsocket 同步 websocket 和 zookeeper 机制有点类似，将网关与 shenyu-admin 建立好 websocket 连接时，shenyu-admin 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 websocket 主动推送给 shenyu-web\n使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。ShenYu使用java-websocket 这个第三方库来进行websocket连接。\npublic class WebsocketSyncCache extends WebsocketCacheHandler { /** * The Client. */ private WebSocketClient client; public WebsocketSyncCache(final ShenyuConfig.WebsocketConfig websocketConfig) { ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, ShenyuThreadFactory.create(\u0026amp;quot;websocket-connect\u0026amp;quot;, true)); client = new WebSocketClient(new URI(websocketConfig.getUrl())) { @Override public void onOpen(final ServerHandshake serverHandshake) { //.... } @Override public void onMessage(final String result) { //.... } }; //进行连接 client.connectBlocking(); //使用调度线程池进行断线重连，30秒进行一次 executor.scheduleAtFixedRate(() -\u0026amp;gt; { if (client != null \u0026amp;amp;\u0026amp;amp; client.isClosed()) { client.reconnectBlocking(); } }, 10, 30, TimeUnit.SECONDS); }  Http长轮询 zookeeper、websocket 数据同步的机制比较简单，而 http ShenYu 借鉴了 Apollo、Nacos 的设计思想，取其精华，自己实现了 http 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！\nhttp 长轮询机制如上所 …","date":-62135596800,"description":"数据同步设计","dir":"projects/shenyu/data-sync/","fuzzywordcount":2900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"706ab1da932ad5bf847429db045dda88f9339322","permalink":"/zh/projects/shenyu/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu/data-sync/","summary":"说明 本篇主要讲解数据库同步的三种方式，以及原理。 前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在","tags":null,"title":"数据同步设计","type":"projects","url":"/zh/projects/shenyu/data-sync/","wordcount":2815},{"author":null,"categories":null,"content":" 插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。 数据库表UML类图:   设计详解:\n 一个插件对应多个选择器，一个选择器对应多个规则。\n 一个选择器对应多个匹配条件，一个规则对应多个匹配条件。\n 每个规则在对应插件下，不同的处理表现为handle字段，handle字段就是一个json字符串。具体的可以在admin使用过程中进行查看。\n 资源权限设计用来存储用户名称、角色、资源数据以及对应关系\n  数据库UML类图：\n   设计详情:  一个用户对应多个角色,一个角色对应多个资源。   ","date":-62135596800,"description":"数据库设计","dir":"projects/shenyu-2.3.0/database-design/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"a9940e641b9db01e5b1ec4a9d7a3466473f6ede9","permalink":"/zh/projects/shenyu-2.3.0/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/database-design/","summary":"插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。 数据库表UML类图: 设计详解: 一个插件对应多个选择器，一个选择器对应多个","tags":null,"title":"数据库设计","type":"projects","url":"/zh/projects/shenyu-2.3.0/database-design/","wordcount":233},{"author":null,"categories":null,"content":" 插件设计  插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。 数据库表 UML 类图:   设计详解:\n 一个插件对应多个选择器，一个选择器对应多个规则。\n 一个选择器对应多个匹配条件，一个规则对应多个匹配条件。\n 每个规则在对应插件下，不同的处理表现为 handle 字段，handle 字段就是一个 json 字符串。具体的可以在 shenyu-admin 使用过程中进行查看。\n   资源权限设计  资源代表的是 shenyu-admin 用户后台中的菜单或者按钮。\n 资源权限数据表用来存储用户名称、角色、资源数据以及对应关系。\n 数据库UML类图：\n   设计详解:  一个用户对应多个角色,一个角色对应多个资源。   数据权限设计  数据权限数据表用来存储用户，选择器、规则对应的关系。 数据库 UML 类图   设计详解  数据权限的表为： data_permission; 其中一个用户对应多条数据权限。 数据权限表中字段 data_type 区分不同的类型数据， 具体对应关系如下：0 -\u0026amp;gt; 选择器, 1 -\u0026amp;gt; 规则。 数据权限表中字段 data_id 存放相应类型的主键id。    ","date":-62135596800,"description":"数据库设计","dir":"projects/shenyu/database-design/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"8c98f9f3183ccf8fe9f3e3faa717d22c1101d831","permalink":"/zh/projects/shenyu/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/database-design/","summary":"插件设计 插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。 数据库表 UML 类图: 设计详解: 一个插件对应多个选择器，一个选择器对应","tags":null,"title":"数据库设计","type":"projects","url":"/zh/projects/shenyu/database-design/","wordcount":377},{"author":null,"categories":null,"content":" 说明  本文主要介绍soul的文件上传下载的支持。  文件上传  默认限制文件大小为10M。 如果想修改，在启动服务的时候，使用--file.size = 30，为int 类型。 你之前怎么上传文件，还是怎么上传。  文件下载  soul支持流的方式进行下载，你之前的接口怎么写的，还是怎么写，根本不需要变。  ","date":-62135596800,"description":"文件上传下载","dir":"projects/shenyu-2.3.0/file-and-image/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3000e095775e812e772b518488259c1450fd423b","permalink":"/zh/projects/shenyu-2.3.0/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/file-and-image/","summary":"说明 本文主要介绍soul的文件上传下载的支持。 文件上传 默认限制文件大小为10M。 如果想修改，在启动服务的时候，使用--file.size = 3","tags":null,"title":"文件上传下载","type":"projects","url":"/zh/projects/shenyu-2.3.0/file-and-image/","wordcount":139},{"author":null,"categories":null,"content":" 说明  本文主要介绍 ShenYu 的文件上传下载的支持。  文件上传  默认限制文件大小为10M。 如果想修改，在启动服务的时候，使用--file.size = 30，为int 类型。 你之前怎么上传文件，还是怎么上传。  文件下载  ShenYu 支持流的方式进行下载，你之前的接口怎么写的，还是怎么写，根本不需要变。  ","date":-62135596800,"description":"文件上传下载","dir":"projects/shenyu/file-and-image/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"963cdb329b9706ef3de4b3acdf222e4eab440fa8","permalink":"/zh/projects/shenyu/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/file-and-image/","summary":"说明 本文主要介绍 ShenYu 的文件上传下载的支持。 文件上传 默认限制文件大小为10M。 如果想修改，在启动服务的时候，使用--file.size = 30，为","tags":null,"title":"文件上传下载","type":"projects","url":"/zh/projects/shenyu/file-and-image/","wordcount":133},{"author":null,"categories":null,"content":" PDF  English 中文  ","date":-62135596800,"description":"Doc Download","dir":"projects/shenyu-2.3.0/download/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"87fcba45e240af6682b07f4e25376bf5c7d04b99","permalink":"/zh/projects/shenyu-2.3.0/download/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/download/","summary":"PDF English 中文","tags":null,"title":"文档下载","type":"projects","url":"/zh/projects/shenyu-2.3.0/download/","wordcount":4},{"author":null,"categories":null,"content":"  ## 最新版本  Apache ShenYu 的发布版包括源码包及其对应的二进制包。\nApache Shenyu - 版本: 2.3.0 ( 发布日期: Apr 2, 2020 )\n 源码 zip tar ShenYu-admin 二进制包 tar ShenYu-bootstrap 二进制包 tar  Apache Shenyu Dashboard - 版本: 2.3.0 ( 发布日期: Apr 2, 2020 )\n 源码 zip tar ShenYu-dashboard 二进制包 tar\n PDF  Apache ShenYu 提供了博客打包下载的 PDF，供使用者、开发者查阅。\n 中文\n English\n  ","date":-62135596800,"description":"Doc Download","dir":"projects/shenyu/download/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"0b37f7321d3c9d2ce1c796fd7712e29432723ec2","permalink":"/zh/projects/shenyu/download/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/download/","summary":"## 最新版本 Apache ShenYu 的发布版包括源码包及其对应的二进制包。 Apache Shenyu - 版本: 2.3.0 ( 发布日期: Apr 2, 2020 ) 源码 zip tar ShenYu-admin 二进制包 tar ShenYu-bootstrap 二进制包 tar Apache Shenyu Dashboard - 版本: 2.3.0 ( 发布","tags":null,"title":"文档下载","type":"projects","url":"/zh/projects/shenyu/download/","wordcount":118},{"author":null,"categories":null,"content":" 说明  本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来进行匹配。  默认实现  在soul网关自带实现为：org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n 它需要你在 nginx 设置 X-Forwarded-For，以便来获取正确的 ip 与 host。\n  扩展实现  新增一个类A，实现org.dromara.soul.plugin.api.RemoteAddressResolver  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   把你新增的实现类注册成为spring的bean，如下  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"正确获取Ip与host","dir":"projects/shenyu-2.3.0/custom-parsing-ip-and-host/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"dd100ed146ec28877f447432442e286a8e0a2398","permalink":"/zh/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","summary":"说明 本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来","tags":null,"title":"正确获取Ip与host","type":"projects","url":"/zh/projects/shenyu-2.3.0/custom-parsing-ip-and-host/","wordcount":321},{"author":null,"categories":null,"content":" 说明  本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来进行匹配。  默认实现  在 ShenYu 网关自带实现为：org.apache.shenyu.web.forward.ForwardedRemoteAddressResolver。\n 它需要你在 nginx 设置 X-Forwarded-For，以便来获取正确的 ip 与 host。\n  扩展实现  新增一个类A，实现org.apache.shenyu.plugin.api.RemoteAddressResolver  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   把你新增的实现类注册成为spring的bean，如下  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"正确获取Ip与host","dir":"projects/shenyu/custom-parsing-ip-and-host/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"ac98ef50ae15758183b8086a9ae284cf2097ac4c","permalink":"/zh/projects/shenyu/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/custom-parsing-ip-and-host/","summary":"说明 本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来","tags":null,"title":"正确获取Ip与host","type":"projects","url":"/zh/projects/shenyu/custom-parsing-ip-and-host/","wordcount":319},{"author":null,"categories":null,"content":" 说明 说明然后使用不同的注册方式，快速接入。\nHTTP方式注册 Soul-Admin配置 在 application.yml 配置注册中心为HTTP即可，如下：\nsoul: register: registerType: http props: checked: true #是否开启检测 zombieCheckTimes: 5 #失败几次后剔除服务 scheduledTime: 10 #定时检测间隔时间 （秒）  Soul-Client配置 在 application.yml 中配置注册方式为HTTP，并填写Soul-Admin服务地址列表，如下：\nsoul: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 http # serverList: 为http注册类型时，填写Soul-Admin项目的地址，注意加上http://，多个地址用英文逗号分隔 # port: 你本项目的启动端口，目前springmvc/tars/grpc需要进行填写 # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # isFull: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller；目前适用于springmvc/springcloud  Zookeeper方式注册 Soul-Admin配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-server-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 配置注册中心为Zookeeper，填写相关zookeeper服务地址和参数，如下：  soul: register: registerType: zookeeper serverLists : localhost:2181 props: sessionTimeout: 5000 connectionTimeout: 2000  Soul-Client配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-client-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 中配置注册方式为Zookeeper，并填写Zookeeper服务地址和相关参数，如下：  soul: client: registerType: zookeeper serverLists: localhost:2181 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 zookeeper # serverList: 为zookeeper注册类型时，填写zookeeper地址，多个地址用英文分隔 # port: 你本项目的启动端口,目前springmvc/tars/grpc需要进行填写 # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # isFull: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller；目前适用于springmvc/springcloud  Etcd方式注册 Soul-Admin配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-server-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 配置注册中心为etcd, 填写相关etcd服务地址和参数，如下：  soul: register: registerType: etcd serverLists : http://localhost:2379 props: etcdTimeout: 5000 etcdTTL: 5  Soul-Client配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-register-client-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 中配置注册方式为etcd, 并填写etcd服务地址和相关参数，如下：  soul: client: registerType: etcd serverLists: http://localhost:2379 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 etcd # serverList: 为etcd注册类型时，填写etcd地址，多个地址用英文分隔 # port: 你本项目的启动端口,目前springmvc/tars/grpc …","date":-62135596800,"description":"注册中心接入配置","dir":"projects/shenyu-2.3.0/register-center-access/","fuzzywordcount":3000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"77eb445e9e146b4fe5daf8d57a001e5c4cb50745","permalink":"/zh/projects/shenyu-2.3.0/register-center-access/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu-2.3.0/register-center-access/","summary":"说明 说明然后使用不同的注册方式，快速接入。 HTTP方式注册 Soul-Admin配置 在 application.yml 配置注册中心为HTTP即可，如下： soul: register: registerType: http props: checked: true #是否","tags":null,"title":"注册中心接入配置","type":"projects","url":"/zh/projects/shenyu-2.3.0/register-center-access/","wordcount":2926},{"author":null,"categories":null,"content":" 说明 说明然后使用不同的注册方式，快速接入。\nHTTP方式注册 Shenyu-Admin配置 在 application.yml 配置注册中心为HTTP即可，如下：\nshenyu: register: registerType: http props: checked: true #是否开启检测 zombieCheckTimes: 5 #失败几次后剔除服务 scheduledTime: 10 #定时检测间隔时间 （秒）  Shenyu-Client配置 在 application.yml 中配置注册方式为HTTP，并填写Shenyu-Admin服务地址列表，如下：\nshenyu: client: registerType: http serverLists: http://localhost:9095 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 http # serverList: 为http注册类型时，填写Shenyu-Admin项目的地址，注意加上http://，多个地址用英文逗号分隔 # port: 你本项目的启动端口，目前springmvc/tars/grpc需要进行填写 # contextPath: 为你的这个mvc项目在shenyu网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # isFull: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller；目前适用于springmvc/springcloud  Zookeeper方式注册 Shenyu-Admin配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-server-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 配置注册中心为Zookeeper，填写相关zookeeper服务地址和参数，如下：  shenyu: register: registerType: zookeeper serverLists : localhost:2181 props: sessionTimeout: 5000 connectionTimeout: 2000  Shenyu-Client配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-client-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 中配置注册方式为Zookeeper，并填写Zookeeper服务地址和相关参数，如下：  shenyu: client: registerType: zookeeper serverLists: localhost:2181 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 zookeeper # serverList: 为zookeeper注册类型时，填写zookeeper地址，多个地址用英文分隔 # port: 你本项目的启动端口,目前springmvc/tars/grpc需要进行填写 # contextPath: 为你的这个mvc项目在shenyu网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # isFull: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller；目前适用于springmvc/springcloud  Etcd方式注册 Shenyu-Admin配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-server-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 配置注册中心为etcd, 填写相关etcd服务地址和参数，如下：  shenyu: register: registerType: etcd serverLists : http://localhost:2379 props: etcdTimeout: 5000 etcdTTL: 5  Shenyu-Client配置  首先在 pom.xml 文件中加入相关的依赖（默认已经引入）：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-register-client-etcd\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 application.yml 中配置注册方式为etcd, 并填写etcd服务地址和相关参数，如下：  shenyu: client: registerType: etcd serverLists: http://localhost:2379 props: contextPath: /http appName: http port: 8188 isFull: false # registerType : 服务注册类型，填写 etcd # serverList: 为etcd …","date":-62135596800,"description":"注册中心接入配置","dir":"projects/shenyu/register-center-access/","fuzzywordcount":3000,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7f6ccc693d146d3babeae80ba97ccd4159eaf9c5","permalink":"/zh/projects/shenyu/register-center-access/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu/register-center-access/","summary":"说明 说明然后使用不同的注册方式，快速接入。 HTTP方式注册 Shenyu-Admin配置 在 application.yml 配置注册中心为HTTP即可，如下： shenyu: register: registerType: http props: checked: true #","tags":null,"title":"注册中心接入配置","type":"projects","url":"/zh/projects/shenyu/register-center-access/","wordcount":2966},{"author":null,"categories":null,"content":" 说明  本篇主要讲解注册中心原理  Client 配置中声明使用的注册中心客户端类型，如HTTP/Zookeeper\n应用程序启动时使用SPI方式加载并初始化对应注册中心客户端\n通过实现Spring Bean相关的后处理器接口，在其中获取需要进行注册的服务接口信息，将获取的信息放入Disruptor中\n注册中心客户端从Disruptor中读取数据，并将接口信息注册到Soul-Admin\nDisruptor在其中起数据与操作解耦的作用，利于扩展\nServer 在Soul-Admin配置中声明使用的注册中心服务端类型，如HTTP/Zookeeper\nSoul-Admin启动时，更加配置的类型，加载并初始化对应的注册中心服务端\n注册中心服务端收到Soul-Client注册的接口信息后，将其放入Disruptor中，然后会触发注册处理逻辑，将服务接口信息更新并发布同步事件\nDisruptor在其中起到数据与操作解耦，利于扩展；同时比较注册请求过多，导致注册异常，有数据缓冲作用\nHttp 注册 HTTP服务注册原理较为简单，在Soul-Client启动后，会调用Soul-Admin的相关服务注册接口，上传数据进行注册\nSoul-Admin web服务接口收到请求后进行数据更新和数据同步事件发布\nZookeeper 注册 Zookeeper存储结构如下：\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Soul-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）写到如上的zookeeper节点中。\nSoul-Admin使用Zookeeper的Watch机制，对数据的更新和删除等事件进行监听，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nEtcd 注册 Etcd的键值存储结构如下：\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Soul-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）以Ephemeral方式写到如上的Etcd节点中。\nSoul-Admin使用Etcd的Watch机制，对数据的更新和删除等事件进行监听，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nConsul 注册 Consul的Metadata和URI分两部分存储，URIRegisterDTO随着服务注册记录在服务的metadata里，服务下线时随着服务节点一起消失。\nConsul的MetaDataRegisterDTO存在Key/Value里，键值存储结构如下：\nsoul ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO  Soul-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）分别放在ServiceInstance的Metadata（URIRegisterDTO）和KeyValue（MetaDataRegisterDTO），按照上述方式进行存储。\nSoul-Admin通过监听Catalog和KeyValue的index的变化，来感知数据的更新和删除，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nNacos 注册 Nacos分为两部分：URI 和 Metadata。\nURI 使用实例注册方式，在服务异常的情况下，相关URI数据节点会自动进行删除，并发送事件到订阅端，订阅端进行相关的下线处理。\nMetadata 使用配置注册方式，没有相关上下线操作，当有URI实例注册时，会相应的发布Metadata配置，订阅端监听数据变化，进行更新处理。\nURI 实例注册命令规则如下：\nsoul.register.service.${rpcType}  初始监听所有的RpcType节点，其下的{contextPath}实例会对应注册到其下，根据IP和Port进行区分，并携带其对应的contextPath信息。\nURI 实例上下线之后，触发selector的upstream的更新和数据同步事件发布。\nURI 实例上线时，会发布对应的 Metadata 数据，其节点名称命令规则如下：\nsoul.register.service.${rpcType}.${contextPath}  订阅端会对所有的Metadata配置继续监听，当初次订阅和配置更新后，触发selector和rule的数据变更和数据同步事件发布。\nSPI 扩展    SPI 名称 详细说明     SoulClientRegisterRepository Soul网关客户端接入注册服务资源       已知实现类 详细说明     HttpClientRegisterRepository 基于Http请求的实现   ZookeeperClientRegisterRepository 基于Zookeeper注册的实现   EtcdClientRegisterRepository 基于etcd …","date":-62135596800,"description":"注册中心设计","dir":"projects/shenyu-2.3.0/register-center-design/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"d21ea33de1b0818fd32fd53228036d0cd75bc9c0","permalink":"/zh/projects/shenyu-2.3.0/register-center-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu-2.3.0/register-center-design/","summary":"说明 本篇主要讲解注册中心原理 Client 配置中声明使用的注册中心客户端类型，如HTTP/Zookeeper 应用程序启动时使用SPI方式加载并初始化对应","tags":null,"title":"注册中心设计","type":"projects","url":"/zh/projects/shenyu-2.3.0/register-center-design/","wordcount":2537},{"author":null,"categories":null,"content":" 说明  本篇主要讲解注册中心原理  Client 配置中声明使用的注册中心客户端类型，如HTTP/Zookeeper\n应用程序启动时使用SPI方式加载并初始化对应注册中心客户端\n通过实现Spring Bean相关的后处理器接口，在其中获取需要进行注册的服务接口信息，将获取的信息放入Disruptor中\n注册中心客户端从Disruptor中读取数据，并将接口信息注册到Shenyu-Admin\nDisruptor在其中起数据与操作解耦的作用，利于扩展\nServer 在Shenyu-Admin配置中声明使用的注册中心服务端类型，如HTTP/Zookeeper\nShenyu-Admin启动时，更加配置的类型，加载并初始化对应的注册中心服务端\n注册中心服务端收到Shenyu-Client注册的接口信息后，将其放入Disruptor中，然后会触发注册处理逻辑，将服务接口信息更新并发布同步事件\nDisruptor在其中起到数据与操作解耦，利于扩展；同时比较注册请求过多，导致注册异常，有数据缓冲作用\nHttp 注册 HTTP服务注册原理较为简单，在Shenyu-Client启动后，会调用Shenyu-Admin的相关服务注册接口，上传数据进行注册\nShenyu-Admin web服务接口收到请求后进行数据更新和数据同步事件发布\nZookeeper 注册 Zookeeper存储结构如下：\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Shenyu-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）写到如上的zookeeper节点中。\nShenyu-Admin使用Zookeeper的Watch机制，对数据的更新和删除等事件进行监听，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nEtcd 注册 Etcd的键值存储结构如下：\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO ├ ├──uri ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ip:prot} : save uri data of URIRegisterDTO ├ ├ ├ ├──${ip:prot}  Shenyu-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）以Ephemeral方式写到如上的Etcd节点中。\nShenyu-Admin使用Etcd的Watch机制，对数据的更新和删除等事件进行监听，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nConsul 注册 Consul的Metadata和URI分两部分存储，URIRegisterDTO随着服务注册记录在服务的metadata里，服务下线时随着服务节点一起消失。\nConsul的MetaDataRegisterDTO存在Key/Value里，键值存储结构如下：\nshenyu ├──regsiter ├ ├──metadata ├ ├ ├──${rpcType} ├ ├ ├ ├────${contextPath} ├ ├ ├ ├──${ruleName} : save metadata data of MetaDataRegisterDTO  Shenyu-Client启动时，将服务接口信息（MetaDataRegisterDTO/URIRegisterDTO）分别放在ServiceInstance的Metadata（URIRegisterDTO）和KeyValue（MetaDataRegisterDTO），按照上述方式进行存储。\nShenyu-Admin通过监听Catalog和KeyValue的index的变化，来感知数据的更新和删除，数据变更后触发对应的注册处理逻辑。\n在收到MetaDataRegisterDTO节点变更后，触发selector和rule的数据变更和数据同步事件发布。\n收到URIRegisterDTO节点变更后，触发selector的upstream的更新和数据同步事件发布。\nNacos 注册 Nacos分为两部分：URI 和 Metadata。\nURI 使用实例注册方式，在服务异常的情况下，相关URI数据节点会自动进行删除，并发送事件到订阅端，订阅端进行相关的下线处理。\nMetadata 使用配置注册方式，没有相关上下线操作，当有URI实例注册时，会相应的发布Metadata配置，订阅端监听数据变化，进行更新处理。\nURI 实例注册命令规则如下：\nshenyu.register.service.${rpcType}  初始监听所有的RpcType节点，其下的{contextPath}实例会对应注册到其下，根据IP和Port进行区分，并携带其对应的contextPath信息。\nURI 实例上下线之后，触发selector的upstream的更新和数据同步事件发布。\nURI 实例上线时，会发布对应的 Metadata 数据，其节点名称命令规则如下：\nshenyu.register.service.${rpcType}.${contextPath}  订阅端会对所有的Metadata配置继续监听，当初次订阅和配置更新后，触发selector和rule的数据变更和数据同步事件发布。\nSPI 扩展    SPI 名称 详细说明     ShenyuClientRegisterRepository ShenYu网关客户端接入注册服务资源       已知实现类 详细说明     HttpClientRegisterRepository 基于Http请求的实现   ZookeeperClientRegisterRepository 基于Zookeeper …","date":-62135596800,"description":"注册中心设计","dir":"projects/shenyu/register-center-design/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"7d5fcc5a5326313a68543ebbd5aa0244d430e578","permalink":"/zh/projects/shenyu/register-center-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/projects/shenyu/register-center-design/","summary":"说明 本篇主要讲解注册中心原理 Client 配置中声明使用的注册中心客户端类型，如HTTP/Zookeeper 应用程序启动时使用SPI方式加载并初始化对应","tags":null,"title":"注册中心设计","type":"projects","url":"/zh/projects/shenyu/register-center-design/","wordcount":2565},{"author":null,"categories":null,"content":" 说明  soul 2.2.0以后都是基于插件化可插拔的思想，本文是说明如何基于soul搭建属于你自己网关。 请确保你的机器安装了JDK 1.8+，Mysql 5.5.20 + 。  启动 Soul-Admin 远程下载  2.3.0 下载 soul-admin-bin-2.3.0-RELEASE.tar.gz\n 解压缩 soul-admin-bin-2.3.0-RELEASE.tar.gz。 进入 bin 目录。\n 使用 h2 来存储后台数据\n\u0026amp;gt; windows : start.bat --spring.profiles.active = h2 \u0026amp;gt; linux : ./start.sh --spring.profiles.active = h2  使用 mysql 来存储后台数据。 进入 /conf 目录，修改 application.yaml 中mysql 的配置。\n\u0026amp;gt; windows : start.bat \u0026amp;gt; linux : ./start.sh   docker构建 \u0026amp;gt; docker pull dromara/soul-admin \u0026amp;gt; docker network create soul   使用 h2 来存储后台数据\n\u0026amp;gt; docker run -d -p 9095:9095 --net soul dromara/soul-admin  使用 mysql 来存储后台数据。\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -d -p 9095:9095 --net soul dromara/soul-admin   如果你想覆盖环境变量，你可以这样操作。\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -e \u0026amp;quot;spring.datasource.url=jdbc:mysql://192.168.1.9:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; -e \u0026amp;quot;spring.datasource.password=123456\u0026amp;quot; -d -p 9095:9095 --net soul dromara/soul-admin  另外一种方式，可以挂载你本地磁盘其他目录\n把你的application.yml配置放到xxx目录， 然后执行以下语句。\ndocker run -v D:\\tmp\\conf:/opt/soul-admin/conf/ -d -p 9095:9095 --net soul dromara/soul-admin  本地构建  下载代码\n\u0026amp;gt; git clone https://github.com/dromara/soul.git \u0026amp;gt; cd soul  编译代码\n\u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  启动 SoulAdminBootstrap。\n 如果使用h2来存储，设置变量 --spring.profiles.active = h2\n 如果使用mysql来存储，修改 application.yaml 中的 mysql 配置。\n   访问 http://localhost:9095 用户名密码为: admin/123456\n启动 Soul-Bootstrap 远程下载  2.3.0 下载 soul-bootstrap-bin-2.3.0-RELEASE.tar.gz\n 解压缩 soul-bootstrap-bin-2.3.0-RELEASE.tar.gz。 进入 bin 目录。\n\u0026amp;gt; windows : start.bat \u0026amp;gt; linux : ./start.sh   docker构建 \u0026amp;gt; docker network create soul \u0026amp;gt; docker pull dromara/soul-bootstrap \u0026amp;gt; docker run -d -p 9195:9195 --net soul dromara/soul-bootstrap  本地构建  下载代码\n\u0026amp;gt; git clone https://github.com/dromara/soul.git \u0026amp;gt; cd soul  编译代码\n\u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  启动 SoulBootstrap。\n  搭建自己的网关（推荐）  首先你新建一个空的springboot项目，可以参考 soul-bootstrap. 也可以在spring官网:[https://spring.io/quickstart]\n 引入如下jar包：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"环境搭建","dir":"projects/shenyu-2.3.0/soul-set-up/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"627972ef346941fcb68dd5a49e818ac57f04067d","permalink":"/zh/projects/shenyu-2.3.0/soul-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu-2.3.0/soul-set-up/","summary":"说明 soul 2.2.0以后都是基于插件化可插拔的思想，本文是说明如何基于soul搭建属于你自己网关。 请确保你的机器安装了JDK 1.8+，Mysql","tags":null,"title":"环境搭建","type":"projects","url":"/zh/projects/shenyu-2.3.0/soul-set-up/","wordcount":773},{"author":null,"categories":null,"content":" 说明  shenyu 2.2.0 以后都是基于插件化可插拔的思想，本文是说明如何基于 shenyu 搭建属于你自己网关。 请确保你的机器安装了 JDK 1.8+，Mysql 5.5.20 +。  启动 Shenyu-Admin 远程下载  2.3.0 下载 shenyu-admin-bin-2.3.0-RELEASE.tar.gz\n 解压缩 shenyu-admin-bin-2.3.0-RELEASE.tar.gz。 进入 bin 目录。\n 使用 h2 来存储后台数据\n\u0026amp;gt; windows: start.bat --spring.profiles.active = h2 \u0026amp;gt; linux: ./start.sh --spring.profiles.active = h2  使用 mysql 来存储后台数据。 进入 /conf 目录，修改 application.yaml 中 mysql 的配置。\n\u0026amp;gt; windows: start.bat \u0026amp;gt; linux: ./start.sh   docker构建 \u0026amp;gt; docker pull dromara/shenyu-admin \u0026amp;gt; docker network create shenyu   使用 h2 来存储后台数据\n\u0026amp;gt; docker run -d -p 9095:9095 --net shenyu dromara/shenyu-admin  使用 mysql 来存储后台数据。\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -d -p 9095:9095 --net shenyu dromara/shenyu-admin   如果你想覆盖环境变量，你可以这样操作。\ndocker run -e \u0026amp;quot;SPRING_PROFILES_ACTIVE=mysql\u0026amp;quot; -e \u0026amp;quot;spring.datasource.url=jdbc:mysql://192.168.1.9:3306/shenyu?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;quot; -e \u0026amp;quot;spring.datasource.password=123456\u0026amp;quot; -d -p 9095:9095 --net shenyu dromara/shenyu-admin  另外一种方式，可以挂载你本地磁盘其他目录\n把你的 application.yml 配置放到xxx目录， 然后执行以下语句。\ndocker run -v D:\\tmp\\conf:/opt/shenyu-admin/conf/ -d -p 9095:9095 --net shenyu dromara/shenyu-admin  本地构建  下载代码\n\u0026amp;gt; git clone https://github.com/apache/incubator-shenyu.git \u0026amp;gt; cd shenyu  编译代码\n\u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  启动 ShenyuAdminBootstrap。\n 如果使用h2来存储，设置变量 --spring.profiles.active = h2\n 如果使用mysql来存储，修改 application.yaml 中的 mysql 配置。\n   访问 http://localhost:9095 用户名密码为: admin/123456\n启动 Shenyu-Bootstrap 远程下载  2.3.0 下载 shenyu-bootstrap-bin-2.3.0-RELEASE.tar.gz\n 解压缩 shenyu-bootstrap-bin-2.3.0-RELEASE.tar.gz。 进入 bin 目录。\n\u0026amp;gt; windwos : start.bat \u0026amp;gt; linux : ./start.sh   docker构建 \u0026amp;gt; docker network create shenyu \u0026amp;gt; docker pull dromara/shenyu-bootstrap \u0026amp;gt; docker run -d -p 9195:9195 --net shenyu dromara/shenyu-bootstrap  本地构建  下载代码\n\u0026amp;gt; git clone https://github.com/apache/incubator-shenyu.git \u0026amp;gt; cd shenyu  编译代码\n\u0026amp;gt; mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests  启动 ShenyuBootstrap。\n  搭建自己的网关（推荐）  首先你新建一个空的 springboot 项目，可以参考 shenyu-bootstrap. 也可以在 spring 官网:[https://spring.io/quickstart]\n 引入如下jar包：\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--shenyu data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; …","date":-62135596800,"description":"环境搭建","dir":"projects/shenyu/shenyu-set-up/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3b4aecdaba99adf1b94c3986931a608b5fc35970","permalink":"/zh/projects/shenyu/shenyu-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/projects/shenyu/shenyu-set-up/","summary":"说明 shenyu 2.2.0 以后都是基于插件化可插拔的思想，本文是说明如何基于 shenyu 搭建属于你自己网关。 请确保你的机器安装了 JDK 1.8+，Mysql 5.5.20 +。 启动 Shenyu-Admin 远程下","tags":null,"title":"环境搭建","type":"projects","url":"/zh/projects/shenyu/shenyu-set-up/","wordcount":726},{"author":null,"categories":null,"content":" 说明  本文主要介绍soul的线程模型，以及各种场景的使用。  io与work线程  soul内置依赖 spring-webflux 而其底层是使用的netty，这一块主要是使用的netty线程模型。  业务线程  默认使用调度线程来执行。 默认使用固定的线程池来执行，其线程数为 cpu * 2 + 1。  切换类型  reactor.core.scheduler.Schedulers。 可以使用 -Dsoul.scheduler.type=fixed 这个是默认。 设置其他的值 就会使用弹性线程池来执行Schedulers.elastic()。 可以使用 -Dsoul.work.threads = xx 来指定线程数量，默认为 cpu * 2 + 1，最小为16个线程。  ","date":-62135596800,"description":"线程模型","dir":"projects/shenyu-2.3.0/thread/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"55a19e382e8e31d1b17f0fec8f9daee3d25a62a3","permalink":"/zh/projects/shenyu-2.3.0/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/thread/","summary":"说明 本文主要介绍soul的线程模型，以及各种场景的使用。 io与work线程 soul内置依赖 spring-webflux 而其底层是使用的netty，这一块主要是使用的n","tags":null,"title":"线程模型","type":"projects","url":"/zh/projects/shenyu-2.3.0/thread/","wordcount":241},{"author":null,"categories":null,"content":" 说明  本文主要介绍 ShenYu 的线程模型，以及各种场景的使用。  io与work线程  ShenYu 内置依赖 spring-webflux 而其底层是使用的 netty，这一块主要是使用的 netty 线程模型。  业务线程  默认使用调度线程来执行。 默认使用固定的线程池来执行，其线程数为 cpu * 2 + 1。  切换类型  reactor.core.scheduler.Schedulers。 可以使用 -Dshenyu.scheduler.type=fixed 这个是默认。 设置其他的值 就会使用弹性线程池来执行Schedulers.elastic()。 可以使用 -Dshenyu.work.threads = xx 来指定线程数量，默认为 cpu * 2 + 1，最小为16个线程。  ","date":-62135596800,"description":"线程模型","dir":"projects/shenyu/thread/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"3d622bfe502357c74b875b725d88f92ea67c4d1d","permalink":"/zh/projects/shenyu/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/thread/","summary":"说明 本文主要介绍 ShenYu 的线程模型，以及各种场景的使用。 io与work线程 ShenYu 内置依赖 spring-webflux 而其底层是使用的 netty，这一块主要是使用的 netty 线程模型。 业","tags":null,"title":"线程模型","type":"projects","url":"/zh/projects/shenyu/thread/","wordcount":231},{"author":null,"categories":null,"content":" 说明  本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。  跨域支持  新增 org.dromara.soul.bootstrap.cors.CrossFilter 实现 WebFilter。  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   将 CrossFilter 注册成为 spring的bean，完事。  网关过滤 springboot健康检查  注意顺序，使用 @Order 注解  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  继承 org.dromara.soul.web.filter.AbstractWebFilter  新增一个类，继承它。\n 实现它的2个方法。\n  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute doDenyResponse(ServerWebExchange exchange) */ protected abstract Mono\u0026amp;lt;Boolean\u0026amp;gt; doFilter(ServerWebExchange exchange, WebFilterChain chain); /** * this is Template Method ,children Implement your own And response client. * * @param exchange the current server exchange. * @return {@code …","date":-62135596800,"description":"filter扩展","dir":"projects/shenyu-2.3.0/custom-filter/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bf82f2a7e2d358fecd20610033a4a3e551d216f5","permalink":"/zh/projects/shenyu-2.3.0/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/custom-filter/","summary":"说明 本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。 跨域支持 新增 org.dromara.soul.bootstrap.cors.CrossFilter 实现 WebFilter。 public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final","tags":null,"title":"自定义Filter","type":"projects","url":"/zh/projects/shenyu-2.3.0/custom-filter/","wordcount":437},{"author":null,"categories":null,"content":" 说明  本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。  跨域支持  新增 org.apache.shenyu.web.filter.CrossFilter 实现 WebFilter。  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   将 CrossFilter 注册成为 spring的bean，完事。  网关过滤 springboot健康检查  注意顺序，使用 @Order 注解  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  继承 org.apache.shenyu.web.filter.AbstractWebFilter  新增一个类，继承它。\n 实现它的2个方法。\n  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute doDenyResponse(ServerWebExchange exchange) */ protected abstract Mono\u0026amp;lt;Boolean\u0026amp;gt; doFilter(ServerWebExchange exchange, WebFilterChain chain); /** * this is Template Method ,children Implement your own And response client. * * @param exchange the current server exchange. * @return {@code …","date":-62135596800,"description":"filter扩展","dir":"projects/shenyu/custom-filter/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"37c916e0974711da4a5f61ef70ddbeb5d88f9a2a","permalink":"/zh/projects/shenyu/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/custom-filter/","summary":"说明 本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。 跨域支持 新增 org.apache.shenyu.web.filter.CrossFilter 实现 WebFilter。 public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final","tags":null,"title":"自定义Filter","type":"projects","url":"/zh/projects/shenyu/custom-filter/","wordcount":437},{"author":null,"categories":null,"content":" 说明  用户可以自定义签名认证算法来实现验证。  扩展  默认的实现为 org.dromara.soul.plugin.sign.service.DefaultSignService。\n 新增一个类 A 实现 org.dromara.soul.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   Pair中返回true，表示验证通过，为false的时候，会把String中的信息输出到前端。\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"自定义sign插件检验","dir":"projects/shenyu-2.3.0/custom-sign-algorithm/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"5941ae6f5baf4fc151ac14bdc12774fd6f758ef2","permalink":"/zh/projects/shenyu-2.3.0/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/custom-sign-algorithm/","summary":"说明 用户可以自定义签名认证算法来实现验证。 扩展 默认的实现为 org.dromara.soul.plugin.sign.service.Defa","tags":null,"title":"自定义sign插件检验算法","type":"projects","url":"/zh/projects/shenyu-2.3.0/custom-sign-algorithm/","wordcount":240},{"author":null,"categories":null,"content":" 说明  用户可以自定义签名认证算法来实现验证。  扩展  默认的实现为 org.apache.shenyu.plugin.sign.service.DefaultSignService。\n 新增一个类 A 实现 org.apache.shenyu.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   Pair中返回true，表示验证通过，为false的时候，会把String中的信息输出到前端。\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"自定义sign插件检验","dir":"projects/shenyu/custom-sign-algorithm/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"c347b21f4f68195eb043ebe3962753363e620635","permalink":"/zh/projects/shenyu/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/custom-sign-algorithm/","summary":"说明 用户可以自定义签名认证算法来实现验证。 扩展 默认的实现为 org.apache.shenyu.plugin.sign.service.Def","tags":null,"title":"自定义sign插件检验算法","type":"projects","url":"/zh/projects/shenyu/custom-sign-algorithm/","wordcount":242},{"author":null,"categories":null,"content":" 说明  本文是说明基于soul网关返回自定义的数据个数。 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。  默认实现  默认的实现为 org.dromara.soul.plugin.api.result.DefaultSoulResult\n 返回的数据格式如下：\n  public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   返回的json 格式如下：\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //返回码, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //提示字段 \u0026amp;quot;data\u0026amp;quot;: null // 具体的数据 }  扩展  新增一个类 A 实现 org.dromara.soul.plugin.api.result.SoulResult  public interface SoulResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  其他 泛型 T 为你自定义的数据格式，返回它就好\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public SoulResult a() { return new A(); }  ","date":-62135596800,"description":"自定义网关返回数据格式","dir":"projects/shenyu-2.3.0/custom-result/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"87f3b0230115c7defefed466428bb57eac48963c","permalink":"/zh/projects/shenyu-2.3.0/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/custom-result/","summary":"说明 本文是说明基于soul网关返回自定义的数据个数。 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。 默认实现 默认","tags":null,"title":"自定义网关返回数据格式","type":"projects","url":"/zh/projects/shenyu-2.3.0/custom-result/","wordcount":309},{"author":null,"categories":null,"content":" 说明  本文是说明基于 ShenYu 网关返回自定义的数据个数。 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。  默认实现  默认的实现为 org.apache.shenyu.plugin.api.result.DefaultShenyuResult\n 返回的数据格式如下：\n  public class ShenyuDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   返回的json 格式如下：\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //返回码, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //提示字段 \u0026amp;quot;data\u0026amp;quot;: null // 具体的数据 }  扩展  新增一个类 A 实现 org.apache.shenyu.plugin.api.result.ShenyuResult  public interface ShenyuResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  其他 泛型 T 为你自定义的数据格式，返回它就好\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public ShenyuResult a() { return new A(); }  ","date":-62135596800,"description":"自定义网关返回数据格式","dir":"projects/shenyu/custom-result/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"102af1f38096a4f81e48d91ed1d234fa507750c6","permalink":"/zh/projects/shenyu/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/custom-result/","summary":"说明 本文是说明基于 ShenYu 网关返回自定义的数据个数。 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。 默认实现 默认的实现","tags":null,"title":"自定义网关返回数据格式","type":"projects","url":"/zh/projects/shenyu/custom-result/","wordcount":306},{"author":null,"categories":null,"content":" 说明  选择器和规则是soul网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。 本篇主要详解soul网关中，选择器与规则的概念，以及如何使用。  大体理解  一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的一级筛选，规则就是最终的筛选。 我们想象一下，在一个插件里面，我们是不是希望根据我们的配置，达到满足条件的流量，我们插件才去执行它？ 选择器和规则就是为了让流量在满足特定的条件下，才去执行我们想要的，这种规则我们首先要明白。 数据结构可以参考之前的 数据库设计  选择器  选择器详解：\n 名称：为你的选择器起一个容易分辨的名字 类型：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 匹配方式：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 条件：  uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配：  match：模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） =：前后值相等，才能匹配。 regEx：正则匹配，表示前面一个值去匹配后面的正则表达式。 like：字符串模糊匹配。\n   是否开启：打开才会生效 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。   上述图片中表示:当请求的uri前缀是 /test，并且header 头上 module 字段值为test 的时候，会转发到 1.1.1.1:8080 这个服务。\n 选择器建议：可以uri 条件， match 前缀 （/contextPath），进行第一道流量筛选。\n  规则  当流量经过选择器匹配成功之后，会进入规则来进行最终的流量匹配。\n 规则是对流量最终执行逻辑的确认。\n 规则详解：\n 名称：为你的规则起一个容易分辨的名字 匹配方式：and 或者or 是指下面多个条件是按照and 还是or。 条件：  uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配:  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。   是否开启：打开才会生效。 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个规则的时候，执行顺序小的优先执行。 处理：每个插件的规则处理不一样，具体的差有具体的处理，具体请查看每个对应插件的处理。  上图表示：当 uri 等于 /http/order/save 的时候该规则被匹配，就会执行该规则中，负载策略是 random。\n 联合选择器，我们来表述一下：当一个 请求的 uri 为 /http/order/save，会通过 random 的方式，转发到 1.1.1.1:8080。\n 规则建议：可以uri 条件， match 最真实的uri路径，进行流量的最终筛选 。\n  条件详解  uri 匹配 （推荐）\n uri匹配是根据你请求路径中的uri来进行匹配，在接入网关的时候，前端几乎不用做任何更改。\n 当使用 match 方式匹配时候，同 springmvc 模糊匹配原理相同。\n 在选择器中，推荐使用uri中的前缀来进行匹配，而在规则中，则使用具体路径来进行匹配。\n 该匹配方式的时候，在匹配字段名称可以任意填写，匹配字段值需要正确填写。\n  header 匹配\n header是根据你的http 请求头中的字段值来匹配。   query 匹配\n 这个是根据你的uri中的查询参数来进行匹配，比如 /test?a=1\u0026amp;amp;\u0026amp;amp;b=2 ，那么可以选择该匹配方式。\n 上述就可以新增一个条件，选取 query方式 , a = 1 。\n  ip匹配\n 这个是根据 http调用方的 ip来进行匹配。\n 尤其是在waf插件里面，如果发现一个ip地址有攻击，可以新增一条匹配条件，填上该ip，拒绝该ip的访问。\n 如果在soul前面使用了nginx代理，为了获取正确的ip，你可能要参考 parsing-ip-and-host\n  host匹配\n 这个是根据 http调用方的host来进行匹配。\n 尤其是在waf插件里面，如果发现一个host地址有攻击，可以新增一条匹配条件，填上该host，拒绝该host的访问。\n 如果在soul前面使用了nginx代理，为了获取正确的host，你可能要参考 parsing-ip-and-host\n  post匹配\n 不推荐使用。   ","date":-62135596800,"description":"选择器规则详解","dir":"projects/shenyu-2.3.0/selector-and-rule/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"9399c6ce33158fd464c59d5f1bcdced4e3144cb8","permalink":"/zh/projects/shenyu-2.3.0/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/zh/projects/shenyu-2.3.0/selector-and-rule/","summary":"说明 选择器和规则是soul网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。 本篇主要详解soul网关中，选择器与规则的概念，以及如何使","tags":null,"title":"选择器规则详解","type":"projects","url":"/zh/projects/shenyu-2.3.0/selector-and-rule/","wordcount":1885},{"author":null,"categories":null,"content":" 说明  选择器和规则是 ShenYu 网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。 本篇主要详解 ShenYu 网关中，选择器与规则的概念，以及如何使用。  大体理解  一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的一级筛选，规则就是最终的筛选。 我们想象一下，在一个插件里面，我们是不是希望根据我们的配置，达到满足条件的流量，我们插件才去执行它？ 选择器和规则就是为了让流量在满足特定的条件下，才去执行我们想要的，这种规则我们首先要明白。 数据结构可以参考之前的 数据库设计。  选择器  选择器详解：\n 名称：为你的选择器起一个容易分辨的名字 类型：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 匹配方式：and 或者 or 是指下面多个条件是按照 and 还是 or 的方式来组合。 条件：  uri：是指你根据 uri 的方式来筛选流量，match 的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据 uri 的查询条件来进行筛选流量。 ip：是指根据你请求的真实 ip，来筛选流量。 host：是指根据你请求的真实 host，来筛选流量。 post：建议不要使用。 条件匹配：  match：模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） =：前后值相等，才能匹配。 regEx：正则匹配，表示前面一个值去匹配后面的正则表达式。 like：字符串模糊匹配。   是否开启：打开才会生效 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。  上述图片中表示: 当请求的 uri 前缀是 /test，并且 header 头上 module 字段值为 test 的时候，会转发到 1.1.1.1:8080 这个服务。\n 选择器建议：可以 uri 条件， match 前缀（/contextPath），进行第一道流量筛选。\n  规则  当流量经过选择器匹配成功之后，会进入规则来进行最终的流量匹配。\n 规则是对流量最终执行逻辑的确认。\n 规则详解：\n 名称：为你的规则起一个容易分辨的名字 匹配方式：and 或者or 是指下面多个条件是按照and 还是or。 条件：  uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配:  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。   是否开启：打开才会生效。 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个规则的时候，执行顺序小的优先执行。 处理：每个插件的规则处理不一样，具体的差有具体的处理，具体请查看每个对应插件的处理。  上图表示：当 uri 等于 /http/order/save 的时候该规则被匹配，就会执行该规则中，负载策略是 random。\n 联合选择器，我们来表述一下：当一个 请求的 uri 为 /http/order/save，会通过 random 的方式，转发到 1.1.1.1:8080。\n 规则建议：可以uri 条件， match 最真实的uri路径，进行流量的最终筛选 。\n  条件详解  uri 匹配 （推荐）\n uri 匹配是根据你请求路径中的 uri 来进行匹配，在接入网关的时候，前端几乎不用做任何更改。\n 当使用 match 方式匹配时候，同 springmvc 模糊匹配原理相同。\n 在选择器中，推荐使用 uri 中的前缀来进行匹配，而在规则中，则使用具体路径来进行匹配。\n 该匹配方式的时候，在匹配字段名称可以任意填写，匹配字段值需要正确填写。\n  header 匹配\n header 是根据你的 http 请求头中的字段值来匹配。  query 匹配\n 这个是根据你的 uri 中的查询参数来进行匹配，比如 /test?a=1\u0026amp;amp;\u0026amp;amp;b=2 ，那么可以选择该匹配方式。\n 上述就可以新增一个条件，选取 query 方式, a = 1。\n  ip匹配\n 这个是根据 http调用方的 ip来进行匹配。\n 尤其是在 waf 插件里面，如果发现一个 ip 地址有攻击，可以新增一条匹配条件，填上该 ip，拒绝该 ip 的访问。\n 如果在 ShenYu 前面使用了 nginx 代理，为了获取正确的 ip，你可能要参考 parsing-ip-and-host\n  host 匹配\n 这个是根据 http 调用方的 host 来进行匹配。\n 尤其是在 waf 插件里面，如果发现一个 host 地址有攻击，可以新增一条匹配条件，填上该 host，拒绝该 host 的访问。\n 如果在 ShenYu 前面使用了 nginx 代理，为了获取正确的 host，你可能要参考 parsing-ip-and-host\n  post 匹配\n 不推荐使用。   ","date":-62135596800,"description":"选择器规则详解","dir":"projects/shenyu/selector-and-rule/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"6887c0b18f61f46638e1dbe8b1f3d81ba4003e21","permalink":"/zh/projects/shenyu/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/zh/projects/shenyu/selector-and-rule/","summary":"说明 选择器和规则是 ShenYu 网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。 本篇主要详解 ShenYu 网关中，选择器与规则的概念，以及如何使用。 大体理解","tags":null,"title":"选择器规则详解","type":"projects","url":"/zh/projects/shenyu/selector-and-rule/","wordcount":1802},{"author":null,"categories":null,"content":" 说明  本篇是对admin后台操作数据以后，同步到网关的流程介绍。  使用  用户可以在 soul-admin 后台任意修改数据，并马上同步到网关的jvm内存中。 同步soul的插件数据，选择器，规则数据，元数据，签名数据等等。 所有插件的选择器，规则都是动态配置，立即生效，不需要重启服务。\n 下面是数据流程图：   作用  用户所有的配置都可以动态的更新，任何修改不需要重启服务。 使用了本地缓存，在高并发的时候，提供高效的性能。  ","date":-62135596800,"description":"配置流程介绍","dir":"projects/shenyu-2.3.0/config/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"bbf410184fe19fd6b3bee70be296a59a0f9fe2c7","permalink":"/zh/projects/shenyu-2.3.0/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/config/","summary":"说明 本篇是对admin后台操作数据以后，同步到网关的流程介绍。 使用 用户可以在 soul-admin 后台任意修改数据，并马上同步到网关的jvm内存中。 同步soul","tags":null,"title":"配置流程介绍","type":"projects","url":"/zh/projects/shenyu-2.3.0/config/","wordcount":190},{"author":null,"categories":null,"content":" 说明  本篇是对 shenyu-admin 后台操作数据以后，同步到网关的流程介绍。  使用  用户可以在 shenyu-admin 后台任意修改数据，并马上同步到网关的 jvm 内存中。 同步 ShenYu 的插件数据，选择器，规则数据，元数据，签名数据等等。 所有插件的选择器，规则都是动态配置，立即生效，不需要重启服务。\n 下面是数据流程图：   作用  用户所有的配置都可以动态的更新，任何修改不需要重启服务。 使用了本地缓存，在高并发的时候，提供高效的性能。  ","date":-62135596800,"description":"配置流程介绍","dir":"projects/shenyu/config/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"20586aa9a5526c78299791eb73e78a631b4ffe99","permalink":"/zh/projects/shenyu/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/config/","summary":"说明 本篇是对 shenyu-admin 后台操作数据以后，同步到网关的流程介绍。 使用 用户可以在 shenyu-admin 后台任意修改数据，并马上同步到网关的 jvm 内存中。 同步 ShenYu 的插件数据，选择器","tags":null,"title":"配置流程介绍","type":"projects","url":"/zh/projects/shenyu/config/","wordcount":181},{"author":null,"categories":null,"content":" 说明  soul网关在对目标服务进行代理调用的时候，还容许用户使用 redirect 插件来重定向请求。\n 插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; redirect，设置为开启。 在网关的 pom.xml 文件中添加 redirect 的支持。 如果用户不需要，可以把插件禁用。 选择器和规则，只有匹配的请求，才会进行转发和重定向，请详细看：选择器规则。  Maven 依赖 在 soul-bootstrap 工程的 pom.xml 文件中添加插件依赖。\n\u0026amp;lt;!-- soul redirect plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul redirect plugin end--\u0026amp;gt;  场景  顾名思义，redirect 插件就是对 uri 的重新转发和重定向。\n 重定向  我们在 Rule 配置自定义路径时，应该为一个可达的服务路径。 当匹配到请求后，根据自定义的路径，Soul 网关会进行 308 服务跳转。  网关自身接口转发  当满足匹配规则时，服务内部会使用 DispatcherHandler 内部接口转发。 要实现网关自身接口转发，我们需要在配置路径使用 / 作为前缀开始，具体配置如下图。  ","date":-62135596800,"description":"redirect插件","dir":"projects/shenyu-2.3.0/redirect-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"1eeec216499cf3a07bb40e16d59483e360558969","permalink":"/zh/projects/shenyu-2.3.0/redirect-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu-2.3.0/redirect-plugin/","summary":"说明 soul网关在对目标服务进行代理调用的时候，还容许用户使用 redirect 插件来重定向请求。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; redirect，设置为开启。 在网","tags":null,"title":"重定向插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/redirect-plugin/","wordcount":333},{"author":null,"categories":null,"content":" 说明  ShenYu 网关在对目标服务进行代理调用的时候，还容许用户使用 redirect 插件来重定向请求。\n 插件设置  在 shenyu-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; redirect，设置为开启。 在网关的 pom.xml 文件中添加 redirect 的支持。 如果用户不需要，可以把插件禁用。 选择器和规则，只有匹配的请求，才会进行转发和重定向，请详细看：选择器规则。  Maven 依赖 在 shenyu-bootstrap 工程的 pom.xml 文件中添加插件依赖。\n\u0026amp;lt;!-- shenyu redirect plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-redirect\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu redirect plugin end--\u0026amp;gt;  场景  顾名思义，redirect 插件就是对 uri 的重新转发和重定向。\n 重定向  我们在 Rule 配置自定义路径时，应该为一个可达的服务路径。 当匹配到请求后，根据自定义的路径，ShenYu 网关会进行 308 服务跳转。  网关自身接口转发  当满足匹配规则时，服务内部会使用 DispatcherHandler 内部接口转发。 要实现网关自身接口转发，我们需要在配置路径使用 / 作为前缀开始，具体配置如下图。  ","date":-62135596800,"description":"redirect插件","dir":"projects/shenyu/redirect-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"ab25f8728282fabe9338d1effc26700c2c88b03f","permalink":"/zh/projects/shenyu/redirect-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/projects/shenyu/redirect-plugin/","summary":"说明 ShenYu 网关在对目标服务进行代理调用的时候，还容许用户使用 redirect 插件来重定向请求。 插件设置 在 shenyu-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; redirect，设置为开启。 在网关的 pom.xml","tags":null,"title":"重定向插件","type":"projects","url":"/zh/projects/shenyu/redirect-plugin/","wordcount":332},{"author":null,"categories":null,"content":" 说明  限流插件，是网关对流量管控限制核心的实现。\n soul网关提供了多种限流算法的实现，包括令牌桶算法、并发的令牌桶算法、漏桶算法、滑动时间窗口算法。\n soul网关的限流算法实现都是基于redis。\n 可以到接口级别，也可以到参数级别，具体怎么用，还得看你对流量配置。\n  技术方案 采用redis令牌桶算法进行限流。  系统以恒定的速率产⽣令牌，然后将令牌放⼊令牌桶中。 令牌桶有⼀个容量，当令牌桶满了的时候，再向其中放⼊的令牌就会被丢弃。 每次⼀个请求过来，需要从令牌桶中获取⼀个令牌，如果有令牌，则提供服务；如果没有令牌，则拒绝服务。\n 流程图：   采用redis漏桶算法进行限流。  ⽔（请求）先进⼊到漏桶⾥，漏桶以⼀定的速度出⽔，当⽔流⼊速度过⼤会直接溢出（拒绝服务）\n 流程图：   基于redis实现的滑动窗口算法  滑动时间窗口通过维护⼀个单位时间内的计数值，每当⼀个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下⼀轮的计数。\n 算法图：  流程图：   插件设置  在 soul-admin\u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; rate_limiter 将其设置为开启。\n 在插件中，对redis进行配置。\n 目前支持redis的单机，哨兵，以及集群模式。\n 如果是哨兵，集群等多节点的，在URL中的配置，请对每个实列使用 ; 分割. 如 192.168.1.1:6379;192.168.1.2:6379。\n 如果用户无需使用，在admin后台把插件禁用。\n  插件使用  在网关的 pom.xml 文件中添加 rateLimiter的支持。  \u0026amp;lt;!-- soul ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul ratelimiter plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 规则详细说明\n  令牌桶算法/并发令牌桶算法   algorithmName（算法名）：tocketBucket/concurrent\nreplenishRate（速率）：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。\nburstCapacity（容量）：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。\n * 漏桶算法  algorithmName（算法名）：leakyBucket\nreplenishRate（速率）：单位时间内执行请求的速率，漏桶中水滴漏出的速率。\nburstCapacity（容量）：是允许用户在一秒钟内执行的最大请求数。这是桶中的水量。\n * 滑动窗口算法  algorithmName（算法名）：sildingWindow\nreplenishRate（速率）：单位时间内执行请求的速率，用于计算时间窗口大小。\nburstCapacity（容量）：时间窗口内（单位时间内）最大的请求数量。\n","date":-62135596800,"description":"rateLimiter插件","dir":"projects/shenyu-2.3.0/rate-limiter-plugin/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"c0db09004640ac3b8f33aa33feb5091b998aed34","permalink":"/zh/projects/shenyu-2.3.0/rate-limiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu-2.3.0/rate-limiter-plugin/","summary":"说明 限流插件，是网关对流量管控限制核心的实现。 soul网关提供了多种限流算法的实现，包括令牌桶算法、并发的令牌桶算法、漏桶算法、滑动时间窗口","tags":null,"title":"限流插件","type":"projects","url":"/zh/projects/shenyu-2.3.0/rate-limiter-plugin/","wordcount":1074},{"author":null,"categories":null,"content":" 说明  限流插件，是网关对流量管控限制核心的实现。\n ShenYu 网关提供了多种限流算法的实现，包括令牌桶算法、并发的令牌桶算法、漏桶算法、滑动时间窗口算法。\n ShenYu 网关的限流算法实现都是基于redis。\n 可以到接口级别，也可以到参数级别，具体怎么用，还得看你对流量配置。\n  技术方案 采用redis令牌桶算法进行限流。  系统以恒定的速率产⽣令牌，然后将令牌放⼊令牌桶中。 令牌桶有⼀个容量，当令牌桶满了的时候，再向其中放⼊的令牌就会被丢弃。 每次⼀个请求过来，需要从令牌桶中获取⼀个令牌，如果有令牌，则提供服务；如果没有令牌，则拒绝服务。\n 流程图：   采用redis漏桶算法进行限流。  ⽔（请求）先进⼊到漏桶⾥，漏桶以⼀定的速度出⽔，当⽔流⼊速度过⼤会直接溢出（拒绝服务）\n 流程图：   基于redis实现的滑动窗口算法  滑动时间窗口通过维护⼀个单位时间内的计数值，每当⼀个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下⼀轮的计数。\n 算法图：  流程图：   插件设置  在 shenyu-admin\u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; rate_limiter 将其设置为开启。\n 在插件中，对redis进行配置。\n 目前支持redis的单机，哨兵，以及集群模式。\n 如果是哨兵，集群等多节点的，在URL中的配置，请对每个实列使用 ; 分割. 如 192.168.1.1:6379;192.168.1.2:6379。\n 如果用户无需使用，在admin后台把插件禁用。\n  插件使用  在网关的 pom.xml 文件中添加 rateLimiter的支持。  \u0026amp;lt;!-- shenyu ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.shenyu\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;shenyu-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- shenyu ratelimiter plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 规则详细说明\n  令牌桶算法/并发令牌桶算法   algorithmName（算法名）：tocketBucket/concurrent\nreplenishRate（速率）：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。\nburstCapacity（容量）：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。\n * 漏桶算法  algorithmName（算法名）：leakyBucket\nreplenishRate（速率）：单位时间内执行请求的速率，漏桶中水滴漏出的速率。\nburstCapacity（容量）：是允许用户在一秒钟内执行的最大请求数。这是桶中的水量。\n * 滑动窗口算法  algorithmName（算法名）：sildingWindow\nreplenishRate（速率）：单位时间内执行请求的速率，用于计算时间窗口大小。\nburstCapacity（容量）：时间窗口内（单位时间内）最大的请求数量。\n","date":-62135596800,"description":"rateLimiter插件","dir":"projects/shenyu/rate-limiter-plugin/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1624774609,"objectID":"27f7161653b927d5d1d8a1ba3a77f4f4cc18e93b","permalink":"/zh/projects/shenyu/rate-limiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/projects/shenyu/rate-limiter-plugin/","summary":"说明 限流插件，是网关对流量管控限制核心的实现。 ShenYu 网关提供了多种限流算法的实现，包括令牌桶算法、并发的令牌桶算法、漏桶算法、滑动时间窗口算法。","tags":null,"title":"限流插件","type":"projects","url":"/zh/projects/shenyu/rate-limiter-plugin/","wordcount":1068}]